//! Rust code generation
//!
//! Generates a Rust module that loads assets from embedded ember binary data.

use anyhow::Result;
use std::fs;
use std::path::Path;

use crate::manifest::Manifest;
use crate::{EWZ_MESH_EXT, EWZ_SOUND_EXT, EWZ_TEXTURE_EXT};

/// Generate a Rust module that loads assets
///
/// The generated module will:
/// 1. Embed all assets via `include_bytes!`
/// 2. Define an `Assets` struct with handles for each asset
/// 3. Provide a `load()` function that loads all assets
///
/// # Generated code example:
/// ```rust,ignore
/// //! Auto-generated by ember-export
///
/// mod assets {
///     // Embedded data
///     static PLAYER_MESH: &[u8] = include_bytes!("../assets/player.ewzmesh");
///     static PLAYER_TEX: &[u8] = include_bytes!("../assets/player.ewztex");
///
///     extern "C" {
///         fn rom_mesh(data_ptr: u32, data_len: u32) -> u32;
///         fn rom_texture(data_ptr: u32, data_len: u32) -> u32;
///         fn rom_sound(data_ptr: u32, data_len: u32) -> u32;
///     }
///
///     pub struct Assets {
///         pub player_mesh: u32,
///         pub player_tex: u32,
///     }
///
///     pub fn load() -> Assets {
///         Assets {
///             player_mesh: unsafe { rom_mesh(PLAYER_MESH.as_ptr() as u32, PLAYER_MESH.len() as u32) },
///             player_tex: unsafe { rom_texture(PLAYER_TEX.as_ptr() as u32, PLAYER_TEX.len() as u32) },
///         }
///     }
/// }
/// ```
pub fn generate_rust_module(manifest: &Manifest, output_path: &Path) -> Result<()> {
    let mut code = String::new();

    // Header
    code.push_str("//! Auto-generated by ember-export - DO NOT EDIT\n");
    code.push_str("//!\n");
    code.push_str("//! This module provides access to all assets defined in assets.toml.\n");
    code.push_str("//! Call `load()` during your game's `init()` to load all assets.\n");
    code.push('\n');
    code.push_str("#![allow(dead_code)]\n");
    code.push('\n');

    // Collect all assets
    let mut mesh_assets: Vec<(&String, String)> = Vec::new();
    let mut texture_assets: Vec<(&String, String)> = Vec::new();
    let mut sound_assets: Vec<(&String, String)> = Vec::new();

    let output_dir = &manifest.output.dir;

    // Meshes
    for name in manifest.meshes.keys() {
        let output_file = format!("{}/{}.{}", output_dir.display(), name, EWZ_MESH_EXT);
        mesh_assets.push((name, output_file));
    }

    // Textures
    for name in manifest.textures.keys() {
        let output_file = format!("{}/{}.{}", output_dir.display(), name, EWZ_TEXTURE_EXT);
        texture_assets.push((name, output_file));
    }

    // Sounds
    for name in manifest.sounds.keys() {
        let output_file = format!("{}/{}.{}", output_dir.display(), name, EWZ_SOUND_EXT);
        sound_assets.push((name, output_file));
    }

    // Generate relative paths from the generated file to the asset files
    let output_parent = output_path.parent().unwrap_or(Path::new("."));

    // Static embedded data
    code.push_str("// Embedded asset data\n");

    for (name, path) in &mesh_assets {
        let rel_path = make_relative_path(output_parent, Path::new(path));
        let const_name = to_const_name(name, "MESH");
        code.push_str(&format!("static {}: &[u8] = include_bytes!(\"{}\");\n", const_name, rel_path));
    }

    for (name, path) in &texture_assets {
        let rel_path = make_relative_path(output_parent, Path::new(path));
        let const_name = to_const_name(name, "TEX");
        code.push_str(&format!("static {}: &[u8] = include_bytes!(\"{}\");\n", const_name, rel_path));
    }

    for (name, path) in &sound_assets {
        let rel_path = make_relative_path(output_parent, Path::new(path));
        let const_name = to_const_name(name, "SND");
        code.push_str(&format!("static {}: &[u8] = include_bytes!(\"{}\");\n", const_name, rel_path));
    }

    code.push('\n');

    // FFI declarations
    code.push_str("// FFI functions for loading assets\n");
    code.push_str("extern \"C\" {\n");
    if !mesh_assets.is_empty() {
        code.push_str("    fn rom_mesh(data_ptr: u32, data_len: u32) -> u32;\n");
    }
    if !texture_assets.is_empty() {
        code.push_str("    fn rom_texture(data_ptr: u32, data_len: u32) -> u32;\n");
    }
    if !sound_assets.is_empty() {
        code.push_str("    fn rom_sound(data_ptr: u32, data_len: u32) -> u32;\n");
    }
    code.push_str("}\n\n");

    // Assets struct
    code.push_str("/// Loaded asset handles\n");
    code.push_str("#[derive(Debug, Clone, Copy)]\n");
    code.push_str("pub struct Assets {\n");

    for (name, _) in &mesh_assets {
        let field_name = to_field_name(name);
        code.push_str(&format!("    /// Mesh handle for '{}'\n", name));
        code.push_str(&format!("    pub {}_mesh: u32,\n", field_name));
    }

    for (name, _) in &texture_assets {
        let field_name = to_field_name(name);
        code.push_str(&format!("    /// Texture handle for '{}'\n", name));
        code.push_str(&format!("    pub {}_tex: u32,\n", field_name));
    }

    for (name, _) in &sound_assets {
        let field_name = to_field_name(name);
        code.push_str(&format!("    /// Sound handle for '{}'\n", name));
        code.push_str(&format!("    pub {}_snd: u32,\n", field_name));
    }

    code.push_str("}\n\n");

    // Load function
    code.push_str("/// Load all assets\n");
    code.push_str("///\n");
    code.push_str("/// Call this during your game's `init()` function.\n");
    code.push_str("/// Returns an `Assets` struct with handles to all loaded assets.\n");
    code.push_str("pub fn load() -> Assets {\n");
    code.push_str("    Assets {\n");

    for (name, _) in &mesh_assets {
        let field_name = to_field_name(name);
        let const_name = to_const_name(name, "MESH");
        code.push_str(&format!(
            "        {}_mesh: unsafe {{ rom_mesh({}.as_ptr() as u32, {}.len() as u32) }},\n",
            field_name, const_name, const_name
        ));
    }

    for (name, _) in &texture_assets {
        let field_name = to_field_name(name);
        let const_name = to_const_name(name, "TEX");
        code.push_str(&format!(
            "        {}_tex: unsafe {{ rom_texture({}.as_ptr() as u32, {}.len() as u32) }},\n",
            field_name, const_name, const_name
        ));
    }

    for (name, _) in &sound_assets {
        let field_name = to_field_name(name);
        let const_name = to_const_name(name, "SND");
        code.push_str(&format!(
            "        {}_snd: unsafe {{ rom_sound({}.as_ptr() as u32, {}.len() as u32) }},\n",
            field_name, const_name, const_name
        ));
    }

    code.push_str("    }\n");
    code.push_str("}\n");

    // Write file
    if let Some(parent) = output_path.parent() {
        fs::create_dir_all(parent)?;
    }
    fs::write(output_path, code)?;

    tracing::info!("Generated Rust module: {:?}", output_path);

    Ok(())
}

/// Convert asset name to constant name (e.g., "player" -> "PLAYER_MESH")
fn to_const_name(name: &str, suffix: &str) -> String {
    format!("{}_{}", name.to_uppercase().replace('-', "_"), suffix)
}

/// Convert asset name to field name (e.g., "player-sprite" -> "player_sprite")
fn to_field_name(name: &str) -> String {
    name.to_lowercase().replace('-', "_")
}

/// Create a relative path from `from` to `to`
fn make_relative_path(_from: &Path, to: &Path) -> String {
    // Simple implementation: just use the path as-is for now
    // A more sophisticated version would compute actual relative paths
    to.to_string_lossy()
        .replace('\\', "/")  // Use forward slashes for cross-platform compatibility
}
