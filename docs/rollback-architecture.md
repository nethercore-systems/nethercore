# Emberware Rollback Netcode Architecture

## Core Principle

**Snapshot WASM linear memory for rollback. Keep resources in GPU memory.**

This gives you:
- ✅ Normal programming patterns (dynamic arrays, hash maps, etc.)
- ✅ Small snapshots (game state only)
- ✅ Fast rollback
- ✅ Transparent to developers

---

## WASM Memory Layout

WASM separates code from data:

```
┌─────────────────────────────────────┐
│ CODE SECTION (not in linear memory) │
│ - Compiled functions                │
│ - Embedded data (assets)            │  ← Assets live here
│ - Never changes after load          │
└─────────────────────────────────────┘

┌─────────────────────────────────────┐
│ LINEAR MEMORY (what we snapshot)    │
│ - Stack                             │
│ - Heap (allocations, game state)    │  ← Game state lives here
│ - Globals                           │
└─────────────────────────────────────┘
```

**Key:** Embedded assets are in the code section, NOT linear memory.

---

## How It Works

### 1. Embed Assets at Compile Time

Assets are embedded in the WASM binary during compilation, not loaded at runtime.

**Examples:**
- Rust: `include_bytes!("player.png")`
- Zig: `@embedFile("player.png")`
- C: Use a tool to generate `.c` files with byte arrays

### 2. Load Resources to GPU During Initialization

During your game's init function, pass pointers to embedded data. The host decodes and uploads to GPU.

```c
// Pseudocode - actual syntax depends on language
void init() {
    // player_png_data is embedded in code section
    int player_tex = load_texture(
        &player_png_data,
        256, 256,
        TEX_RGBA
    );
    
    // Store just the ID (4 bytes)
    game.player_texture = player_tex;
}
```

### 3. Use Normal Programming Patterns

Game state lives in linear memory. Use whatever data structures your language provides.

```c
// Pseudocode
struct GameState {
    Enemy* enemies;      // Dynamic array
    Item* items;         // Hash map, linked list, whatever
    int enemy_count;
    
    int player_texture;  // Just an ID (4 bytes)
    int enemy_mesh;      // Just an ID (4 bytes)
}
```

### 4. Rollback Snapshots Game State Only

The host snapshots WASM linear memory. Resources stay in GPU memory.

```rust
// Host implementation (not game code)
fn save_state(&self) -> Vec<u8> {
    self.instance.memory().to_vec()
}

fn restore_state(&mut self, snapshot: &[u8]) {
    self.instance.memory_mut().copy_from_slice(&snapshot);
}
```

---

## Memory Architecture

```
┌────────────────────────────────────────┐
│ GPU MEMORY (Host Side)                 │
│ - Textures (decoded, ready to render) │  ← NOT snapshotted
│ - Meshes (uploaded to GPU)            │  ← NOT snapshotted
│ - Vertex/index buffers                │
└────────────────────────────────────────┘

┌────────────────────────────────────────┐
│ WASM LINEAR MEMORY                     │
│ - Game state (allocations)            │  ← Snapshotted
│ - Resource IDs (integers)             │  ← Snapshotted
│ - Stack/globals                       │  ← Snapshotted
└────────────────────────────────────────┘
```

**Result:** Only game state gets snapshotted. Resources stay in GPU memory.

---

## What NOT to Do

❌ **Don't decode/process assets into WASM heap:**

```c
// BAD - decoding into WASM linear memory
void init() {
    uint8_t* decoded = decode_png(player_png_data, &size);  // Heap allocation!
    int tex = load_texture(decoded, 256, 256, TEX_RGBA);
    // Now 5 MB of decoded pixels sit in WASM memory forever
}
```

✅ **Do pass pointers directly:**

```c
// GOOD - host decodes and uploads to GPU
void init() {
    int tex = load_texture(player_png_data, 256, 256, TEX_RGBA);
    // Only the ID (4 bytes) lives in WASM memory
}
```

---

## Language Examples

### Rust

```rust
static PLAYER_PNG: &[u8] = include_bytes!("assets/player.png");

#[no_mangle]
pub extern "C" fn init() {
    let tex = load_texture(PLAYER_PNG.as_ptr(), 256, 256, TEX_RGBA);
}
```

### Zig

```zig
const player_png = @embedFile("assets/player.png");

export fn init() void {
    const tex = load_texture(&player_png[0], 256, 256, TEX_RGBA);
}
```

### C

```c
// player.png.c (generated by tool)
const unsigned char player_png_data[] = { /* bytes */ };
const unsigned int player_png_size = 12345;

// game.c
extern const unsigned char player_png_data[];

void init() {
    int tex = load_texture(player_png_data, 256, 256, TEX_RGBA);
}
```

---

## Summary

1. **Embed assets** in WASM binary (code section)
2. **Load to GPU** during init (host memory)
3. **Store IDs** in game state (4 bytes each)
4. **Snapshot linear memory** (game state only)

**Result:** Normal programming patterns + deterministic rollback netcode.

**Works with:** Rust, Zig, C, C++, AssemblyScript, or any language that compiles to WASM.

See console-specific docs for memory limits.