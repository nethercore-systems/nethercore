# Emberware Asset Pipeline

Convert 3D models, textures, fonts, and audio into optimized Emberware formats.

> **Implementation Status:** The `ember-export` tool and manifest workflow are planned but not yet implemented. See [asset-pipeline-spec.md](asset-pipeline-spec.md) for implementation details. Currently, assets must be loaded manually using the FFI functions documented in the [Manual Integration](#advanced-manual-integration) section.

---

## Quick Start (Planned)

Once implemented, getting assets into an Emberware game will be 3 steps:

**1. Export from your 3D tool** (Blender, Maya, etc.) as glTF, FBX, or OBJ

**2. Create `assets.toml`:**
```toml
[output]
rust = "src/assets.rs"

[meshes]
player = "models/player.gltf"
enemy = "models/enemy.fbx"

[textures]
grass = "textures/grass.png"
```

**3. Build and use:**
```bash
ember-export build assets.toml
```

```rust
fn init() {
    let assets = assets::load();
    // Use assets.player, assets.enemy, assets.grass
}
```

One manifest, one command, one line to load everything.

---

## Supported Input Formats

### 3D Models

| Format | Extension | Recommended For |
|--------|-----------|-----------------|
| **glTF 2.0** | `.gltf`, `.glb` | Primary format. Blender default, industry standard, best tooling support |
| **FBX** | `.fbx` | Complex scenes, animations, legacy pipelines |
| **OBJ** | `.obj` | Simple geometry, ASCII-based, universal support |

**Recommendation:** Use glTF for new projects. It's the "JPEG of 3D" - efficient, well-documented, and supported everywhere.

### Textures

| Format | Notes |
|--------|-------|
| **PNG** | Lossless, supports transparency |
| **JPG** | Lossy, smaller files, no transparency |

### Fonts

| Format | Notes |
|--------|-------|
| **TTF** | TrueType fonts |
| **OTF** | OpenType fonts |

### Audio

| Format | Notes |
|--------|-------|
| **WAV** | Uncompressed, best quality |
| **OGG** | Compressed, good for music |
| **MP3** | Compressed, widely supported |

---

## Manifest-Based Asset Pipeline (Planned)

> **Status:** Not yet implemented. See [asset-pipeline-spec.md](asset-pipeline-spec.md) for implementation guide.

Define all your game assets in a single `assets.toml` file, then build everything with one command.

### assets.toml Reference

```toml
# Output configuration
[output]
rust = "src/assets.rs"          # Generated Rust module
# c = "include/assets.h"        # Future: C header generation

# 3D Models
[meshes]
player = "models/player.gltf"                           # Simple: just the path
enemy = "models/enemy.fbx"
level = { path = "models/level.obj", format = "POS_UV_NORMAL" }  # With options

# Textures
[textures]
player_diffuse = "textures/player.png"
grass = { path = "textures/grass.png", palette = 256 }  # Palette mode (smaller)

# Fonts
[fonts]
ui = { path = "fonts/roboto.ttf", size = 16 }
title = { path = "fonts/title.otf", size = 32, charset = "ascii" }

# Audio
[sounds]
jump = "audio/jump.wav"
music = "audio/theme.ogg"
```

### Build Commands

```bash
# Build all assets from manifest
ember-export build assets.toml

# Watch mode - rebuilds on file changes
ember-export build assets.toml --watch

# Validate manifest without building
ember-export check assets.toml
```

### Generated Code

Running `ember-export build assets.toml` generates:

1. **Binary asset files** in `assets/` directory:
   - `player.embermesh`, `enemy.embermesh`, `level.embermesh`
   - `player_diffuse.embertex`, `grass.embertex`
   - `ui.emberfont`, `title.emberfont`
   - `jump.embersnd`, `music.embersnd`

2. **Rust module** at the path specified in `[output].rust`:

```rust
// AUTO-GENERATED by ember-export - do not edit
// Source: assets.toml

pub mod assets {
    // Embedded binary data (compile-time, zero runtime overhead)
    static PLAYER_MESH: &[u8] = include_bytes!("../assets/player.embermesh");
    static ENEMY_MESH: &[u8] = include_bytes!("../assets/enemy.embermesh");
    static LEVEL_MESH: &[u8] = include_bytes!("../assets/level.embermesh");
    static PLAYER_DIFFUSE_TEX: &[u8] = include_bytes!("../assets/player_diffuse.embertex");
    static GRASS_TEX: &[u8] = include_bytes!("../assets/grass.embertex");
    static UI_FONT: &[u8] = include_bytes!("../assets/ui.emberfont");
    static TITLE_FONT: &[u8] = include_bytes!("../assets/title.emberfont");
    static JUMP_SFX: &[u8] = include_bytes!("../assets/jump.embersnd");
    static MUSIC_SFX: &[u8] = include_bytes!("../assets/music.embersnd");

    /// All loaded asset handles
    pub struct AssetPack {
        // Meshes
        pub player: u32,
        pub enemy: u32,
        pub level: u32,
        // Textures
        pub player_diffuse: u32,
        pub grass: u32,
        // Fonts
        pub ui_font: u32,
        pub title_font: u32,
        // Sounds
        pub jump: u32,
        pub music: u32,
    }

    /// Load all assets. Call once in init().
    pub fn load() -> AssetPack {
        AssetPack {
            player: load_mesh_from_embermesh(PLAYER_MESH),
            enemy: load_mesh_from_embermesh(ENEMY_MESH),
            level: load_mesh_from_embermesh(LEVEL_MESH),
            player_diffuse: load_texture_from_embertex(PLAYER_DIFFUSE_TEX),
            grass: load_texture_from_embertex(GRASS_TEX),
            ui_font: load_font_from_emberfont(UI_FONT),
            title_font: load_font_from_emberfont(TITLE_FONT),
            jump: load_sound_from_embersnd(JUMP_SFX),
            music: load_sound_from_embersnd(MUSIC_SFX),
        }
    }
}
```

### Using in Your Game

```rust
fn init() {
    let assets = assets::load();

    // Now use the handles:
    // assets.player      - mesh handle
    // assets.grass       - texture handle
    // assets.ui_font     - font handle
    // assets.jump        - sound handle
}
```

**Key benefits:**
- Zero runtime overhead (all `include_bytes!` at compile time)
- Type-safe struct with named fields
- Single entry point - no boilerplate

---

## Output File Formats (Planned)

> **Status:** These binary formats are specified but not yet implemented. The `ember-export` tool will generate these files.

### EmberMesh (.embermesh)

Binary format for 3D meshes with GPU-optimized packed vertex data.

**Header (24 bytes):**
```
Offset | Type    | Description
-------|---------|----------------------------------
0x00   | char[4] | Magic: "EMSH"
0x04   | u32     | Format version (1)
0x08   | u32     | Vertex count
0x0C   | u32     | Index count
0x10   | u8      | Vertex format flags (0-15)
0x11   | u8      | Packing mode (1 = packed)
0x12   | u16     | Reserved
0x14   | u32     | Stride (bytes per vertex)
0x18   | data    | Vertex data (vertex_count * stride bytes)
0x??   | u16[]   | Index data (index_count * 2 bytes)
```

### EmberTexture (.embertex)

Binary format for textures.

**Header (24 bytes):**
```
Offset | Type    | Description
-------|---------|----------------------------------
0x00   | char[4] | Magic: "EMTX"
0x04   | u32     | Format version (1)
0x08   | u32     | Width in pixels
0x0C   | u32     | Height in pixels
0x10   | u32     | Pixel format (0=RGBA8, 1=Palette256)
0x14   | u32     | Reserved
0x18   | u8[]    | Pixel data
```

**Pixel formats:**
- **RGBA8**: 4 bytes per pixel (width * height * 4 bytes)
- **Palette256**: 1024-byte palette + 1 byte per pixel (75% smaller)

### EmberFont (.emberfont)

Binary format for bitmap font atlases.

**Header:**
```
Offset | Type    | Description
-------|---------|----------------------------------
0x00   | char[4] | Magic: "EMFT"
0x04   | u32     | Format version (1)
0x08   | u32     | Atlas width
0x0C   | u32     | Atlas height
0x10   | f32     | Line height
0x14   | f32     | Baseline offset
0x18   | u32     | Glyph count
0x1C   | u32     | Reserved
0x20   | Glyph[] | Glyph metadata (16 bytes each)
0x??   | u8[]    | Atlas texture (RGBA8)
```

### EmberSound (.embersnd)

Binary format for audio.

**Header (24 bytes):**
```
Offset | Type    | Description
-------|---------|----------------------------------
0x00   | char[4] | Magic: "EMSN"
0x04   | u32     | Format version (1)
0x08   | u32     | Sample rate (22050)
0x0C   | u32     | Sample count
0x10   | u32     | Audio format (0=PCM16)
0x14   | u32     | Reserved
0x18   | i16[]   | PCM samples
```

---

## Vertex Formats (Implemented)

The Emberware runtime supports 16 vertex format combinations, controlled by format flags. These are used by the existing `load_mesh` FFI functions.

```rust
FORMAT_UV      = 1   // Texture coordinates
FORMAT_COLOR   = 2   // Per-vertex color
FORMAT_NORMAL  = 4   // Surface normals
FORMAT_SKINNED = 8   // Bone weights for skeletal animation
```

### All 16 Formats

| Format | Name | Packed Stride | Unpacked Stride |
|--------|------|---------------|-----------------|
| 0 | POS | 8 bytes | 12 bytes |
| 1 | POS_UV | 12 bytes | 20 bytes |
| 2 | POS_COLOR | 12 bytes | 24 bytes |
| 3 | POS_UV_COLOR | 16 bytes | 32 bytes |
| 4 | POS_NORMAL | 12 bytes | 24 bytes |
| 5 | POS_UV_NORMAL | 16 bytes | 32 bytes |
| 6 | POS_COLOR_NORMAL | 16 bytes | 36 bytes |
| 7 | POS_UV_COLOR_NORMAL | 20 bytes | 44 bytes |
| 8 | POS_SKINNED | 16 bytes | 32 bytes |
| 9 | POS_UV_SKINNED | 20 bytes | 40 bytes |
| 10 | POS_COLOR_SKINNED | 20 bytes | 44 bytes |
| 11 | POS_UV_COLOR_SKINNED | 24 bytes | 52 bytes |
| 12 | POS_NORMAL_SKINNED | 20 bytes | 44 bytes |
| 13 | POS_UV_NORMAL_SKINNED | 24 bytes | 52 bytes |
| 14 | POS_COLOR_NORMAL_SKINNED | 24 bytes | 56 bytes |
| 15 | POS_UV_COLOR_NORMAL_SKINNED | 28 bytes | 64 bytes |

**Common formats:**
- **Format 5 (POS_UV_NORMAL)**: Most common for textured, lit meshes
- **Format 13 (POS_UV_NORMAL_SKINNED)**: Animated characters

---

## Packed Vertex Data (Implemented)

The runtime automatically packs vertex data using GPU-optimized formats for smaller memory footprint and faster uploads.

### Attribute Encoding

| Attribute | Packed Format | Size | Notes |
|-----------|--------------|------|-------|
| Position | Float16x4 | 8 bytes | x, y, z, w=1.0 |
| UV | Unorm16x2 | 4 bytes | 65536 values in [0,1], better precision than f16 |
| Color | Unorm8x4 | 4 bytes | RGBA, alpha=255 if not provided |
| Normal | Octahedral u32 | 4 bytes | ~0.02° angular precision |
| Bone Indices | Uint8x4 | 4 bytes | Up to 256 bones |
| Bone Weights | Unorm8x4 | 4 bytes | Normalized to [0,255] |

### Octahedral Normal Encoding

Normals use octahedral encoding for uniform angular precision with 66% size reduction:

```
Standard normal: 3 floats × 4 bytes = 12 bytes
Octahedral:      1 u32              =  4 bytes
```

**How it works:**
1. Project 3D unit vector onto octahedron surface
2. Unfold octahedron to 2D square [-1, 1]²
3. Pack as 2× snorm16 into single u32

**Precision:** ~0.02° worst-case angular error - uniform across the entire sphere.

The vertex shader decodes the normal automatically.

### Memory Savings

| Format | Unpacked | Packed | Savings |
|--------|----------|--------|---------|
| POS_UV_NORMAL | 32 bytes | 16 bytes | 50% |
| POS_UV_NORMAL_SKINNED | 52 bytes | 24 bytes | 54% |
| Full format (15) | 64 bytes | 28 bytes | 56% |

---

## Skeletal Animation (Implemented)

### Vertex Skinning Data

Each skinned vertex stores:
- **Bone Indices**: Uint8x4 (4 bytes) - which bones affect this vertex (0-255)
- **Bone Weights**: Unorm8x4 (4 bytes) - influence weights, normalized

### Bone Matrices

Bone transforms use 3×4 affine matrices (not 4×4):

```
set_bones(matrices_ptr, count)
```

**3×4 Matrix Layout (column-major, 12 floats per bone):**
```
[m00, m10, m20]  ← column 0 (X basis)
[m01, m11, m21]  ← column 1 (Y basis)
[m02, m12, m22]  ← column 2 (Z basis)
[m03, m13, m23]  ← column 3 (translation)
```

The bottom row `[0, 0, 0, 1]` is implicit (affine transform).

**Limits:**
- Maximum 256 bones per skeleton
- 48 bytes per bone (vs 64 bytes for 4×4) - 25% memory savings

---

## Tool Reference (Planned)

> **Status:** The `ember-export` CLI tool is not yet implemented. See [asset-pipeline-spec.md](asset-pipeline-spec.md) for implementation guide.

### ember-export

The asset conversion CLI tool.

**Build from manifest:**
```bash
ember-export build assets.toml           # Build all assets
ember-export build assets.toml --watch   # Watch for changes
ember-export check assets.toml           # Validate only
```

**Convert individual files:**
```bash
# Meshes
ember-export mesh player.gltf -o player.embermesh
ember-export mesh level.fbx -o level.embermesh --format POS_UV_NORMAL

# Textures
ember-export texture grass.png -o grass.embertex
ember-export texture sprites.png -o sprites.embertex --palette 256

# Fonts
ember-export font roboto.ttf -o ui.emberfont --size 16
ember-export font title.otf -o title.emberfont --size 32 --charset ascii

# Audio
ember-export audio jump.wav -o jump.embersnd
ember-export audio music.ogg -o music.embersnd
```

---

## Manual Integration (Current Method)

Until `ember-export` is implemented, load assets manually using these FFI functions. This is also available for fine-grained control once the tooling exists.

### Load APIs

**Convenience API** (f32 input, auto-packed):
```rust
load_mesh(data_ptr, vertex_count, format) -> u32
load_mesh_indexed(data_ptr, vertex_count, index_ptr, index_count, format) -> u32
```

**Power User API** (pre-packed data):
```rust
load_mesh_packed(data_ptr, vertex_count, format) -> u32
load_mesh_indexed_packed(data_ptr, vertex_count, index_ptr, index_count, format) -> u32
```

### Manual Binary Loading

```rust
static MESH_DATA: &[u8] = include_bytes!("assets/player.embermesh");

fn init() {
    // Parse header
    let vertex_count = u32::from_le_bytes([MESH_DATA[8], MESH_DATA[9], MESH_DATA[10], MESH_DATA[11]]);
    let index_count = u32::from_le_bytes([MESH_DATA[12], MESH_DATA[13], MESH_DATA[14], MESH_DATA[15]]);
    let format = MESH_DATA[16];
    let stride = u32::from_le_bytes([MESH_DATA[20], MESH_DATA[21], MESH_DATA[22], MESH_DATA[23]]);

    // Calculate offsets
    let vertex_data_start = 24;
    let vertex_data_size = vertex_count as usize * stride as usize;
    let index_data_start = vertex_data_start + vertex_data_size;

    // Load mesh
    let mesh = load_mesh_indexed_packed(
        &MESH_DATA[vertex_data_start] as *const u8 as u32,
        vertex_count,
        &MESH_DATA[index_data_start] as *const u8 as u32,
        index_count,
        format as u32,
    );
}
```

---

## Constraints

Emberware enforces these limits:

| Resource | Limit |
|----------|-------|
| ROM size | 12 MB |
| VRAM | 4 MB |
| Bones per skeleton | 256 |

All assets are embedded in the WASM binary at compile time. There is no runtime asset loading - this ensures deterministic builds required for rollback netcode.
