<!DOCTYPE HTML>
<html lang="en" class="navy sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nethercore ZX API Reference</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="Complete API documentation for the Nethercore ZX fantasy console">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon-de23e50b.svg">
        <link rel="shortcut icon" href="favicon-8114d1fc.png">
        <link rel="stylesheet" href="css/variables-8adf115d.css">
        <link rel="stylesheet" href="css/general-2459343d.css">
        <link rel="stylesheet" href="css/chrome-ae938929.css">
        <link rel="stylesheet" href="css/print-9e4910d8.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="fonts/fonts-9644e21d.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="mdbook-highlight-css" href="highlight-493f70e1.css">
        <link rel="stylesheet" id="mdbook-tomorrow-night-css" href="tomorrow-night-4c0ae647.css">
        <link rel="stylesheet" id="mdbook-ayu-highlight-css" href="ayu-highlight-3fdfc3ac.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "navy";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex-34d68c72.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc-f2f77113.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="mdbook-body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('navy')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="mdbook-sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("mdbook-sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="mdbook-sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="mdbook-sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="mdbook-page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="mdbook-menu-bar-hover-placeholder"></div>
                <div id="mdbook-menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="mdbook-sidebar-toggle" class="icon-button" for="mdbook-sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="mdbook-sidebar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg></span>
                        </label>
                        <button id="mdbook-theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="mdbook-theme-list">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M371.3 367.1c27.3-3.9 51.9-19.4 67.2-42.9L600.2 74.1c12.6-19.5 9.4-45.3-7.6-61.2S549.7-4.4 531.1 9.6L294.4 187.2c-24 18-38.2 46.1-38.4 76.1L371.3 367.1zm-19.6 25.4l-116-104.4C175.9 290.3 128 339.6 128 400c0 3.9 .2 7.8 .6 11.6c1.8 17.5-10.2 36.4-27.8 36.4H96c-17.7 0-32 14.3-32 32s14.3 32 32 32H240c61.9 0 112-50.1 112-112c0-2.5-.1-5-.2-7.5z"/></svg></span>
                        </button>
                        <ul id="mdbook-theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="mdbook-theme-ayu">Ayu</button></li>
                        </ul>
                        <button id="mdbook-search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="mdbook-searchbar">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M416 208c0 45.9-14.9 88.3-40 122.7L502.6 457.4c12.5 12.5 12.5 32.8 0 45.3s-32.8 12.5-45.3 0L330.7 376c-34.4 25.2-76.8 40-122.7 40C93.1 416 0 322.9 0 208S93.1 0 208 0S416 93.1 416 208zM208 352c79.5 0 144-64.5 144-144s-64.5-144-144-144S64 128.5 64 208s64.5 144 144 144z"/></svg></span>
                        </button>
                    </div>

                    <h1 class="menu-title">Nethercore ZX API Reference</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <span class=fa-svg id="print-button"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M128 0C92.7 0 64 28.7 64 64v96h64V64H354.7L384 93.3V160h64V93.3c0-17-6.7-33.3-18.7-45.3L400 18.7C388 6.7 371.7 0 354.7 0H128zM384 352v32 64H128V384 368 352H384zm64 32h32c17.7 0 32-14.3 32-32V256c0-35.3-28.7-64-64-64H64c-35.3 0-64 28.7-64 64v96c0 17.7 14.3 32 32 32H64v64c0 35.3 28.7 64 64 64H384c35.3 0 64-28.7 64-64V384zm-16-88c-13.3 0-24-10.7-24-24s10.7-24 24-24s24 10.7 24 24s-10.7 24-24 24z"/></svg></span>
                        </a>
                        <a href="https://github.com/nethercore/nethercore" title="Git repository" aria-label="Git repository">
                            <span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 496 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M165.9 397.4c0 2-2.3 3.6-5.2 3.6-3.3.3-5.6-1.3-5.6-3.6 0-2 2.3-3.6 5.2-3.6 3-.3 5.6 1.3 5.6 3.6zm-31.1-4.5c-.7 2 1.3 4.3 4.3 4.9 2.6 1 5.6 0 6.2-2s-1.3-4.3-4.3-5.2c-2.6-.7-5.5.3-6.2 2.3zm44.2-1.7c-2.9.7-4.9 2.6-4.6 4.9.3 2 2.9 3.3 5.9 2.6 2.9-.7 4.9-2.6 4.6-4.6-.3-1.9-3-3.2-5.9-2.9zM244.8 8C106.1 8 0 113.3 0 252c0 110.9 69.8 205.8 169.5 239.2 12.8 2.3 17.3-5.6 17.3-12.1 0-6.2-.3-40.4-.3-61.4 0 0-70 15-84.7-29.8 0 0-11.4-29.1-27.8-36.6 0 0-22.9-15.7 1.6-15.4 0 0 24.9 2 38.6 25.8 21.9 38.6 58.6 27.5 72.9 20.9 2.3-16 8.8-27.1 16-33.7-55.9-6.2-112.3-14.3-112.3-110.5 0-27.5 7.6-41.3 23.6-58.9-2.6-6.5-11.1-33.3 2.6-67.9 20.9-6.5 69 27 69 27 20-5.6 41.5-8.5 62.8-8.5s42.8 2.9 62.8 8.5c0 0 48.1-33.6 69-27 13.7 34.7 5.2 61.4 2.6 67.9 16 17.7 25.8 31.5 25.8 58.9 0 96.5-58.9 104.2-114.8 110.5 9.2 7.9 17 22.9 17 46.4 0 33.7-.3 75.4-.3 83.6 0 6.5 4.6 14.4 17.3 12.1C428.2 457.8 496 362.9 496 252 496 113.3 383.5 8 244.8 8zM97.2 352.9c-1.3 1-1 3.3.7 5.2 1.6 1.6 3.9 2.3 5.2 1 1.3-1 1-3.3-.7-5.2-1.6-1.6-3.9-2.3-5.2-1zm-10.8-8.1c-.7 1.3.3 2.9 2.3 3.9 1.6 1 3.6.7 4.3-.7.7-1.3-.3-2.9-2.3-3.9-2-.6-3.6-.3-4.3.7zm32.4 35.6c-1.6 1.3-1 4.3 1.3 6.2 2.3 2.3 5.2 2.6 6.5 1 1.3-1.3.7-4.3-1.3-6.2-2.2-2.3-5.2-2.6-6.5-1zm-11.4-14.7c-1.6 1-1.6 3.6 0 5.9 1.6 2.3 4.3 3.3 5.6 2.3 1.6-1.3 1.6-3.9 0-6.2-1.4-2.3-4-3.3-5.6-2z"/></svg></span>
                        </a>

                    </div>
                </div>

                <div id="mdbook-search-wrapper" class="hidden">
                    <form id="mdbook-searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="mdbook-searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="mdbook-searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <span class=fa-svg id="fa-spin"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M304 48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zm0 416c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM48 304c26.5 0 48-21.5 48-48s-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48zm464-48c0-26.5-21.5-48-48-48s-48 21.5-48 48s21.5 48 48 48s48-21.5 48-48zM142.9 437c18.7-18.7 18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zm0-294.2c18.7-18.7 18.7-49.1 0-67.9S93.7 56.2 75 75s-18.7 49.1 0 67.9s49.1 18.7 67.9 0zM369.1 437c18.7 18.7 49.1 18.7 67.9 0s18.7-49.1 0-67.9s-49.1-18.7-67.9 0s-18.7 49.1 0 67.9z"/></svg></span>
                            </div>
                        </div>
                    </form>
                    <div id="mdbook-searchresults-outer" class="searchresults-outer hidden">
                        <div id="mdbook-searchresults-header" class="searchresults-header"></div>
                        <ul id="mdbook-searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('mdbook-sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('mdbook-sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#mdbook-sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="mdbook-content" class="content">
                    <main>
                        <h1 id="nethercore-zx-api-reference"><a class="header" href="#nethercore-zx-api-reference">Nethercore ZX API Reference</a></h1>
<p>Nethercore ZX is a 5th-generation fantasy console targeting PS1/N64/Saturn aesthetics with modern conveniences like deterministic rollback netcode.</p>
<h2 id="console-specs"><a class="header" href="#console-specs">Console Specs</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Spec</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td><strong>Aesthetic</strong></td><td>PS1/N64/Saturn (5th gen)</td></tr>
<tr><td><strong>Resolution</strong></td><td>960×540 (fixed, upscaled to display)</td></tr>
<tr><td><strong>Color depth</strong></td><td>RGBA8</td></tr>
<tr><td><strong>Tick rate</strong></td><td>24, 30, 60 (default), 120 fps</td></tr>
<tr><td><strong>ROM (Cartridge)</strong></td><td>16MB (WASM code + data pack assets)</td></tr>
<tr><td><strong>RAM</strong></td><td>4MB (WASM linear memory for game state)</td></tr>
<tr><td><strong>VRAM</strong></td><td>4MB (GPU textures and mesh buffers)</td></tr>
<tr><td><strong>Compute budget</strong></td><td>WASM GAS metering</td></tr>
<tr><td><strong>Netcode</strong></td><td>Deterministic rollback via GGRS</td></tr>
<tr><td><strong>Max players</strong></td><td>4 (any mix of local + remote)</td></tr>
</tbody>
</table>
</div>
<h2 id="game-lifecycle"><a class="header" href="#game-lifecycle">Game Lifecycle</a></h2>
<p>Games export three functions:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    // Called once at startup
    // Load resources, configure console settings
}

#[no_mangle]
pub extern "C" fn update() {
    // Called every tick (deterministic for rollback)
    // Update game state, handle input
}

#[no_mangle]
pub extern "C" fn render() {
    // Called every frame (skipped during rollback replay)
    // Draw to screen
}
<span class="boring">}</span></code></pre>
<h2 id="memory-model"><a class="header" href="#memory-model">Memory Model</a></h2>
<p>Nethercore ZX uses a <strong>16MB ROM + 4MB RAM</strong> memory model:</p>
<ul>
<li><strong>ROM (16MB)</strong>: WASM bytecode + data pack (textures, meshes, sounds)</li>
<li><strong>RAM (4MB)</strong>: WASM linear memory for game state</li>
<li><strong>VRAM (4MB)</strong>: GPU textures and mesh buffers</li>
</ul>
<p>Assets loaded via <code>rom_*</code> functions go directly to VRAM/audio memory, keeping RAM free for game state.</p>
<h2 id="api-categories"><a class="header" href="#api-categories">API Categories</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Category</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><a href="#system-functions">System</a></td><td>Time, logging, random, session info</td></tr>
<tr><td><a href="#input-functions">Input</a></td><td>Buttons, sticks, triggers</td></tr>
<tr><td><a href="#graphics-configuration">Graphics</a></td><td>Resolution, render mode, state</td></tr>
<tr><td><a href="#camera-functions">Camera</a></td><td>View and projection</td></tr>
<tr><td><a href="#transform-functions">Transforms</a></td><td>Matrix stack operations</td></tr>
<tr><td><a href="#texture-functions">Textures</a></td><td>Loading and binding textures</td></tr>
<tr><td><a href="#mesh-functions">Meshes</a></td><td>Loading and drawing meshes</td></tr>
<tr><td><a href="#material-functions">Materials</a></td><td>PBR and Blinn-Phong properties</td></tr>
<tr><td><a href="#lighting-functions">Lighting</a></td><td>Directional and point lights</td></tr>
<tr><td><a href="#skeletal-animation-functions">Skinning</a></td><td>Skeletal animation</td></tr>
<tr><td><a href="#keyframe-animation-functions">Animation</a></td><td>Keyframe playback</td></tr>
<tr><td><a href="#procedural-mesh-functions">Procedural</a></td><td>Generated primitives</td></tr>
<tr><td><a href="#2d-drawing-functions">2D Drawing</a></td><td>Sprites, text, rectangles</td></tr>
<tr><td><a href="#billboard-functions">Billboards</a></td><td>Camera-facing quads</td></tr>
<tr><td><a href="#sky-functions">Sky</a></td><td>Procedural sky rendering</td></tr>
<tr><td><a href="#audio-functions">Audio</a></td><td>Sound effects and music</td></tr>
<tr><td><a href="#save-data-functions">Save Data</a></td><td>Persistent storage</td></tr>
<tr><td><a href="#rom-data-pack-functions">ROM Loading</a></td><td>Data pack access</td></tr>
<tr><td><a href="#debug-functions">Debug</a></td><td>Runtime value inspection</td></tr>
</tbody>
</table>
</div>
<h2 id="screen-capture"><a class="header" href="#screen-capture">Screen Capture</a></h2>
<p>The host application includes screenshot and GIF recording capabilities:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Default</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>Screenshot</td><td><strong>F9</strong></td><td>Save PNG to screenshots folder</td></tr>
<tr><td>GIF Toggle</td><td><strong>F10</strong></td><td>Start/stop GIF recording</td></tr>
</tbody>
</table>
</div>
<p>Files are saved to:</p>
<ul>
<li>Screenshots: <code>~/.nethercore/Nethercore/screenshots/</code></li>
<li>GIFs: <code>~/.nethercore/Nethercore/gifs/</code></li>
</ul>
<p>Filenames include game name and timestamp (e.g., <code>platformer_screenshot_2025-01-15_14-30-45.png</code>).</p>
<p><strong>Configuration</strong> (<code>~/.nethercore/config.toml</code>):</p>
<pre><code class="language-toml">[capture]
screenshot = "F9"
gif_toggle = "F10"
gif_fps = 30          # GIF framerate
gif_max_seconds = 60  # Max duration
</code></pre>
<h2 id="quick-links"><a class="header" href="#quick-links">Quick Links</a></h2>
<ul>
<li><a href="#cheat-sheet">Cheat Sheet</a> - All functions on one page</li>
<li><a href="getting-started.html">Getting Started</a> - Your first game</li>
<li><a href="#render-modes-guide">Render Modes</a> - Mode 0-3 explained</li>
<li><a href="#rollback-safety-guide">Rollback Safety</a> - Writing deterministic code</li>
</ul>
<hr>
<h2 id="building-these-docs"><a class="header" href="#building-these-docs">Building These Docs</a></h2>
<p>These docs are built with <a href="https://rust-lang.github.io/mdBook/">mdBook</a>.</p>
<pre><code class="language-bash"># Install mdBook
cargo install mdbook

# Build static HTML (outputs to docs/book/book/)
cd docs/book
mdbook build

# Or serve locally with live reload
mdbook serve
</code></pre>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h1>
<p>Before you start building games for Nethercore ZX, you’ll need to set up your development environment.</p>
<h2 id="choose-your-language"><a class="header" href="#choose-your-language">Choose Your Language</a></h2>
<p>Nethercore ZX games are compiled to WebAssembly. You can write games in several languages:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Language</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td><strong>Rust</strong></td><td>Full ecosystem support, best tooling</td></tr>
<tr><td><strong>C/C++</strong></td><td>Existing codebases, familiar to game devs</td></tr>
<tr><td><strong>Zig</strong></td><td>Modern systems programming, C interop</td></tr>
</tbody>
</table>
</div>
<p>This guide shows setup for each language. Pick one and follow its setup instructions.</p>
<h2 id="language-setup"><a class="header" href="#language-setup">Language Setup</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<h3 id="install-rust"><a class="header" href="#install-rust">Install Rust</a></h3>
<p>Install Rust using rustup:</p>
<p><strong>Windows/macOS/Linux:</strong></p>
<pre><code class="language-bash">curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
</code></pre>
<p>Or visit <a href="https://rustup.rs/">rustup.rs</a> for platform-specific installers.</p>
<h3 id="add-webassembly-target"><a class="header" href="#add-webassembly-target">Add WebAssembly Target</a></h3>
<p>After installing Rust, add the WASM compilation target:</p>
<pre><code class="language-bash">rustup target add wasm32-unknown-unknown
</code></pre>
<h3 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h3>
<pre><code class="language-bash"># Check Rust version
rustc --version

# Check WASM target is installed
rustup target list --installed | grep wasm32
</code></pre>
<p>You should see:</p>
<pre><code>rustc 1.75.0 (82e1608df 2023-12-21)
wasm32-unknown-unknown
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<h3 id="install-wasi-sdk"><a class="header" href="#install-wasi-sdk">Install wasi-sdk</a></h3>
<p>wasi-sdk provides a clang toolchain configured for WebAssembly:</p>
<p><strong>macOS (Homebrew):</strong></p>
<pre><code class="language-bash">brew install wasi-sdk
</code></pre>
<p><strong>Linux/Windows:</strong></p>
<p>Download from <a href="https://github.com/WebAssembly/wasi-sdk/releases">wasi-sdk releases</a>:</p>
<pre><code class="language-bash"># Linux example (adjust version as needed)
wget https://github.com/WebAssembly/wasi-sdk/releases/download/wasi-sdk-24/wasi-sdk-24.0-x86_64-linux.tar.gz
tar xzf wasi-sdk-24.0-x86_64-linux.tar.gz
sudo mv wasi-sdk-24.0 /opt/wasi-sdk
</code></pre>
<p><strong>Windows (manual):</strong></p>
<ol>
<li>Download the Windows release from GitHub</li>
<li>Extract to <code>C:\wasi-sdk</code></li>
<li>Add to PATH or set <code>WASI_SDK_PATH</code> environment variable</li>
</ol>
<h3 id="get-the-nethercore-header"><a class="header" href="#get-the-nethercore-header">Get the Nethercore Header</a></h3>
<p>Download <code>nethercore_zx.h</code> from the Nethercore repository:</p>
<pre><code class="language-bash"># From the nethercore repo
cp include/nethercore_zx.h your-game/
</code></pre>
<p>Or add the include path to your build.</p>
<h3 id="verify-installation-1"><a class="header" href="#verify-installation-1">Verify Installation</a></h3>
<pre><code class="language-bash"># Check clang version
/opt/wasi-sdk/bin/clang --version
</code></pre>
<p>You should see:</p>
<pre><code>clang version 18.1.2 (https://github.com/aspect-build/llvm-project ...)
Target: wasm32-unknown-wasi
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<h3 id="install-zig"><a class="header" href="#install-zig">Install Zig</a></h3>
<p><strong>macOS (Homebrew):</strong></p>
<pre><code class="language-bash">brew install zig
</code></pre>
<p><strong>Linux/Windows:</strong></p>
<p>Download from <a href="https://ziglang.org/download/">ziglang.org/download</a>:</p>
<pre><code class="language-bash"># Extract and add to PATH
wget https://ziglang.org/download/0.13.0/zig-linux-x86_64-0.13.0.tar.xz
tar xf zig-linux-x86_64-0.13.0.tar.xz
export PATH=$PATH:$(pwd)/zig-linux-x86_64-0.13.0
</code></pre>
<h3 id="get-the-nethercore-bindings"><a class="header" href="#get-the-nethercore-bindings">Get the Nethercore Bindings</a></h3>
<p>Copy the native Zig bindings from the Nethercore repository:</p>
<pre><code class="language-bash">cp include/nethercore_zx.zig your-game/
</code></pre>
<p>Or declare the FFI imports directly in your code (see examples).</p>
<h3 id="verify-installation-2"><a class="header" href="#verify-installation-2">Verify Installation</a></h3>
<pre><code class="language-bash">zig version
</code></pre>
<p>You should see:</p>
<pre><code>0.13.0
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="code-editor-optional-but-recommended"><a class="header" href="#code-editor-optional-but-recommended">Code Editor (Optional but Recommended)</a></h2>
<p>Any text editor works, but we recommend one with language support:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<ul>
<li><strong>VS Code</strong> with rust-analyzer extension</li>
<li><strong>RustRover</strong> (JetBrains IDE for Rust)</li>
<li><strong>Neovim</strong> with rust-analyzer LSP
{{#endtab}}</li>
</ul>
<p>{{#tab name=“C/C++”}}</p>
<ul>
<li><strong>VS Code</strong> with C/C++ extension (clangd)</li>
<li><strong>CLion</strong> (JetBrains IDE)</li>
<li><strong>Neovim</strong> with clangd LSP
{{#endtab}}</li>
</ul>
<p>{{#tab name=“Zig”}}</p>
<ul>
<li><strong>VS Code</strong> with Zig Language extension</li>
<li><strong>Neovim</strong> with zls (Zig Language Server)
{{#endtab}}</li>
</ul>
<p>{{#endtabs}}</p>
<h2 id="optional-nethercore-cli"><a class="header" href="#optional-nethercore-cli">Optional: Nethercore CLI</a></h2>
<p>The <code>nether</code> CLI tool provides convenient commands for building and running games:</p>
<pre><code class="language-bash">cargo install --path tools/nether-cli
</code></pre>
<p>This gives you commands like:</p>
<ul>
<li><code>nether build</code> - Compile your game</li>
<li><code>nether run</code> - Run your game in the player</li>
<li><code>nether pack</code> - Package your game into a ROM file</li>
</ul>
<hr>
<p><strong>Next:</strong> <a href="#your-first-game">Your First Game</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="your-first-game"><a class="header" href="#your-first-game">Your First Game</a></h1>
<p>Let’s create a simple game that draws a colored square and responds to input. This will introduce you to the core concepts of Nethercore game development.</p>
<h2 id="create-the-project"><a class="header" href="#create-the-project">Create the Project</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre><code class="language-bash">cargo new --lib my-first-game
cd my-first-game
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-bash">mkdir my-first-game
cd my-first-game
</code></pre>
<p>Copy <code>nethercore_zx.h</code> from the Nethercore repository to your project folder.
{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-bash">mkdir my-first-game
cd my-first-game
</code></pre>
<p>Copy <code>nethercore_zx.h</code> from the Nethercore repository to your project folder.
{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="configure-your-build"><a class="header" href="#configure-your-build">Configure Your Build</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}
Replace the contents of <code>Cargo.toml</code> with:</p>
<pre><code class="language-toml">[package]
name = "my-first-game"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[profile.release]
opt-level = "s"
lto = true
</code></pre>
<p>Key settings:</p>
<ul>
<li><code>crate-type = ["cdylib"]</code> - Builds a C-compatible dynamic library (required for WASM)</li>
<li><code>opt-level = "s"</code> - Optimize for small binary size</li>
<li><code>lto = true</code> - Link-time optimization for even smaller binaries
{{#endtab}}</li>
</ul>
<p>{{#tab name=“C/C++”}}
Create a <code>Makefile</code>:</p>
<pre><code class="language-makefile"># Path to wasi-sdk (adjust for your system)
WASI_SDK_PATH ?= /opt/wasi-sdk

CC = $(WASI_SDK_PATH)/bin/clang
CFLAGS = -O2 -Wall -Wextra

# Export the three required functions
LDFLAGS = -Wl,--no-entry \
          -Wl,--export=init \
          -Wl,--export=update \
          -Wl,--export=render \
          -Wl,--allow-undefined

all: game.wasm

game.wasm: game.c
	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^

clean:
	rm -f game.wasm
</code></pre>
<p>Key settings:</p>
<ul>
<li><code>--no-entry</code> - No main() function, we use init/update/render</li>
<li><code>--export=...</code> - Make our functions visible to the runtime</li>
<li><code>--allow-undefined</code> - FFI functions are provided by the runtime
{{#endtab}}</li>
</ul>
<p>{{#tab name=“Zig”}}
Create a <code>build.zig</code>:</p>
<pre><code class="language-zig">const std = @import("std");

pub fn build(b: *std.Build) void {
    const target = b.resolveTargetQuery(.{
        .cpu_arch = .wasm32,
        .os_tag = .freestanding,
    });

    const exe = b.addExecutable(.{
        .name = "game",
        .root_source_file = b.path("src/main.zig"),
        .target = target,
        .optimize = .ReleaseSmall,
    });

    // Export the required functions
    exe.entry = .disabled;
    exe.rdynamic = true;

    b.installArtifact(exe);
}
</code></pre>
<p>Key settings:</p>
<ul>
<li><code>.wasm32</code> + <code>.freestanding</code> - Compile to bare WASM</li>
<li><code>.ReleaseSmall</code> - Optimize for size</li>
<li><code>.rdynamic = true</code> - Export public functions
{{#endtab}}</li>
</ul>
<p>{{#endtabs}}</p>
<h2 id="write-your-game"><a class="header" href="#write-your-game">Write Your Game</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}
Replace <code>src/lib.rs</code> with:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

// Panic handler required for no_std
#[panic_handler]
fn panic(_: &amp;PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}

// FFI imports from the Nethercore runtime
#[link(wasm_import_module = "env")]
extern "C" {
    fn set_clear_color(color: u32);
    fn button_pressed(player: u32, button: u32) -&gt; u32;
    fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32);
    fn draw_text(ptr: *const u8, len: u32, x: f32, y: f32, size: f32, color: u32);
}

// Game state - stored in static variables for rollback safety
static mut SQUARE_Y: f32 = 200.0;

// Button constants
const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_A: u32 = 4;

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        // Set the background color (dark blue)
        set_clear_color(0x1a1a2eFF);
    }
}

#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        // Move square with D-pad
        if button_pressed(0, BUTTON_UP) != 0 {
            SQUARE_Y -= 10.0;
        }
        if button_pressed(0, BUTTON_DOWN) != 0 {
            SQUARE_Y += 10.0;
        }

        // Reset position with A button
        if button_pressed(0, BUTTON_A) != 0 {
            SQUARE_Y = 200.0;
        }

        // Keep square on screen
        SQUARE_Y = SQUARE_Y.clamp(20.0, 450.0);
    }
}

#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Draw title text
        let title = b"Hello Nethercore!";
        draw_text(
            title.as_ptr(),
            title.len() as u32,
            80.0, 50.0, 32.0,
            0xFFFFFFFF,
        );

        // Draw the moving square
        draw_rect(200.0, SQUARE_Y, 80.0, 80.0, 0xFF6B6BFF);

        // Draw instructions
        let hint = b"D-pad: Move   A: Reset";
        draw_text(
            hint.as_ptr(),
            hint.len() as u32,
            60.0, 500.0, 18.0,
            0x888888FF,
        );
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}
Create <code>game.c</code>:</p>
<pre><code class="language-c">#include "nethercore_zx.h"

/* Game state - stored in static variables for rollback safety */
static float square_y = 200.0f;

EWZX_EXPORT void init(void) {
    /* Set the background color (dark blue) */
    set_clear_color(0x1a1a2eFF);
}

EWZX_EXPORT void update(void) {
    /* Move square with D-pad */
    if (button_pressed(0, EWZX_BUTTON_UP)) {
        square_y -= 10.0f;
    }
    if (button_pressed(0, EWZX_BUTTON_DOWN)) {
        square_y += 10.0f;
    }

    /* Reset position with A button */
    if (button_pressed(0, EWZX_BUTTON_A)) {
        square_y = 200.0f;
    }

    /* Keep square on screen */
    square_y = nczx_clampf(square_y, 20.0f, 450.0f);
}

EWZX_EXPORT void render(void) {
    /* Draw title text */
    EWZX_DRAW_TEXT("Hello Nethercore!", 80.0f, 50.0f, 32.0f, EWZX_WHITE);

    /* Draw the moving square */
    draw_rect(200.0f, square_y, 80.0f, 80.0f, 0xFF6B6BFF);

    /* Draw instructions */
    EWZX_DRAW_TEXT("D-pad: Move   A: Reset", 60.0f, 500.0f, 18.0f, 0x888888FF);
}
</code></pre>
<p>The header provides:</p>
<ul>
<li><code>EWZX_EXPORT</code> - Marks functions for WASM export</li>
<li><code>EWZX_BUTTON_*</code> - Button constants</li>
<li><code>EWZX_DRAW_TEXT()</code> - Helper macro for string literals</li>
<li><code>nczx_clampf()</code> - Clamp float between min and max
{{#endtab}}</li>
</ul>
<p>{{#tab name=“Zig”}}
Create <code>src/main.zig</code>:</p>
<pre><code class="language-zig">// FFI imports from the Nethercore runtime
extern fn set_clear_color(color: u32) void;
extern fn button_pressed(player: u32, button: u32) u32;
extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;
extern fn draw_text(ptr: [*]const u8, len: u32, x: f32, y: f32, size: f32, color: u32) void;

// Button constants
const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_A: u32 = 4;

// Game state - stored in static variables for rollback safety
var square_y: f32 = 200.0;

export fn init() void {
    // Set the background color (dark blue)
    set_clear_color(0x1a1a2eFF);
}

export fn update() void {
    // Move square with D-pad
    if (button_pressed(0, BUTTON_UP) != 0) {
        square_y -= 10.0;
    }
    if (button_pressed(0, BUTTON_DOWN) != 0) {
        square_y += 10.0;
    }

    // Reset position with A button
    if (button_pressed(0, BUTTON_A) != 0) {
        square_y = 200.0;
    }

    // Keep square on screen
    square_y = @max(20.0, @min(square_y, 450.0));
}

export fn render() void {
    // Draw title text
    const title = "Hello Nethercore!";
    draw_text(title.ptr, title.len, 80.0, 50.0, 32.0, 0xFFFFFFFF);

    // Draw the moving square
    draw_rect(200.0, square_y, 80.0, 80.0, 0xFF6B6BFF);

    // Draw instructions
    const hint = "D-pad: Move   A: Reset";
    draw_text(hint.ptr, hint.len, 60.0, 500.0, 18.0, 0x888888FF);
}
</code></pre>
<p>Zig’s <code>export fn</code> automatically exports functions from the WASM module.
{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="understanding-the-code"><a class="header" href="#understanding-the-code">Understanding the Code</a></h2>
<h3 id="no-standard-library"><a class="header" href="#no-standard-library">No Standard Library</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre>
<p>Nethercore games run in a minimal WebAssembly environment without the Rust standard library. This keeps binaries small and avoids OS dependencies.
{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}
We compile with <code>--no-entry</code> and don’t link libc. The header provides everything you need. For advanced use cases, you can optionally link wasi-libc.
{{#endtab}}</p>
<p>{{#tab name=“Zig”}}
Zig compiles to freestanding WASM by default with <code>.os_tag = .freestanding</code>. The standard library’s OS-specific parts are unavailable, but math and memory functions work.
{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="ffi-imports"><a class="header" href="#ffi-imports">FFI Imports</a></h3>
<p>Functions are imported from the Nethercore runtime. See the <a href="#cheat-sheet">Cheat Sheet</a> for all available functions.</p>
<h3 id="static-game-state"><a class="header" href="#static-game-state">Static Game State</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SQUARE_Y: f32 = 200.0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float square_y = 200.0f;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var square_y: f32 = 200.0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>All game state lives in static/global variables. This is intentional - the Nethercore runtime automatically snapshots all WASM memory for rollback netcode. No manual state serialization needed!</p>
<h3 id="colors"><a class="header" href="#colors">Colors</a></h3>
<p>Colors are 32-bit RGBA values in hexadecimal:</p>
<ul>
<li><code>0xFFFFFFFF</code> = White (R=255, G=255, B=255, A=255)</li>
<li><code>0xFF6B6BFF</code> = Salmon red (R=255, G=107, B=107, A=255)</li>
<li><code>0x1a1a2eFF</code> = Dark blue (R=26, G=26, B=46, A=255)</li>
</ul>
<h2 id="build-and-run"><a class="header" href="#build-and-run">Build and Run</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<h3 id="build-the-wasm-file"><a class="header" href="#build-the-wasm-file">Build the WASM file:</a></h3>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
</code></pre>
<p>Output: <code>target/wasm32-unknown-unknown/release/my_first_game.wasm</code></p>
<h3 id="run-in-the-nethercore-player"><a class="header" href="#run-in-the-nethercore-player">Run in the Nethercore player:</a></h3>
<pre><code class="language-bash">nether run target/wasm32-unknown-unknown/release/my_first_game.wasm
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<h3 id="build-the-wasm-file-1"><a class="header" href="#build-the-wasm-file-1">Build the WASM file:</a></h3>
<pre><code class="language-bash">make
</code></pre>
<p>Output: <code>game.wasm</code></p>
<h3 id="run-in-the-nethercore-player-1"><a class="header" href="#run-in-the-nethercore-player-1">Run in the Nethercore player:</a></h3>
<pre><code class="language-bash">nether run game.wasm
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<h3 id="build-the-wasm-file-2"><a class="header" href="#build-the-wasm-file-2">Build the WASM file:</a></h3>
<pre><code class="language-bash">zig build
</code></pre>
<p>Output: <code>zig-out/bin/game.wasm</code></p>
<h3 id="run-in-the-nethercore-player-2"><a class="header" href="#run-in-the-nethercore-player-2">Run in the Nethercore player:</a></h3>
<pre><code class="language-bash">nether run zig-out/bin/game.wasm
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Or load the <code>.wasm</code> file directly in the Nethercore Library application.</p>
<h2 id="what-youve-learned"><a class="header" href="#what-youve-learned">What You’ve Learned</a></h2>
<ul>
<li>Setting up a project for WASM compilation</li>
<li>The minimal/freestanding environment</li>
<li>Importing FFI functions from the runtime</li>
<li>The three lifecycle functions: <code>init()</code>, <code>update()</code>, <code>render()</code></li>
<li>Drawing 2D graphics with <code>draw_rect()</code> and <code>draw_text()</code></li>
<li>Handling input with <code>button_pressed()</code></li>
<li>Using static variables for game state</li>
</ul>
<hr>
<p><strong>Next:</strong> <a href="#understanding-the-game-loop">Understanding the Game Loop</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="understanding-the-game-loop"><a class="header" href="#understanding-the-game-loop">Understanding the Game Loop</a></h1>
<p>Every Nethercore game implements three core functions that the runtime calls at specific times. Understanding this lifecycle is key to building robust, multiplayer-ready games.</p>
<h2 id="the-three-functions"><a class="header" href="#the-three-functions">The Three Functions</a></h2>
<h3 id="init---called-once-at-startup"><a class="header" href="#init---called-once-at-startup"><code>init()</code> - Called Once at Startup</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    // Load resources
    // Configure graphics settings
    // Initialize game state
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    /* Load resources */
    /* Configure graphics settings */
    /* Initialize game state */
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    // Load resources
    // Configure graphics settings
    // Initialize game state
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Purpose:</strong> Set up your game. This runs once when the game starts.</p>
<p><strong>Common uses:</strong></p>
<ul>
<li>Set resolution and tick rate</li>
<li>Configure render mode</li>
<li>Load textures from ROM or create procedural ones</li>
<li>Initialize game state to starting values</li>
<li>Set clear color</li>
</ul>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_resolution(1);        // 540p
        set_tick_rate(2);         // 60 FPS
        set_clear_color(0x000000FF);
        render_mode(2);           // PBR lighting

        // Load a texture
        PLAYER_TEXTURE = load_texture(8, 8, PIXELS.as_ptr());
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t player_texture = 0;

EWZX_EXPORT void init(void) {
    set_resolution(1);        /* 540p */
    set_tick_rate(2);         /* 60 FPS */
    set_clear_color(0x000000FF);
    render_mode(EWZX_RENDER_PBR);

    /* Load a texture */
    player_texture = load_texture(8, 8, pixels);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var player_texture: u32 = 0;

export fn init() void {
    set_resolution(1);        // 540p
    set_tick_rate(2);         // 60 FPS
    set_clear_color(0x000000FF);
    render_mode(2);           // PBR lighting

    // Load a texture
    player_texture = load_texture(8, 8, &amp;pixels);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="update---called-every-tick"><a class="header" href="#update---called-every-tick"><code>update()</code> - Called Every Tick</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    // Read input
    // Update game logic
    // Handle physics
    // Check collisions
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Read input */
    /* Update game logic */
    /* Handle physics */
    /* Check collisions */
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Read input
    // Update game logic
    // Handle physics
    // Check collisions
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Purpose:</strong> Update your game state. This runs at a fixed rate (default 60 times per second).</p>
<p><strong>Critical for multiplayer:</strong> The <code>update()</code> function must be <strong>deterministic</strong>. Given the same inputs, it must produce exactly the same results every time. This is how rollback netcode works.</p>
<p><strong>Rules for deterministic code:</strong></p>
<ul>
<li>Use <code>random()</code> (or <code>random_u32()</code> in C) for randomness (seeded by the runtime)</li>
<li>Don’t use system time or external state</li>
<li>All game logic goes here, not in <code>render()</code></li>
</ul>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        let dt = delta_time();

        // Read input
        let move_x = left_stick_x(0);
        let jump = button_pressed(0, BUTTON_A) != 0;

        // Update physics
        PLAYER_VY -= GRAVITY;
        PLAYER_X += move_x * SPEED * dt;
        PLAYER_Y += PLAYER_VY * dt;

        // Handle jump
        if jump &amp;&amp; ON_GROUND {
            PLAYER_VY = JUMP_FORCE;
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float dt = delta_time();

    /* Read input */
    float move_x = left_stick_x(0);
    int jump = button_pressed(0, EWZX_BUTTON_A) != 0;

    /* Update physics */
    player_vy -= GRAVITY;
    player_x += move_x * SPEED * dt;
    player_y += player_vy * dt;

    /* Handle jump */
    if (jump &amp;&amp; on_ground) {
        player_vy = JUMP_FORCE;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const dt = delta_time();

    // Read input
    const move_x = left_stick_x(0);
    const jump = button_pressed(0, BUTTON_A) != 0;

    // Update physics
    player_vy -= GRAVITY;
    player_x += move_x * SPEED * dt;
    player_y += player_vy * dt;

    // Handle jump
    if (jump and on_ground) {
        player_vy = JUMP_FORCE;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="render---called-every-frame"><a class="header" href="#render---called-every-frame"><code>render()</code> - Called Every Frame</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    // Set up camera
    // Draw game objects
    // Draw UI
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Set up camera */
    /* Draw game objects */
    /* Draw UI */
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Set up camera
    // Draw game objects
    // Draw UI
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Purpose:</strong> Draw your game. This runs every frame (may be more often than <code>update()</code> for smooth visuals).</p>
<p><strong>Important:</strong></p>
<ul>
<li>This function is <strong>skipped during rollback</strong></li>
<li>Don’t modify game state here</li>
<li>Use state from <code>update()</code> to determine what to draw</li>
</ul>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Set camera
        camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

        // Draw player
        push_identity();
        push_translate(PLAYER_X, PLAYER_Y, 0.0);
        texture_bind(PLAYER_TEXTURE);
        draw_mesh(PLAYER_MESH);

        // Draw UI
        let score = b"Score: ";
        draw_text(score.as_ptr(), score.len() as u32, 10.0, 10.0, 20.0, 0xFFFFFFFF);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Set camera */
    camera_set(0.0f, 5.0f, 10.0f, 0.0f, 0.0f, 0.0f);

    /* Draw player */
    push_identity();
    push_translate(player_x, player_y, 0.0f);
    texture_bind(player_texture);
    draw_mesh(player_mesh);

    /* Draw UI */
    EWZX_DRAW_TEXT("Score: ", 10.0f, 10.0f, 20.0f, EWZX_WHITE);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Set camera
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // Draw player
    push_identity();
    push_translate(player_x, player_y, 0.0);
    texture_bind(player_texture);
    draw_mesh(player_mesh);

    // Draw UI
    const score = "Score: ";
    draw_text(score.ptr, score.len, 10.0, 10.0, 20.0, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="tick-rate-vs-frame-rate"><a class="header" href="#tick-rate-vs-frame-rate">Tick Rate vs Frame Rate</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Concept</th><th>Default</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td><strong>Tick Rate</strong></td><td>60 Hz</td><td>How often <code>update()</code> runs. Fixed for determinism.</td></tr>
<tr><td><strong>Frame Rate</strong></td><td>Variable</td><td>How often <code>render()</code> runs. Matches display refresh.</td></tr>
</tbody>
</table>
</div>
<p>You can change the tick rate in <code>init()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_tick_rate(0);  // 24 ticks per second (cinematic)
set_tick_rate(1);  // 30 ticks per second
set_tick_rate(2);  // 60 ticks per second (default)
set_tick_rate(3);  // 120 ticks per second (fighting games)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">set_tick_rate(EWZX_TICK_RATE_24);   /* 24 ticks per second (cinematic) */
set_tick_rate(EWZX_TICK_RATE_30);   /* 30 ticks per second */
set_tick_rate(EWZX_TICK_RATE_60);   /* 60 ticks per second (default) */
set_tick_rate(EWZX_TICK_RATE_120);  /* 120 ticks per second (fighting games) */
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">set_tick_rate(0);  // 24 ticks per second (cinematic)
set_tick_rate(1);  // 30 ticks per second
set_tick_rate(2);  // 60 ticks per second (default)
set_tick_rate(3);  // 120 ticks per second (fighting games)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="the-rollback-system"><a class="header" href="#the-rollback-system">The Rollback System</a></h2>
<p>Nethercore’s killer feature is automatic rollback netcode. Here’s how it works:</p>
<ol>
<li><strong>Snapshot:</strong> The runtime snapshots all WASM memory after each <code>update()</code></li>
<li><strong>Predict:</strong> When waiting for remote player input, the game predicts and continues</li>
<li><strong>Rollback:</strong> When real input arrives, the game rolls back and replays</li>
<li><strong>Skip render:</strong> During rollback replay, <code>render()</code> is not called</li>
</ol>
<p><strong>Why this matters:</strong></p>
<ul>
<li>All your game state must be in WASM memory (static/global variables)</li>
<li><code>update()</code> must be deterministic</li>
<li><code>render()</code> should only read state, never modify it</li>
</ul>
<pre><code>init()          ← Run once
    │
    ▼
┌─────────────────┐
│   update() ←────┼── Runs at fixed tick rate
│   (snapshot)    │   Rollback replays from here
└────────┬────────┘
         │
         ▼
┌─────────────────┐
│   render() ←────┼── Runs every frame
│   (skipped      │   Skipped during rollback
│    on rollback) │
└────────┬────────┘
         │
         └── Loop back to update()
</code></pre>
<h2 id="helpful-functions"><a class="header" href="#helpful-functions">Helpful Functions</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Returns</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>delta_time()</code></td><td><code>f32</code>/<code>float</code></td><td>Seconds since last tick (fixed)</td></tr>
<tr><td><code>elapsed_time()</code></td><td><code>f32</code>/<code>float</code></td><td>Total seconds since game start</td></tr>
<tr><td><code>tick_count()</code></td><td><code>u64</code>/<code>uint64_t</code></td><td>Number of ticks since start</td></tr>
<tr><td><code>random()</code> / <code>random_u32()</code></td><td><code>u32</code>/<code>uint32_t</code></td><td>Deterministic random number</td></tr>
</tbody>
</table>
</div>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="game-state-machine"><a class="header" href="#game-state-machine">Game State Machine</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq)]
enum GameState {
    Title,
    Playing,
    Paused,
    GameOver,
}

static mut STATE: GameState = GameState::Title;

#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        match STATE {
            GameState::Title =&gt; update_title(),
            GameState::Playing =&gt; update_gameplay(),
            GameState::Paused =&gt; update_pause(),
            GameState::GameOver =&gt; update_game_over(),
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">typedef enum {
    STATE_TITLE,
    STATE_PLAYING,
    STATE_PAUSED,
    STATE_GAME_OVER
} GameState;

static GameState state = STATE_TITLE;

EWZX_EXPORT void update(void) {
    switch (state) {
        case STATE_TITLE:    update_title();     break;
        case STATE_PLAYING:  update_gameplay();  break;
        case STATE_PAUSED:   update_pause();     break;
        case STATE_GAME_OVER: update_game_over(); break;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const GameState = enum {
    title,
    playing,
    paused,
    game_over,
};

var state: GameState = .title;

export fn update() void {
    switch (state) {
        .title =&gt; update_title(),
        .playing =&gt; update_gameplay(),
        .paused =&gt; update_pause(),
        .game_over =&gt; update_game_over(),
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="delta-time-for-smooth-movement"><a class="header" href="#delta-time-for-smooth-movement">Delta Time for Smooth Movement</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        let dt = delta_time();

        // Movement is frame-rate independent
        PLAYER_X += SPEED * dt;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float dt = delta_time();

    /* Movement is frame-rate independent */
    player_x += SPEED * dt;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const dt = delta_time();

    // Movement is frame-rate independent
    player_x += SPEED * dt;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<p><strong>You’re ready to build real games!</strong></p>
<p>Continue to the <a href="#build-paddle">Build Paddle</a> tutorial to create your first complete game, or explore the <a href="#cheat-sheet">API Reference</a> to see all available functions.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="build-paddle"><a class="header" href="#build-paddle">Build Paddle</a></h1>
<p>In this tutorial, you’ll build a complete Paddle game from scratch. By the end, you’ll have a fully playable game with:</p>
<ul>
<li>Two paddles (player-controlled or AI)</li>
<li>Ball physics with collision detection</li>
<li>Score tracking and win conditions</li>
<li>Sound effects loaded from assets</li>
<li>Title screen and game over states</li>
<li><strong>Automatic online multiplayer</strong> via Nethercore’s rollback netcode</li>
</ul>
<p><img src="assets/paddle-preview.png" alt="Paddle game preview"></p>
<h2 id="what-youll-learn"><a class="header" href="#what-youll-learn">What You’ll Learn</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Part</th><th>Topics</th></tr>
</thead>
<tbody>
<tr><td><a href="#part-1-setup--drawing">Part 1: Setup &amp; Drawing</a></td><td>Project creation, FFI imports, <code>draw_rect()</code></td></tr>
<tr><td><a href="#part-2-paddle-movement">Part 2: Paddle Movement</a></td><td>Input handling, game state</td></tr>
<tr><td><a href="#part-3-ball-physics">Part 3: Ball Physics</a></td><td>Velocity, collision detection</td></tr>
<tr><td><a href="#part-4-ai-opponent">Part 4: AI Opponent</a></td><td>Simple AI for single-player</td></tr>
<tr><td><a href="#part-5-multiplayer">Part 5: Multiplayer</a></td><td>The magic of rollback netcode</td></tr>
<tr><td><a href="#part-6-scoring--win-states">Part 6: Scoring &amp; Win States</a></td><td>Game logic, state machine</td></tr>
<tr><td><a href="#part-7-sound-effects">Part 7: Sound Effects</a></td><td>Assets, <code>nether build</code>, audio playback</td></tr>
<tr><td><a href="#part-8-polish--publishing">Part 8: Polish &amp; Publishing</a></td><td>Title screen, publishing to archive</td></tr>
</tbody>
</table>
</div>
<h2 id="prerequisites-1"><a class="header" href="#prerequisites-1">Prerequisites</a></h2>
<p>Before starting this tutorial, you should have:</p>
<ul>
<li>Completed <a href="#your-first-game">Your First Game</a></li>
<li>Rust and WASM target installed (<a href="#prerequisites">Prerequisites</a>)</li>
<li>Basic understanding of the <a href="#understanding-the-game-loop">game loop</a></li>
</ul>
<h2 id="final-code"><a class="header" href="#final-code">Final Code</a></h2>
<p>The complete source code for this tutorial is available in the examples:</p>
<pre><code>nethercore/examples/paddle/
├── Cargo.toml
├── nether.toml
└── src/
    └── lib.rs
</code></pre>
<p>You can build and run it with:</p>
<pre><code class="language-bash">cd examples/paddle
cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<h2 id="time-investment"><a class="header" href="#time-investment">Time Investment</a></h2>
<p>Each part takes about 10-15 minutes to complete. The full tutorial can be finished in about 2 hours.</p>
<hr>
<p><strong>Ready?</strong> Let’s start with <a href="#part-1-setup--drawing">Part 1: Setup &amp; Drawing</a>.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-1-setup--drawing"><a class="header" href="#part-1-setup--drawing">Part 1: Setup &amp; Drawing</a></h1>
<p>In this part, you’ll set up your Paddle project and draw the basic game elements: the court and paddles.</p>
<h2 id="what-youll-learn-1"><a class="header" href="#what-youll-learn-1">What You’ll Learn</a></h2>
<ul>
<li>Creating a new Nethercore game project</li>
<li>Importing FFI functions</li>
<li>Drawing rectangles with <code>draw_rect()</code></li>
<li>Using colors in RGBA hex format</li>
</ul>
<h2 id="create-the-project-1"><a class="header" href="#create-the-project-1">Create the Project</a></h2>
<pre><code class="language-bash">cargo new --lib paddle
cd paddle
</code></pre>
<h2 id="configure-cargotoml"><a class="header" href="#configure-cargotoml">Configure Cargo.toml</a></h2>
<pre><code class="language-toml">[package]
name = "paddle"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib"]

[dependencies]
libm = "0.2"

[profile.release]
opt-level = "s"
lto = true
</code></pre>
<p>We include <code>libm</code> for math functions like <code>sqrt()</code> that we’ll need later.</p>
<h2 id="write-the-basic-structure"><a class="header" href="#write-the-basic-structure">Write the Basic Structure</a></h2>
<p>Create <code>src/lib.rs</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}

// FFI imports from the Nethercore runtime
#[link(wasm_import_module = "env")]
extern "C" {
    fn set_clear_color(color: u32);
    fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32);
}

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        // Dark background
        set_clear_color(0x1a1a2eFF);
    }
}

#[no_mangle]
pub extern "C" fn update() {
    // Game logic will go here
}

#[no_mangle]
pub extern "C" fn render() {
    // Drawing will go here
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;

// FFI imports from the Nethercore runtime
EWZX_IMPORT void set_clear_color(uint32_t color);
EWZX_IMPORT void draw_rect(float x, float y, float w, float h, uint32_t color);

EWZX_EXPORT void init(void) {
    // Dark background
    set_clear_color(0x1a1a2eFF);
}

EWZX_EXPORT void update(void) {
    // Game logic will go here
}

EWZX_EXPORT void render(void) {
    // Drawing will go here
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// FFI imports from the Nethercore runtime
extern fn set_clear_color(color: u32) void;
extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;

export fn init() void {
    // Dark background
    set_clear_color(0x1a1a2eFF);
}

export fn update() void {
    // Game logic will go here
}

export fn render() void {
    // Drawing will go here
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="define-constants"><a class="header" href="#define-constants">Define Constants</a></h2>
<p>Add these constants after the FFI imports:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Screen dimensions (540p default resolution)
const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;

// Paddle dimensions
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;  // Distance from edge

// Ball size
const BALL_SIZE: f32 = 15.0;

// Colors
const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;  // Blue
const COLOR_PLAYER2: u32 = 0xff6b6bFF;  // Red
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Screen dimensions (540p default resolution)
#define SCREEN_WIDTH 960.0f
#define SCREEN_HEIGHT 540.0f

// Paddle dimensions
#define PADDLE_WIDTH 15.0f
#define PADDLE_HEIGHT 80.0f
#define PADDLE_MARGIN 30.0f  // Distance from edge

// Ball size
#define BALL_SIZE 15.0f

// Colors
#define COLOR_WHITE 0xFFFFFFFF
#define COLOR_GRAY 0x666666FF
#define COLOR_PLAYER1 0x4a9fffFF  // Blue
#define COLOR_PLAYER2 0xff6b6bFF  // Red
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Screen dimensions (540p default resolution)
const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;

// Paddle dimensions
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;  // Distance from edge

// Ball size
const BALL_SIZE: f32 = 15.0;

// Colors
const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;  // Blue
const COLOR_PLAYER2: u32 = 0xff6b6bFF;  // Red
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="draw-the-court"><a class="header" href="#draw-the-court">Draw the Court</a></h2>
<p>Let’s draw a dashed center line. Update <code>render()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Draw center line (dashed)
        let dash_height = 20.0;
        let dash_gap = 15.0;
        let dash_width = 4.0;
        let center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;

        let mut y = 10.0;
        while y &lt; SCREEN_HEIGHT - 10.0 {
            draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
            y += dash_height + dash_gap;
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Draw center line (dashed)
    float dash_height = 20.0f;
    float dash_gap = 15.0f;
    float dash_width = 4.0f;
    float center_x = SCREEN_WIDTH / 2.0f - dash_width / 2.0f;

    float y = 10.0f;
    while (y &lt; SCREEN_HEIGHT - 10.0f) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Draw center line (dashed)
    const dash_height = 20.0;
    const dash_gap = 15.0;
    const dash_width = 4.0;
    const center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;

    var y: f32 = 10.0;
    while (y &lt; SCREEN_HEIGHT - 10.0) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="draw-the-paddles"><a class="header" href="#draw-the-paddles">Draw the Paddles</a></h2>
<p>Add paddle state and drawing:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Add after constants
static mut PADDLE1_Y: f32 = 0.0;
static mut PADDLE2_Y: f32 = 0.0;

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);

        // Center paddles vertically
        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Add after constants
static float paddle1_y = 0.0f;
static float paddle2_y = 0.0f;

EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF);

    // Center paddles vertically
    paddle1_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    paddle2_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Add after constants
var paddle1_y: f32 = 0.0;
var paddle2_y: f32 = 0.0;

export fn init() void {
    set_clear_color(0x1a1a2eFF);

    // Center paddles vertically
    paddle1_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    paddle2_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Update <code>render()</code> to draw the paddles:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Draw center line (dashed)
        let dash_height = 20.0;
        let dash_gap = 15.0;
        let dash_width = 4.0;
        let center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;

        let mut y = 10.0;
        while y &lt; SCREEN_HEIGHT - 10.0 {
            draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
            y += dash_height + dash_gap;
        }

        // Draw paddle 1 (left, blue)
        draw_rect(
            PADDLE_MARGIN,
            PADDLE1_Y,
            PADDLE_WIDTH,
            PADDLE_HEIGHT,
            COLOR_PLAYER1,
        );

        // Draw paddle 2 (right, red)
        draw_rect(
            SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH,
            PADDLE2_Y,
            PADDLE_WIDTH,
            PADDLE_HEIGHT,
            COLOR_PLAYER2,
        );
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Draw center line (dashed)
    float dash_height = 20.0f;
    float dash_gap = 15.0f;
    float dash_width = 4.0f;
    float center_x = SCREEN_WIDTH / 2.0f - dash_width / 2.0f;

    float y = 10.0f;
    while (y &lt; SCREEN_HEIGHT - 10.0f) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Draw paddle 1 (left, blue)
    draw_rect(
        PADDLE_MARGIN,
        paddle1_y,
        PADDLE_WIDTH,
        PADDLE_HEIGHT,
        COLOR_PLAYER1
    );

    // Draw paddle 2 (right, red)
    draw_rect(
        SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH,
        paddle2_y,
        PADDLE_WIDTH,
        PADDLE_HEIGHT,
        COLOR_PLAYER2
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Draw center line (dashed)
    const dash_height = 20.0;
    const dash_gap = 15.0;
    const dash_width = 4.0;
    const center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;

    var y: f32 = 10.0;
    while (y &lt; SCREEN_HEIGHT - 10.0) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Draw paddle 1 (left, blue)
    draw_rect(
        PADDLE_MARGIN,
        paddle1_y,
        PADDLE_WIDTH,
        PADDLE_HEIGHT,
        COLOR_PLAYER1,
    );

    // Draw paddle 2 (right, red)
    draw_rect(
        SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH,
        paddle2_y,
        PADDLE_WIDTH,
        PADDLE_HEIGHT,
        COLOR_PLAYER2,
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="draw-the-ball"><a class="header" href="#draw-the-ball">Draw the Ball</a></h2>
<p>Add ball state:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut BALL_X: f32 = 0.0;
static mut BALL_Y: f32 = 0.0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float ball_x = 0.0f;
static float ball_y = 0.0f;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var ball_x: f32 = 0.0;
var ball_y: f32 = 0.0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Initialize it in <code>init()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);

        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

        // Center the ball
        BALL_X = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
        BALL_Y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF);

    paddle1_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    paddle2_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;

    // Center the ball
    ball_x = SCREEN_WIDTH / 2.0f - BALL_SIZE / 2.0f;
    ball_y = SCREEN_HEIGHT / 2.0f - BALL_SIZE / 2.0f;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_clear_color(0x1a1a2eFF);

    paddle1_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    paddle2_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

    // Center the ball
    ball_x = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
    ball_y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Draw it in <code>render()</code> (add after paddles):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>        // Draw ball
        draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">    // Draw ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">    // Draw ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="build-and-test"><a class="header" href="#build-and-test">Build and Test</a></h2>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>You should see:</p>
<ul>
<li>Dark blue background</li>
<li>Dashed white center line</li>
<li>Blue paddle on the left</li>
<li>Red paddle on the right</li>
<li>White ball in the center</li>
</ul>
<h2 id="complete-code-so-far"><a class="header" href="#complete-code-so-far">Complete Code So Far</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}

#[link(wasm_import_module = "env")]
extern "C" {
    fn set_clear_color(color: u32);
    fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32);
}

const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;
const BALL_SIZE: f32 = 15.0;
const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;
const COLOR_PLAYER2: u32 = 0xff6b6bFF;

static mut PADDLE1_Y: f32 = 0.0;
static mut PADDLE2_Y: f32 = 0.0;
static mut BALL_X: f32 = 0.0;
static mut BALL_Y: f32 = 0.0;

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);
        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        BALL_X = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
        BALL_Y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
    }
}

#[no_mangle]
pub extern "C" fn update() {}

#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Center line
        let dash_height = 20.0;
        let dash_gap = 15.0;
        let dash_width = 4.0;
        let center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;
        let mut y = 10.0;
        while y &lt; SCREEN_HEIGHT - 10.0 {
            draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
            y += dash_height + dash_gap;
        }

        // Paddles
        draw_rect(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
        draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, PADDLE2_Y,
                  PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

        // Ball
        draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;

// FFI imports
EWZX_IMPORT void set_clear_color(uint32_t color);
EWZX_IMPORT void draw_rect(float x, float y, float w, float h, uint32_t color);

// Constants
#define SCREEN_WIDTH 960.0f
#define SCREEN_HEIGHT 540.0f
#define PADDLE_WIDTH 15.0f
#define PADDLE_HEIGHT 80.0f
#define PADDLE_MARGIN 30.0f
#define BALL_SIZE 15.0f
#define COLOR_WHITE 0xFFFFFFFF
#define COLOR_GRAY 0x666666FF
#define COLOR_PLAYER1 0x4a9fffFF
#define COLOR_PLAYER2 0xff6b6bFF

// State
static float paddle1_y = 0.0f;
static float paddle2_y = 0.0f;
static float ball_x = 0.0f;
static float ball_y = 0.0f;

EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF);
    paddle1_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    paddle2_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    ball_x = SCREEN_WIDTH / 2.0f - BALL_SIZE / 2.0f;
    ball_y = SCREEN_HEIGHT / 2.0f - BALL_SIZE / 2.0f;
}

EWZX_EXPORT void update(void) {}

EWZX_EXPORT void render(void) {
    // Center line
    float dash_height = 20.0f;
    float dash_gap = 15.0f;
    float dash_width = 4.0f;
    float center_x = SCREEN_WIDTH / 2.0f - dash_width / 2.0f;
    float y = 10.0f;
    while (y &lt; SCREEN_HEIGHT - 10.0f) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Paddles
    draw_rect(PADDLE_MARGIN, paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
    draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, paddle2_y,
              PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

    // Ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// FFI imports
extern fn set_clear_color(color: u32) void;
extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;

// Constants
const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;
const BALL_SIZE: f32 = 15.0;
const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;
const COLOR_PLAYER2: u32 = 0xff6b6bFF;

// State
var paddle1_y: f32 = 0.0;
var paddle2_y: f32 = 0.0;
var ball_x: f32 = 0.0;
var ball_y: f32 = 0.0;

export fn init() void {
    set_clear_color(0x1a1a2eFF);
    paddle1_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    paddle2_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    ball_x = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
    ball_y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
}

export fn update() void {}

export fn render() void {
    // Center line
    const dash_height = 20.0;
    const dash_gap = 15.0;
    const dash_width = 4.0;
    const center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;
    var y: f32 = 10.0;
    while (y &lt; SCREEN_HEIGHT - 10.0) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Paddles
    draw_rect(PADDLE_MARGIN, paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
    draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, paddle2_y,
              PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

    // Ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<p><strong>Next:</strong> <a href="#part-2-paddle-movement">Part 2: Paddle Movement</a> — Make the paddles respond to input.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-2-paddle-movement"><a class="header" href="#part-2-paddle-movement">Part 2: Paddle Movement</a></h1>
<p>Now let’s make the paddles respond to player input.</p>
<h2 id="what-youll-learn-2"><a class="header" href="#what-youll-learn-2">What You’ll Learn</a></h2>
<ul>
<li>Reading input with <code>button_held()</code> and <code>left_stick_y()</code></li>
<li>Clamping values to keep paddles on screen</li>
<li>The difference between <code>button_pressed()</code> and <code>button_held()</code></li>
</ul>
<h2 id="add-input-ffi-functions"><a class="header" href="#add-input-ffi-functions">Add Input FFI Functions</a></h2>
<p>Update your FFI imports:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    fn set_clear_color(color: u32);
    fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32);

    // Input functions
    fn left_stick_y(player: u32) -&gt; f32;
    fn button_held(player: u32, button: u32) -&gt; u32;
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_clear_color(uint32_t color);
EWZX_IMPORT void draw_rect(float x, float y, float w, float h, uint32_t color);

// Input functions
EWZX_IMPORT float left_stick_y(uint32_t player);
EWZX_IMPORT uint32_t button_held(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_clear_color(color: u32) void;
pub extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;

// Input functions
pub extern fn left_stick_y(player: u32) f32;
pub extern fn button_held(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="add-constants-for-input"><a class="header" href="#add-constants-for-input">Add Constants for Input</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Button constants
const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;

// Movement speed
const PADDLE_SPEED: f32 = 8.0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Button constants
#define EWZX_BUTTON_UP 0
#define EWZX_BUTTON_DOWN 1

// Movement speed
#define PADDLE_SPEED 8.0f
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Button constants
const Button = struct {
    pub const up: u32 = 0;
    pub const down: u32 = 1;
};

// Movement speed
const PADDLE_SPEED: f32 = 8.0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="implement-paddle-movement"><a class="header" href="#implement-paddle-movement">Implement Paddle Movement</a></h2>
<p>Update the <code>update()</code> function:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        // Player 1 (left paddle)
        update_paddle(&amp;mut PADDLE1_Y, 0);

        // Player 2 (right paddle) - we'll add AI later
        update_paddle(&amp;mut PADDLE2_Y, 1);
    }
}

fn update_paddle(paddle_y: &amp;mut f32, player: u32) {
    unsafe {
        // Read analog stick (Y axis is inverted: up is negative)
        let stick_y = left_stick_y(player);

        // Read D-pad buttons
        let up = button_held(player, BUTTON_UP) != 0;
        let down = button_held(player, BUTTON_DOWN) != 0;

        // Calculate movement
        let mut movement = -stick_y * PADDLE_SPEED;  // Invert stick

        if up {
            movement -= PADDLE_SPEED;
        }
        if down {
            movement += PADDLE_SPEED;
        }

        // Apply movement
        *paddle_y += movement;

        // Clamp to screen bounds
        *paddle_y = clamp(*paddle_y, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
    }
}

// Helper function
fn clamp(v: f32, min: f32, max: f32) -&gt; f32 {
    if v &lt; min { min } else if v &gt; max { max } else { v }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void update_paddle(float *paddle_y, uint32_t player) {
    // Read analog stick (Y axis is inverted: up is negative)
    float stick_y = left_stick_y(player);

    // Read D-pad buttons
    bool up = button_held(player, EWZX_BUTTON_UP) != 0;
    bool down = button_held(player, EWZX_BUTTON_DOWN) != 0;

    // Calculate movement
    float movement = -stick_y * PADDLE_SPEED;  // Invert stick

    if (up) {
        movement -= PADDLE_SPEED;
    }
    if (down) {
        movement += PADDLE_SPEED;
    }

    // Apply movement
    *paddle_y += movement;

    // Clamp to screen bounds
    *paddle_y = clamp(*paddle_y, 0.0f, SCREEN_HEIGHT - PADDLE_HEIGHT);
}

EWZX_EXPORT void update() {
    // Player 1 (left paddle)
    update_paddle(&amp;paddle1_y, 0);

    // Player 2 (right paddle) - we'll add AI later
    update_paddle(&amp;paddle2_y, 1);
}

// Helper function
float clamp(float v, float min, float max) {
    if (v &lt; min) return min;
    if (v &gt; max) return max;
    return v;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn update_paddle(paddle_y: *f32, player: u32) void {
    // Read analog stick (Y axis is inverted: up is negative)
    const stick_y = left_stick_y(player);

    // Read D-pad buttons
    const up = button_held(player, Button.up) != 0;
    const down = button_held(player, Button.down) != 0;

    // Calculate movement
    var movement = -stick_y * PADDLE_SPEED;  // Invert stick

    if (up) {
        movement -= PADDLE_SPEED;
    }
    if (down) {
        movement += PADDLE_SPEED;
    }

    // Apply movement
    paddle_y.* += movement;

    // Clamp to screen bounds
    paddle_y.* = clamp(paddle_y.*, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
}

export fn update() void {
    // Player 1 (left paddle)
    update_paddle(&amp;paddle1_y, 0);

    // Player 2 (right paddle) - we'll add AI later
    update_paddle(&amp;paddle2_y, 1);
}

// Helper function
fn clamp(v: f32, min: f32, max: f32) f32 {
    if (v &lt; min) return min;
    if (v &gt; max) return max;
    return v;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="understanding-input"><a class="header" href="#understanding-input">Understanding Input</a></h2>
<h3 id="analog-stick"><a class="header" href="#analog-stick">Analog Stick</a></h3>
<p><code>left_stick_y(player)</code> returns a value from -1.0 to 1.0:</p>
<ul>
<li><strong>-1.0</strong> = stick pushed fully up</li>
<li><strong>0.0</strong> = stick at center</li>
<li><strong>1.0</strong> = stick pushed fully down</li>
</ul>
<p>We invert this because screen Y coordinates increase downward.</p>
<h3 id="d-pad-buttons"><a class="header" href="#d-pad-buttons">D-Pad Buttons</a></h3>
<p>There are two ways to read buttons:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Function</th><th>Behavior</th></tr>
</thead>
<tbody>
<tr><td><code>button_pressed(player, button)</code></td><td>Returns <code>1</code> only on the frame the button is first pressed</td></tr>
<tr><td><code>button_held(player, button)</code></td><td>Returns <code>1</code> every frame the button is held down</td></tr>
</tbody>
</table>
</div>
<p>For continuous movement like paddles, use <code>button_held()</code>.</p>
<h3 id="button-constants"><a class="header" href="#button-constants">Button Constants</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_LEFT: u32 = 2;
const BUTTON_RIGHT: u32 = 3;
const BUTTON_A: u32 = 4;
const BUTTON_B: u32 = 5;
const BUTTON_X: u32 = 6;
const BUTTON_Y: u32 = 7;
const BUTTON_LB: u32 = 8;
const BUTTON_RB: u32 = 9;
const BUTTON_START: u32 = 12;
const BUTTON_SELECT: u32 = 13;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define EWZX_BUTTON_UP 0
#define EWZX_BUTTON_DOWN 1
#define EWZX_BUTTON_LEFT 2
#define EWZX_BUTTON_RIGHT 3
#define EWZX_BUTTON_A 4
#define EWZX_BUTTON_B 5
#define EWZX_BUTTON_X 6
#define EWZX_BUTTON_Y 7
#define EWZX_BUTTON_LB 8
#define EWZX_BUTTON_RB 9
#define EWZX_BUTTON_START 12
#define EWZX_BUTTON_SELECT 13
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const Button = struct {
    pub const up: u32 = 0;
    pub const down: u32 = 1;
    pub const left: u32 = 2;
    pub const right: u32 = 3;
    pub const a: u32 = 4;
    pub const b: u32 = 5;
    pub const x: u32 = 6;
    pub const y: u32 = 7;
    pub const lb: u32 = 8;
    pub const rb: u32 = 9;
    pub const start: u32 = 12;
    pub const select: u32 = 13;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="build-and-test-1"><a class="header" href="#build-and-test-1">Build and Test</a></h2>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>Both paddles should now respond to input. Use:</p>
<ul>
<li><strong>Player 1:</strong> Left stick or D-pad on controller 1</li>
<li><strong>Player 2:</strong> Left stick or D-pad on controller 2 (if connected)</li>
</ul>
<p>If you only have one controller, player 2’s paddle won’t move yet - we’ll add AI in Part 4.</p>
<h2 id="complete-code-so-far-1"><a class="header" href="#complete-code-so-far-1">Complete Code So Far</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![no_std]
#![no_main]

<span class="boring">fn main() {
</span>use core::panic::PanicInfo;

#[panic_handler]
fn panic(_info: &amp;PanicInfo) -&gt; ! {
    core::arch::wasm32::unreachable()
}

#[link(wasm_import_module = "env")]
extern "C" {
    fn set_clear_color(color: u32);
    fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32);
    fn left_stick_y(player: u32) -&gt; f32;
    fn button_held(player: u32, button: u32) -&gt; u32;
}

const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;
const PADDLE_SPEED: f32 = 8.0;
const BALL_SIZE: f32 = 15.0;

const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;

const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;
const COLOR_PLAYER2: u32 = 0xff6b6bFF;

static mut PADDLE1_Y: f32 = 0.0;
static mut PADDLE2_Y: f32 = 0.0;
static mut BALL_X: f32 = 0.0;
static mut BALL_Y: f32 = 0.0;

fn clamp(v: f32, min: f32, max: f32) -&gt; f32 {
    if v &lt; min { min } else if v &gt; max { max } else { v }
}

fn update_paddle(paddle_y: &amp;mut f32, player: u32) {
    unsafe {
        let stick_y = left_stick_y(player);
        let up = button_held(player, BUTTON_UP) != 0;
        let down = button_held(player, BUTTON_DOWN) != 0;

        let mut movement = -stick_y * PADDLE_SPEED;
        if up { movement -= PADDLE_SPEED; }
        if down { movement += PADDLE_SPEED; }

        *paddle_y += movement;
        *paddle_y = clamp(*paddle_y, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
    }
}

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);
        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        BALL_X = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
        BALL_Y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
    }
}

#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        update_paddle(&amp;mut PADDLE1_Y, 0);
        update_paddle(&amp;mut PADDLE2_Y, 1);
    }
}

#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // Center line
        let dash_height = 20.0;
        let dash_gap = 15.0;
        let dash_width = 4.0;
        let center_x = SCREEN_WIDTH / 2.0 - dash_width / 2.0;
        let mut y = 10.0;
        while y &lt; SCREEN_HEIGHT - 10.0 {
            draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
            y += dash_height + dash_gap;
        }

        // Paddles
        draw_rect(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
        draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, PADDLE2_Y,
                  PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

        // Ball
        draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;stdint.h&gt;
#include &lt;stdbool.h&gt;

EWZX_IMPORT void set_clear_color(uint32_t color);
EWZX_IMPORT void draw_rect(float x, float y, float w, float h, uint32_t color);
EWZX_IMPORT float left_stick_y(uint32_t player);
EWZX_IMPORT uint32_t button_held(uint32_t player, uint32_t button);

#define SCREEN_WIDTH 960.0f
#define SCREEN_HEIGHT 540.0f
#define PADDLE_WIDTH 15.0f
#define PADDLE_HEIGHT 80.0f
#define PADDLE_MARGIN 30.0f
#define PADDLE_SPEED 8.0f
#define BALL_SIZE 15.0f

#define EWZX_BUTTON_UP 0
#define EWZX_BUTTON_DOWN 1

#define COLOR_WHITE 0xFFFFFFFF
#define COLOR_GRAY 0x666666FF
#define COLOR_PLAYER1 0x4a9fffFF
#define COLOR_PLAYER2 0xff6b6bFF

static float paddle1_y = 0.0f;
static float paddle2_y = 0.0f;
static float ball_x = 0.0f;
static float ball_y = 0.0f;

float clamp(float v, float min, float max) {
    if (v &lt; min) return min;
    if (v &gt; max) return max;
    return v;
}

void update_paddle(float *paddle_y, uint32_t player) {
    float stick_y = left_stick_y(player);
    bool up = button_held(player, EWZX_BUTTON_UP) != 0;
    bool down = button_held(player, EWZX_BUTTON_DOWN) != 0;

    float movement = -stick_y * PADDLE_SPEED;
    if (up) movement -= PADDLE_SPEED;
    if (down) movement += PADDLE_SPEED;

    *paddle_y += movement;
    *paddle_y = clamp(*paddle_y, 0.0f, SCREEN_HEIGHT - PADDLE_HEIGHT);
}

EWZX_EXPORT void init() {
    set_clear_color(0x1a1a2eFF);
    paddle1_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    paddle2_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    ball_x = SCREEN_WIDTH / 2.0f - BALL_SIZE / 2.0f;
    ball_y = SCREEN_HEIGHT / 2.0f - BALL_SIZE / 2.0f;
}

EWZX_EXPORT void update() {
    update_paddle(&amp;paddle1_y, 0);
    update_paddle(&amp;paddle2_y, 1);
}

EWZX_EXPORT void render() {
    // Center line
    float dash_height = 20.0f;
    float dash_gap = 15.0f;
    float dash_width = 4.0f;
    float center_x = SCREEN_WIDTH / 2.0f - dash_width / 2.0f;
    float y = 10.0f;
    while (y &lt; SCREEN_HEIGHT - 10.0f) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Paddles
    draw_rect(PADDLE_MARGIN, paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
    draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, paddle2_y,
              PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

    // Ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const std = @import("std");

pub extern fn set_clear_color(color: u32) void;
pub extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;
pub extern fn left_stick_y(player: u32) f32;
pub extern fn button_held(player: u32, button: u32) u32;

const SCREEN_WIDTH: f32 = 960.0;
const SCREEN_HEIGHT: f32 = 540.0;
const PADDLE_WIDTH: f32 = 15.0;
const PADDLE_HEIGHT: f32 = 80.0;
const PADDLE_MARGIN: f32 = 30.0;
const PADDLE_SPEED: f32 = 8.0;
const BALL_SIZE: f32 = 15.0;

const Button = struct {
    pub const up: u32 = 0;
    pub const down: u32 = 1;
};

const COLOR_WHITE: u32 = 0xFFFFFFFF;
const COLOR_GRAY: u32 = 0x666666FF;
const COLOR_PLAYER1: u32 = 0x4a9fffFF;
const COLOR_PLAYER2: u32 = 0xff6b6bFF;

var paddle1_y: f32 = 0.0;
var paddle2_y: f32 = 0.0;
var ball_x: f32 = 0.0;
var ball_y: f32 = 0.0;

fn clamp(v: f32, min: f32, max: f32) f32 {
    if (v &lt; min) return min;
    if (v &gt; max) return max;
    return v;
}

fn update_paddle(paddle_y: *f32, player: u32) void {
    const stick_y = left_stick_y(player);
    const up = button_held(player, Button.up) != 0;
    const down = button_held(player, Button.down) != 0;

    var movement = -stick_y * PADDLE_SPEED;
    if (up) movement -= PADDLE_SPEED;
    if (down) movement += PADDLE_SPEED;

    paddle_y.* += movement;
    paddle_y.* = clamp(paddle_y.*, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
}

export fn init() void {
    set_clear_color(0x1a1a2eFF);
    paddle1_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    paddle2_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    ball_x = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
    ball_y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;
}

export fn update() void {
    update_paddle(&amp;paddle1_y, 0);
    update_paddle(&amp;paddle2_y, 1);
}

export fn render() void {
    // Center line
    const dash_height: f32 = 20.0;
    const dash_gap: f32 = 15.0;
    const dash_width: f32 = 4.0;
    const center_x: f32 = SCREEN_WIDTH / 2.0 - dash_width / 2.0;
    var y: f32 = 10.0;
    while (y &lt; SCREEN_HEIGHT - 10.0) {
        draw_rect(center_x, y, dash_width, dash_height, COLOR_GRAY);
        y += dash_height + dash_gap;
    }

    // Paddles
    draw_rect(PADDLE_MARGIN, paddle1_y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
    draw_rect(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, paddle2_y,
              PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER2);

    // Ball
    draw_rect(ball_x, ball_y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<p><strong>Next:</strong> <a href="#part-3-ball-physics">Part 3: Ball Physics</a> - Make the ball move and bounce.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-3-ball-physics"><a class="header" href="#part-3-ball-physics">Part 3: Ball Physics</a></h1>
<p>Time to make the ball move! We’ll add velocity, wall bouncing, and paddle collision.</p>
<h2 id="what-youll-learn-3"><a class="header" href="#what-youll-learn-3">What You’ll Learn</a></h2>
<ul>
<li>Ball velocity and movement</li>
<li>Wall collision (top and bottom)</li>
<li>Paddle collision with spin</li>
<li>AABB collision detection</li>
</ul>
<h2 id="add-ball-velocity"><a class="header" href="#add-ball-velocity">Add Ball Velocity</a></h2>
<p>Update your ball state to include velocity:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut BALL_X: f32 = 0.0;
static mut BALL_Y: f32 = 0.0;
static mut BALL_VX: f32 = 0.0;  // Horizontal velocity
static mut BALL_VY: f32 = 0.0;  // Vertical velocity
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float BALL_X = 0.0f;
static float BALL_Y = 0.0f;
static float BALL_VX = 0.0f;  // Horizontal velocity
static float BALL_VY = 0.0f;  // Vertical velocity
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var BALL_X: f32 = 0.0;
var BALL_Y: f32 = 0.0;
var BALL_VX: f32 = 0.0;  // Horizontal velocity
var BALL_VY: f32 = 0.0;  // Vertical velocity
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Add ball speed constants:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BALL_SPEED_INITIAL: f32 = 5.0;
const BALL_SPEED_MAX: f32 = 12.0;
const BALL_SPEED_INCREMENT: f32 = 0.5;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define BALL_SPEED_INITIAL 5.0f
#define BALL_SPEED_MAX 12.0f
#define BALL_SPEED_INCREMENT 0.5f
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const BALL_SPEED_INITIAL: f32 = 5.0;
const BALL_SPEED_MAX: f32 = 12.0;
const BALL_SPEED_INCREMENT: f32 = 0.5;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="add-random-ffi"><a class="header" href="#add-random-ffi">Add Random FFI</a></h2>
<p>We need randomness to vary the ball’s starting angle:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...
    fn random() -&gt; u32;
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Add to imports section
EWZX_IMPORT uint32_t random_u32(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Add to imports section
pub extern fn random_u32() u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="reset-ball-function"><a class="header" href="#reset-ball-function">Reset Ball Function</a></h2>
<p>Create a function to reset the ball position and give it a random velocity:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset_ball(direction: i32) {
    unsafe {
        // Center the ball
        BALL_X = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
        BALL_Y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;

        // Random vertical angle (-0.25 to 0.25)
        let rand = random() % 100;
        let angle = ((rand as f32 / 100.0) - 0.5) * 0.5;

        // Set velocity
        BALL_VX = BALL_SPEED_INITIAL * direction as f32;
        BALL_VY = BALL_SPEED_INITIAL * angle;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void reset_ball(int32_t direction) {
    // Center the ball
    BALL_X = SCREEN_WIDTH / 2.0f - BALL_SIZE / 2.0f;
    BALL_Y = SCREEN_HEIGHT / 2.0f - BALL_SIZE / 2.0f;

    // Random vertical angle (-0.25 to 0.25)
    uint32_t rand = random_u32() % 100;
    float angle = ((rand / 100.0f) - 0.5f) * 0.5f;

    // Set velocity
    BALL_VX = BALL_SPEED_INITIAL * (float)direction;
    BALL_VY = BALL_SPEED_INITIAL * angle;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn reset_ball(direction: i32) void {
    // Center the ball
    BALL_X = SCREEN_WIDTH / 2.0 - BALL_SIZE / 2.0;
    BALL_Y = SCREEN_HEIGHT / 2.0 - BALL_SIZE / 2.0;

    // Random vertical angle (-0.25 to 0.25)
    const rand = random_u32() % 100;
    const angle = ((@as(f32, @floatFromInt(rand)) / 100.0) - 0.5) * 0.5;

    // Set velocity
    BALL_VX = BALL_SPEED_INITIAL * @as(f32, @floatFromInt(direction));
    BALL_VY = BALL_SPEED_INITIAL * angle;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Update <code>init()</code> to use it:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);
        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

        reset_ball(-1);  // Start moving toward player 1
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF);
    PADDLE1_Y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    PADDLE2_Y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;

    reset_ball(-1);  // Start moving toward player 1
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_clear_color(0x1a1a2eFF);
    PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

    reset_ball(-1);  // Start moving toward player 1
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="ball-movement-and-wall-bounce"><a class="header" href="#ball-movement-and-wall-bounce">Ball Movement and Wall Bounce</a></h2>
<p>Create an <code>update_ball()</code> function:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_ball() {
    unsafe {
        // Move ball
        BALL_X += BALL_VX;
        BALL_Y += BALL_VY;

        // Bounce off top wall
        if BALL_Y &lt;= 0.0 {
            BALL_Y = 0.0;
            BALL_VY = -BALL_VY;
        }

        // Bounce off bottom wall
        if BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE {
            BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
            BALL_VY = -BALL_VY;
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void update_ball(void) {
    // Move ball
    BALL_X += BALL_VX;
    BALL_Y += BALL_VY;

    // Bounce off top wall
    if (BALL_Y &lt;= 0.0f) {
        BALL_Y = 0.0f;
        BALL_VY = -BALL_VY;
    }

    // Bounce off bottom wall
    if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
        BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
        BALL_VY = -BALL_VY;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn update_ball() void {
    // Move ball
    BALL_X += BALL_VX;
    BALL_Y += BALL_VY;

    // Bounce off top wall
    if (BALL_Y &lt;= 0.0) {
        BALL_Y = 0.0;
        BALL_VY = -BALL_VY;
    }

    // Bounce off bottom wall
    if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
        BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
        BALL_VY = -BALL_VY;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Call it from <code>update()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        update_paddle(&amp;mut PADDLE1_Y, 0);
        update_paddle(&amp;mut PADDLE2_Y, 1);
        update_ball();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    update_paddle(&amp;PADDLE1_Y, 0);
    update_paddle(&amp;PADDLE2_Y, 1);
    update_ball();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    update_paddle(&amp;PADDLE1_Y, 0);
    update_paddle(&amp;PADDLE2_Y, 1);
    update_ball();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="paddle-collision"><a class="header" href="#paddle-collision">Paddle Collision</a></h2>
<p>Now add collision detection with the paddles. Update <code>update_ball()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_ball() {
    unsafe {
        // Move ball
        BALL_X += BALL_VX;
        BALL_Y += BALL_VY;

        // Bounce off top wall
        if BALL_Y &lt;= 0.0 {
            BALL_Y = 0.0;
            BALL_VY = -BALL_VY;
        }

        // Bounce off bottom wall
        if BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE {
            BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
            BALL_VY = -BALL_VY;
        }

        // Paddle 1 (left) collision
        if BALL_VX &lt; 0.0 {  // Ball moving left
            let paddle_x = PADDLE_MARGIN;
            let paddle_right = paddle_x + PADDLE_WIDTH;

            if BALL_X &lt;= paddle_right
                &amp;&amp; BALL_X + BALL_SIZE &gt;= paddle_x
                &amp;&amp; BALL_Y + BALL_SIZE &gt;= PADDLE1_Y
                &amp;&amp; BALL_Y &lt;= PADDLE1_Y + PADDLE_HEIGHT
            {
                // Bounce
                BALL_X = paddle_right;
                BALL_VX = -BALL_VX;

                // Add spin based on where ball hit paddle
                let paddle_center = PADDLE1_Y + PADDLE_HEIGHT / 2.0;
                let ball_center = BALL_Y + BALL_SIZE / 2.0;
                let offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0);
                BALL_VY += offset * 2.0;

                // Speed up (makes game more exciting)
                speed_up_ball();
            }
        }

        // Paddle 2 (right) collision
        if BALL_VX &gt; 0.0 {  // Ball moving right
            let paddle_x = SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

            if BALL_X + BALL_SIZE &gt;= paddle_x
                &amp;&amp; BALL_X &lt;= paddle_x + PADDLE_WIDTH
                &amp;&amp; BALL_Y + BALL_SIZE &gt;= PADDLE2_Y
                &amp;&amp; BALL_Y &lt;= PADDLE2_Y + PADDLE_HEIGHT
            {
                // Bounce
                BALL_X = paddle_x - BALL_SIZE;
                BALL_VX = -BALL_VX;

                // Add spin
                let paddle_center = PADDLE2_Y + PADDLE_HEIGHT / 2.0;
                let ball_center = BALL_Y + BALL_SIZE / 2.0;
                let offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0);
                BALL_VY += offset * 2.0;

                speed_up_ball();
            }
        }

        // Ball goes off screen (scoring - we'll handle this properly later)
        if BALL_X &lt; -BALL_SIZE || BALL_X &gt; SCREEN_WIDTH {
            reset_ball(if BALL_X &lt; 0.0 { 1 } else { -1 });
        }
    }
}

fn speed_up_ball() {
    unsafe {
        let speed = libm::sqrtf(BALL_VX * BALL_VX + BALL_VY * BALL_VY);
        if speed &lt; BALL_SPEED_MAX {
            let factor = (speed + BALL_SPEED_INCREMENT) / speed;
            BALL_VX *= factor;
            BALL_VY *= factor;
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void update_ball(void) {
    // Move ball
    BALL_X += BALL_VX;
    BALL_Y += BALL_VY;

    // Bounce off top wall
    if (BALL_Y &lt;= 0.0f) {
        BALL_Y = 0.0f;
        BALL_VY = -BALL_VY;
    }

    // Bounce off bottom wall
    if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
        BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
        BALL_VY = -BALL_VY;
    }

    // Paddle 1 (left) collision
    if (BALL_VX &lt; 0.0f) {  // Ball moving left
        float paddle_x = PADDLE_MARGIN;
        float paddle_right = paddle_x + PADDLE_WIDTH;

        if (BALL_X &lt;= paddle_right
            &amp;&amp; BALL_X + BALL_SIZE &gt;= paddle_x
            &amp;&amp; BALL_Y + BALL_SIZE &gt;= PADDLE1_Y
            &amp;&amp; BALL_Y &lt;= PADDLE1_Y + PADDLE_HEIGHT)
        {
            // Bounce
            BALL_X = paddle_right;
            BALL_VX = -BALL_VX;

            // Add spin based on where ball hit paddle
            float paddle_center = PADDLE1_Y + PADDLE_HEIGHT / 2.0f;
            float ball_center = BALL_Y + BALL_SIZE / 2.0f;
            float offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0f);
            BALL_VY += offset * 2.0f;

            // Speed up (makes game more exciting)
            speed_up_ball();
        }
    }

    // Paddle 2 (right) collision
    if (BALL_VX &gt; 0.0f) {  // Ball moving right
        float paddle_x = SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

        if (BALL_X + BALL_SIZE &gt;= paddle_x
            &amp;&amp; BALL_X &lt;= paddle_x + PADDLE_WIDTH
            &amp;&amp; BALL_Y + BALL_SIZE &gt;= PADDLE2_Y
            &amp;&amp; BALL_Y &lt;= PADDLE2_Y + PADDLE_HEIGHT)
        {
            // Bounce
            BALL_X = paddle_x - BALL_SIZE;
            BALL_VX = -BALL_VX;

            // Add spin
            float paddle_center = PADDLE2_Y + PADDLE_HEIGHT / 2.0f;
            float ball_center = BALL_Y + BALL_SIZE / 2.0f;
            float offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0f);
            BALL_VY += offset * 2.0f;

            speed_up_ball();
        }
    }

    // Ball goes off screen (scoring - we'll handle this properly later)
    if (BALL_X &lt; -BALL_SIZE || BALL_X &gt; SCREEN_WIDTH) {
        reset_ball(BALL_X &lt; 0.0f ? 1 : -1);
    }
}

void speed_up_ball(void) {
    float speed = sqrtf(BALL_VX * BALL_VX + BALL_VY * BALL_VY);
    if (speed &lt; BALL_SPEED_MAX) {
        float factor = (speed + BALL_SPEED_INCREMENT) / speed;
        BALL_VX *= factor;
        BALL_VY *= factor;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn update_ball() void {
    // Move ball
    BALL_X += BALL_VX;
    BALL_Y += BALL_VY;

    // Bounce off top wall
    if (BALL_Y &lt;= 0.0) {
        BALL_Y = 0.0;
        BALL_VY = -BALL_VY;
    }

    // Bounce off bottom wall
    if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
        BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
        BALL_VY = -BALL_VY;
    }

    // Paddle 1 (left) collision
    if (BALL_VX &lt; 0.0) {  // Ball moving left
        const paddle_x = PADDLE_MARGIN;
        const paddle_right = paddle_x + PADDLE_WIDTH;

        if (BALL_X &lt;= paddle_right and
            BALL_X + BALL_SIZE &gt;= paddle_x and
            BALL_Y + BALL_SIZE &gt;= PADDLE1_Y and
            BALL_Y &lt;= PADDLE1_Y + PADDLE_HEIGHT)
        {
            // Bounce
            BALL_X = paddle_right;
            BALL_VX = -BALL_VX;

            // Add spin based on where ball hit paddle
            const paddle_center = PADDLE1_Y + PADDLE_HEIGHT / 2.0;
            const ball_center = BALL_Y + BALL_SIZE / 2.0;
            const offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0);
            BALL_VY += offset * 2.0;

            // Speed up (makes game more exciting)
            speed_up_ball();
        }
    }

    // Paddle 2 (right) collision
    if (BALL_VX &gt; 0.0) {  // Ball moving right
        const paddle_x = SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH;

        if (BALL_X + BALL_SIZE &gt;= paddle_x and
            BALL_X &lt;= paddle_x + PADDLE_WIDTH and
            BALL_Y + BALL_SIZE &gt;= PADDLE2_Y and
            BALL_Y &lt;= PADDLE2_Y + PADDLE_HEIGHT)
        {
            // Bounce
            BALL_X = paddle_x - BALL_SIZE;
            BALL_VX = -BALL_VX;

            // Add spin
            const paddle_center = PADDLE2_Y + PADDLE_HEIGHT / 2.0;
            const ball_center = BALL_Y + BALL_SIZE / 2.0;
            const offset = (ball_center - paddle_center) / (PADDLE_HEIGHT / 2.0);
            BALL_VY += offset * 2.0;

            speed_up_ball();
        }
    }

    // Ball goes off screen (scoring - we'll handle this properly later)
    if (BALL_X &lt; -BALL_SIZE or BALL_X &gt; SCREEN_WIDTH) {
        reset_ball(if (BALL_X &lt; 0.0) 1 else -1);
    }
}

fn speed_up_ball() void {
    const speed = @sqrt(BALL_VX * BALL_VX + BALL_VY * BALL_VY);
    if (speed &lt; BALL_SPEED_MAX) {
        const factor = (speed + BALL_SPEED_INCREMENT) / speed;
        BALL_VX *= factor;
        BALL_VY *= factor;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="understanding-the-collision"><a class="header" href="#understanding-the-collision">Understanding the Collision</a></h2>
<h3 id="aabb-axis-aligned-bounding-box"><a class="header" href="#aabb-axis-aligned-bounding-box">AABB (Axis-Aligned Bounding Box)</a></h3>
<p>The collision check uses AABB overlap testing:</p>
<pre><code>Ball overlaps Paddle if:
  ball.left &lt; paddle.right  AND
  ball.right &gt; paddle.left  AND
  ball.top &lt; paddle.bottom  AND
  ball.bottom &gt; paddle.top
</code></pre>
<h3 id="spin-system"><a class="header" href="#spin-system">Spin System</a></h3>
<p>When the ball hits the paddle:</p>
<ul>
<li>Hit the <strong>top</strong> of the paddle → ball goes <strong>up</strong> more</li>
<li>Hit the <strong>center</strong> → ball goes <strong>straight</strong></li>
<li>Hit the <strong>bottom</strong> → ball goes <strong>down</strong> more</li>
</ul>
<p>This gives players control over the ball direction.</p>
<h2 id="build-and-test-2"><a class="header" href="#build-and-test-2">Build and Test</a></h2>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>The ball should now:</p>
<ul>
<li>Move across the screen</li>
<li>Bounce off top and bottom walls</li>
<li>Bounce off paddles with spin</li>
<li>Reset when it goes off screen</li>
</ul>
<hr>
<p><strong>Next:</strong> <a href="#part-4-ai-opponent">Part 4: AI Opponent</a> - Add an AI for single-player mode.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-4-ai-opponent"><a class="header" href="#part-4-ai-opponent">Part 4: AI Opponent</a></h1>
<p>Let’s add an AI opponent so single players can enjoy the game.</p>
<h2 id="what-youll-learn-4"><a class="header" href="#what-youll-learn-4">What You’ll Learn</a></h2>
<ul>
<li>Simple AI that follows the ball</li>
<li>Checking player count with <code>player_count()</code></li>
<li>Making AI beatable (not perfect)</li>
</ul>
<h2 id="add-player-count-ffi"><a class="header" href="#add-player-count-ffi">Add Player Count FFI</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...
    fn player_count() -&gt; u32;
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Add to your imports
EWZX_IMPORT uint32_t player_count(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Add to your imports
pub extern fn player_count() u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="track-game-mode"><a class="header" href="#track-game-mode">Track Game Mode</a></h2>
<p>Add a state variable to track whether we’re in two-player mode:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut IS_TWO_PLAYER: bool = false;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static bool is_two_player = false;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var is_two_player: bool = false;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="simple-ai-logic"><a class="header" href="#simple-ai-logic">Simple AI Logic</a></h2>
<p>Create an AI update function:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_ai(paddle_y: &amp;mut f32) {
    unsafe {
        // AI follows the ball
        let paddle_center = *paddle_y + PADDLE_HEIGHT / 2.0;
        let ball_center = BALL_Y + BALL_SIZE / 2.0;

        let diff = ball_center - paddle_center;

        // Only move if difference is significant (dead zone)
        if diff.abs() &gt; 5.0 {
            // AI moves slower than max speed to be beatable
            let ai_speed = PADDLE_SPEED * 0.7;

            if diff &gt; 0.0 {
                *paddle_y += ai_speed;
            } else {
                *paddle_y -= ai_speed;
            }
        }

        // Clamp to screen bounds
        *paddle_y = clamp(*paddle_y, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void update_ai(float* paddle_y) {
    // AI follows the ball
    float paddle_center = *paddle_y + PADDLE_HEIGHT / 2.0f;
    float ball_center = ball_y + BALL_SIZE / 2.0f;

    float diff = ball_center - paddle_center;

    // Only move if difference is significant (dead zone)
    if (fabsf(diff) &gt; 5.0f) {
        // AI moves slower than max speed to be beatable
        float ai_speed = PADDLE_SPEED * 0.7f;

        if (diff &gt; 0.0f) {
            *paddle_y += ai_speed;
        } else {
            *paddle_y -= ai_speed;
        }
    }

    // Clamp to screen bounds
    *paddle_y = clamp(*paddle_y, 0.0f, SCREEN_HEIGHT - PADDLE_HEIGHT);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn updateAi(paddle_y: *f32) void {
    // AI follows the ball
    const paddle_center = paddle_y.* + PADDLE_HEIGHT / 2.0;
    const ball_center = ball_y + BALL_SIZE / 2.0;

    const diff = ball_center - paddle_center;

    // Only move if difference is significant (dead zone)
    if (@abs(diff) &gt; 5.0) {
        // AI moves slower than max speed to be beatable
        const ai_speed = PADDLE_SPEED * 0.7;

        if (diff &gt; 0.0) {
            paddle_y.* += ai_speed;
        } else {
            paddle_y.* -= ai_speed;
        }
    }

    // Clamp to screen bounds
    paddle_y.* = clamp(paddle_y.*, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>You’ll also need this helper:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn abs(v: f32) -&gt; f32 {
    if v &lt; 0.0 { -v } else { v }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Use fabsf() from math.h (already shown in update_ai above)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Use @abs() builtin (already shown in updateAi above)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="update-the-game-loop"><a class="header" href="#update-the-game-loop">Update the Game Loop</a></h2>
<p>Modify <code>update()</code> to use AI when appropriate:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        // Check if a second player is connected
        IS_TWO_PLAYER = player_count() &gt;= 2;

        // Player 1 always uses input
        update_paddle(&amp;mut PADDLE1_Y, 0);

        // Player 2: human or AI
        if IS_TWO_PLAYER {
            update_paddle(&amp;mut PADDLE2_Y, 1);
        } else {
            update_ai(&amp;mut PADDLE2_Y);
        }

        update_ball();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // Check if a second player is connected
    is_two_player = player_count() &gt;= 2;

    // Player 1 always uses input
    update_paddle(&amp;paddle1_y, 0);

    // Player 2: human or AI
    if (is_two_player) {
        update_paddle(&amp;paddle2_y, 1);
    } else {
        update_ai(&amp;paddle2_y);
    }

    update_ball();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Check if a second player is connected
    is_two_player = player_count() &gt;= 2;

    // Player 1 always uses input
    updatePaddle(&amp;paddle1_y, 0);

    // Player 2: human or AI
    if (is_two_player) {
        updatePaddle(&amp;paddle2_y, 1);
    } else {
        updateAi(&amp;paddle2_y);
    }

    updateBall();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="show-game-mode"><a class="header" href="#show-game-mode">Show Game Mode</a></h2>
<p>Let’s display the current mode. Add text FFI:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...
    fn draw_text(ptr: *const u8, len: u32, x: f32, y: f32, size: f32, color: u32);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Add to your imports
EWZX_IMPORT void draw_text(const uint8_t* ptr, uint32_t len, float x, float y, float size, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Add to your imports
pub extern fn draw_text(ptr: [*]const u8, len: u32, x: f32, y: f32, size: f32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Add to <code>render()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // ... existing drawing code ...

        // Show mode indicator
        if IS_TWO_PLAYER {
            let text = b"2 PLAYERS";
            draw_text(text.as_ptr(), text.len() as u32, 10.0, 10.0, 16.0, COLOR_GRAY);
        } else {
            let text = b"vs AI";
            draw_text(text.as_ptr(), text.len() as u32, 10.0, 10.0, 16.0, COLOR_GRAY);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // ... existing drawing code ...

    // Show mode indicator
    if (is_two_player) {
        draw_text((uint8_t*)"2 PLAYERS", 9, 10.0f, 10.0f, 16.0f, COLOR_GRAY);
    } else {
        draw_text((uint8_t*)"vs AI", 5, 10.0f, 10.0f, 16.0f, COLOR_GRAY);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // ... existing drawing code ...

    // Show mode indicator
    if (is_two_player) {
        draw_text("2 PLAYERS", 9, 10.0, 10.0, 16.0, COLOR_GRAY);
    } else {
        draw_text("vs AI", 5, 10.0, 10.0, 16.0, COLOR_GRAY);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="how-the-ai-works"><a class="header" href="#how-the-ai-works">How the AI Works</a></h2>
<p>The AI is intentionally imperfect:</p>
<ol>
<li><strong>Follows the ball</strong> - Moves toward where the ball is</li>
<li><strong>Slower speed</strong> - Only 70% of max paddle speed</li>
<li><strong>Dead zone</strong> - Doesn’t jitter when ball is near center</li>
<li><strong>No prediction</strong> - Doesn’t anticipate where ball will go</li>
</ol>
<p>This makes the AI beatable but still challenging.</p>
<h3 id="making-ai-harder-or-easier"><a class="header" href="#making-ai-harder-or-easier">Making AI Harder or Easier</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Easier AI (50% speed)
let ai_speed = PADDLE_SPEED * 0.5;

// Harder AI (90% speed)
let ai_speed = PADDLE_SPEED * 0.9;

// Perfect AI (instant tracking) - not fun!
*paddle_y = ball_center - PADDLE_HEIGHT / 2.0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Easier AI (50% speed)
float ai_speed = PADDLE_SPEED * 0.5f;

// Harder AI (90% speed)
float ai_speed = PADDLE_SPEED * 0.9f;

// Perfect AI (instant tracking) - not fun!
*paddle_y = ball_center - PADDLE_HEIGHT / 2.0f;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Easier AI (50% speed)
const ai_speed = PADDLE_SPEED * 0.5;

// Harder AI (90% speed)
const ai_speed = PADDLE_SPEED * 0.9;

// Perfect AI (instant tracking) - not fun!
paddle_y.* = ball_center - PADDLE_HEIGHT / 2.0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="the-magic-automatic-multiplayer"><a class="header" href="#the-magic-automatic-multiplayer">The Magic: Automatic Multiplayer</a></h2>
<p>Here’s the key insight: <strong>when a second player connects, the game automatically becomes two-player</strong>. You don’t need to do anything special!</p>
<p>This works because:</p>
<ol>
<li>We check <code>player_count()</code> every frame</li>
<li>Player 2 input is always read (even if unused)</li>
<li>The switch from AI to human is seamless</li>
</ol>
<p>When a friend joins your game online via Nethercore’s netcode, <code>player_count()</code> increases and they take control of paddle 2.</p>
<h2 id="build-and-test-3"><a class="header" href="#build-and-test-3">Build and Test</a></h2>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>With one controller:</p>
<ul>
<li>You control player 1</li>
<li>AI controls player 2</li>
<li>“vs AI” appears in corner</li>
</ul>
<p>Connect a second controller:</p>
<ul>
<li>Both players are human</li>
<li>“2 PLAYERS” appears</li>
</ul>
<hr>
<p><strong>Next:</strong> <a href="#part-5-multiplayer">Part 5: Multiplayer</a> - Understanding the rollback netcode magic.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-5-multiplayer"><a class="header" href="#part-5-multiplayer">Part 5: Multiplayer</a></h1>
<p>This is where Nethercore’s magic happens. Our Paddle game already supports online multiplayer - and we didn’t write any networking code!</p>
<h2 id="what-youll-learn-5"><a class="header" href="#what-youll-learn-5">What You’ll Learn</a></h2>
<ul>
<li>How Nethercore’s rollback netcode works</li>
<li>Why all game state must be in static variables</li>
<li>Rules for deterministic code</li>
<li>What happens during a rollback</li>
</ul>
<h2 id="the-magic"><a class="header" href="#the-magic">The Magic</a></h2>
<p>Here’s a surprising fact: <strong>your Paddle game already works online</strong>.</p>
<p>When two players connect over the internet:</p>
<ol>
<li>Player 1’s inputs are sent to Player 2’s game</li>
<li>Player 2’s inputs are sent to Player 1’s game</li>
<li>Both games run the same <code>update()</code> function with the same inputs</li>
<li>Both games show the same result</li>
</ol>
<p><strong>You didn’t write a single line of networking code.</strong></p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<h3 id="rollback-netcode"><a class="header" href="#rollback-netcode">Rollback Netcode</a></h3>
<p>Traditional netcode waits for the other player’s input before advancing. This causes lag.</p>
<p>Nethercore uses <strong>rollback netcode</strong>:</p>
<ol>
<li><strong>Predict</strong>: Don’t have remote input? Guess it (usually “same as last frame”)</li>
<li><strong>Continue</strong>: Run the game with the prediction</li>
<li><strong>Correct</strong>: When real input arrives, if it differs from prediction:
<ul>
<li>Roll back to the snapshot</li>
<li>Replay with correct input</li>
<li>Catch up to present</li>
</ul>
</li>
</ol>
<h3 id="automatic-snapshots"><a class="header" href="#automatic-snapshots">Automatic Snapshots</a></h3>
<p>Every frame, Nethercore snapshots your entire WASM memory:</p>
<pre><code>Frame 1: [snapshot] → update() → render()
Frame 2: [snapshot] → update() → render()
Frame 3: [snapshot] → update() → render()
         ↑
         If rollback needed, restore this and replay
</code></pre>
<p>This is why all game state must be in <code>static mut</code> variables - they live in WASM memory and get snapshotted automatically.</p>
<h2 id="the-rules-for-rollback-safe-code"><a class="header" href="#the-rules-for-rollback-safe-code">The Rules for Rollback-Safe Code</a></h2>
<h3 id="rule-1-all-state-in-wasm-memory"><a class="header" href="#rule-1-all-state-in-wasm-memory">Rule 1: All State in WASM Memory</a></h3>
<p>✅ <strong>Good</strong> - State in static variables:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PLAYER_X: f32 = 0.0;
static mut SCORE: u32 = 0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float player_x = 0.0f;
static uint32_t score = 0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var player_x: f32 = 0.0;
var score: u32 = 0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>❌ <strong>Bad</strong> - State outside WASM (if this were possible):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Don't try to use external state!
// (Rust's no_std prevents most of this anyway)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Don't try to use external state!
// All state must be in static variables
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Don't try to use external state!
// All state must be in global variables
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="rule-2-deterministic-update"><a class="header" href="#rule-2-deterministic-update">Rule 2: Deterministic Update</a></h3>
<p>Given the same inputs, <code>update()</code> must produce the same results.</p>
<p>✅ <strong>Good</strong> - Use <code>random()</code> for randomness:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let rand = random();  // Deterministic, seeded by runtime
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t rand = random_u32();  // Deterministic, seeded by runtime
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const rand = random_u32();  // Deterministic, seeded by runtime
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>❌ <strong>Bad</strong> - Use system time (if this were possible):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// let time = get_system_time();  // Non-deterministic!
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// uint64_t time = get_system_time();  // Non-deterministic!
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// const time = get_system_time();  // Non-deterministic!
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="rule-3-no-state-changes-in-render"><a class="header" href="#rule-3-no-state-changes-in-render">Rule 3: No State Changes in Render</a></h3>
<p>The <code>render()</code> function is <strong>skipped during rollback</strong>. Never modify game state there.</p>
<p>✅ <strong>Good</strong>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Only READ state
    draw_rect(BALL_X, BALL_Y, ...);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Only READ state
    draw_rect(ball_x, ball_y, ...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Only READ state
    draw_rect(ball_x, ball_y, ...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>❌ <strong>Bad</strong>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    ANIMATION_FRAME += 1;  // This won't replay during rollback!
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    animation_frame += 1;  // This won't replay during rollback!
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    animation_frame += 1;  // This won't replay during rollback!
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="our-paddle-game-follows-the-rules"><a class="header" href="#our-paddle-game-follows-the-rules">Our Paddle Game Follows the Rules</a></h2>
<p>Let’s verify our code is rollback-safe:</p>
<h3 id="-all-state-in-statics"><a class="header" href="#-all-state-in-statics">✅ All State in Statics</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PADDLE1_Y: f32 = 0.0;
static mut PADDLE2_Y: f32 = 0.0;
static mut BALL_X: f32 = 0.0;
static mut BALL_Y: f32 = 0.0;
static mut BALL_VX: f32 = 0.0;
static mut BALL_VY: f32 = 0.0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float paddle1_y = 0.0f;
static float paddle2_y = 0.0f;
static float ball_x = 0.0f;
static float ball_y = 0.0f;
static float ball_vx = 0.0f;
static float ball_vy = 0.0f;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var paddle1_y: f32 = 0.0;
var paddle2_y: f32 = 0.0;
var ball_x: f32 = 0.0;
var ball_y: f32 = 0.0;
var ball_vx: f32 = 0.0;
var ball_vy: f32 = 0.0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="-deterministic-randomness"><a class="header" href="#-deterministic-randomness">✅ Deterministic Randomness</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset_ball(direction: i32) {
    let rand = random() % 100;  // Uses runtime's seeded RNG
    // ...
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void reset_ball(int32_t direction) {
    uint32_t rand = random_u32() % 100;  // Uses runtime's seeded RNG
    // ...
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn reset_ball(direction: i32) void {
    const rand = random_u32() % 100;  // Uses runtime's seeded RNG
    // ...
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="-update-reads-input-render-just-draws"><a class="header" href="#-update-reads-input-render-just-draws">✅ Update Reads Input, Render Just Draws</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Read input
    let stick_y = left_stick_y(player);
    // Modify state
    PADDLE1_Y += movement;
}

fn render() {
    // Only draw, never modify state
    draw_rect(PADDLE_MARGIN, PADDLE1_Y, ...);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // Read input
    int8_t stick_y = left_stick_y(player);
    // Modify state
    paddle1_y += movement;
}

EWZX_EXPORT void render(void) {
    // Only draw, never modify state
    draw_rect(PADDLE_MARGIN, paddle1_y, ...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Read input
    const stick_y = left_stick_y(player);
    // Modify state
    paddle1_y += movement;
}

export fn render() void {
    // Only draw, never modify state
    draw_rect(PADDLE_MARGIN, paddle1_y, ...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="testing-multiplayer-locally"><a class="header" href="#testing-multiplayer-locally">Testing Multiplayer Locally</a></h2>
<p>To test multiplayer on your local machine:</p>
<ol>
<li>Start the game</li>
<li>Connect a second controller</li>
<li>Both players can play!</li>
</ol>
<p>The <code>player_count()</code> function automatically detects connected players.</p>
<h2 id="testing-online-multiplayer"><a class="header" href="#testing-online-multiplayer">Testing Online Multiplayer</a></h2>
<p>Online play is handled by the Nethercore runtime:</p>
<ol>
<li>Player 1 hosts a game</li>
<li>Player 2 joins via game code or direct connect</li>
<li>The runtime handles all networking</li>
<li>Your game code doesn’t change at all!</li>
</ol>
<h2 id="what-rollback-looks-like"><a class="header" href="#what-rollback-looks-like">What Rollback Looks Like</a></h2>
<p>During normal play:</p>
<pre><code>You press A → Your game shows jump immediately
               (predicting remote player holds same buttons)

50ms later → Remote input arrives, matches prediction
             Nothing changes, smooth gameplay!
</code></pre>
<p>When prediction is wrong:</p>
<pre><code>You press A → Your game shows jump immediately
               (predicting remote player holds same buttons)

50ms later → Remote input arrives: they pressed B!
             Game rolls back to frame N-3
             Replays frames N-3, N-2, N-1 with correct input
             Catches up to present frame N
             Visual "correction" happens in ~1-2 frames
</code></pre>
<p>With good connections, predictions are usually correct and rollbacks are rare.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Traditional Netcode</th><th>Nethercore Rollback</th></tr>
</thead>
<tbody>
<tr><td>Wait for input → lag</td><td>Predict input → smooth</td></tr>
<tr><td>Manual state sync</td><td>Automatic snapshots</td></tr>
<tr><td>You write network code</td><td>You write game code</td></tr>
<tr><td>State can be anywhere</td><td>State must be in WASM</td></tr>
</tbody>
</table>
</div>
<p>The key insight: <strong>Nethercore handles multiplayer complexity so you can focus on making your game fun.</strong></p>
<hr>
<p><strong>Next:</strong> <a href="#part-6-scoring--win-states">Part 6: Scoring &amp; Win States</a> - Add scoring and game flow.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-6-scoring--win-states"><a class="header" href="#part-6-scoring--win-states">Part 6: Scoring &amp; Win States</a></h1>
<p>Let’s add proper scoring, win conditions, and a game state machine.</p>
<h2 id="what-youll-learn-6"><a class="header" href="#what-youll-learn-6">What You’ll Learn</a></h2>
<ul>
<li>Game state machines (Title, Playing, GameOver)</li>
<li>Tracking and displaying scores</li>
<li>Win conditions</li>
<li>Using <code>button_pressed()</code> for menu navigation</li>
</ul>
<h2 id="add-game-state"><a class="header" href="#add-game-state">Add Game State</a></h2>
<p>Create a state enum and related variables:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Copy, PartialEq)]
enum GameState {
    Title,
    Playing,
    GameOver,
}

static mut STATE: GameState = GameState::Title;
static mut SCORE1: u32 = 0;
static mut SCORE2: u32 = 0;
static mut WINNER: u32 = 0;  // 1 or 2

const WIN_SCORE: u32 = 5;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">typedef enum {
    TITLE,
    PLAYING,
    GAME_OVER
} GameState;

static GameState state = TITLE;
static uint32_t score1 = 0;
static uint32_t score2 = 0;
static uint32_t winner = 0;  // 1 or 2

#define WIN_SCORE 5
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const GameState = enum {
    title,
    playing,
    game_over,
};

var state: GameState = .title;
var score1: u32 = 0;
var score2: u32 = 0;
var winner: u32 = 0;  // 1 or 2

const WIN_SCORE: u32 = 5;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="add-button-constants"><a class="header" href="#add-button-constants">Add Button Constants</a></h2>
<p>We need the A button for starting/restarting:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BUTTON_A: u32 = 4;
<span class="boring">}</span></code></pre>
<p>Add to FFI imports:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn button_pressed(player: u32, button: u32) -&gt; u32;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define EWZX_BUTTON_A 4
</code></pre>
<p>Add to FFI imports:</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t button_pressed(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const Button = struct {
    pub const a: u32 = 4;
};
</code></pre>
<p>Add to FFI imports:</p>
<pre><code class="language-zig">pub extern fn button_pressed(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="reset-game-function"><a class="header" href="#reset-game-function">Reset Game Function</a></h2>
<p>Create a function to reset the entire game:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn reset_game() {
    unsafe {
        // Reset paddles
        PADDLE1_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
        PADDLE2_Y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

        // Reset scores
        SCORE1 = 0;
        SCORE2 = 0;
        WINNER = 0;

        // Check player count
        IS_TWO_PLAYER = player_count() &gt;= 2;

        // Reset ball
        reset_ball(-1);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void reset_game(void) {
    // Reset paddles
    paddle1_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;
    paddle2_y = SCREEN_HEIGHT / 2.0f - PADDLE_HEIGHT / 2.0f;

    // Reset scores
    score1 = 0;
    score2 = 0;
    winner = 0;

    // Check player count
    is_two_player = player_count() &gt;= 2;

    // Reset ball
    reset_ball(-1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn resetGame() void {
    // Reset paddles
    paddle1_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;
    paddle2_y = SCREEN_HEIGHT / 2.0 - PADDLE_HEIGHT / 2.0;

    // Reset scores
    score1 = 0;
    score2 = 0;
    winner = 0;

    // Check player count
    is_two_player = player_count() &gt;= 2;

    // Reset ball
    resetBall(-1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="update-scoring-logic"><a class="header" href="#update-scoring-logic">Update Scoring Logic</a></h2>
<p>Modify the ball update to handle scoring:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update_ball() {
    unsafe {
        // ... existing movement and collision code ...

        // Ball goes off left side - Player 2 scores
        if BALL_X &lt; -BALL_SIZE {
            SCORE2 += 1;

            if SCORE2 &gt;= WIN_SCORE {
                WINNER = 2;
                STATE = GameState::GameOver;
            } else {
                reset_ball(-1);  // Serve toward player 1
            }
        }

        // Ball goes off right side - Player 1 scores
        if BALL_X &gt; SCREEN_WIDTH {
            SCORE1 += 1;

            if SCORE1 &gt;= WIN_SCORE {
                WINNER = 1;
                STATE = GameState::GameOver;
            } else {
                reset_ball(1);  // Serve toward player 2
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void update_ball(void) {
    // ... existing movement and collision code ...

    // Ball goes off left side - Player 2 scores
    if (ball_x &lt; -BALL_SIZE) {
        score2++;

        if (score2 &gt;= WIN_SCORE) {
            winner = 2;
            state = GAME_OVER;
        } else {
            reset_ball(-1);  // Serve toward player 1
        }
    }

    // Ball goes off right side - Player 1 scores
    if (ball_x &gt; SCREEN_WIDTH) {
        score1++;

        if (score1 &gt;= WIN_SCORE) {
            winner = 1;
            state = GAME_OVER;
        } else {
            reset_ball(1);  // Serve toward player 2
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn updateBall() void {
    // ... existing movement and collision code ...

    // Ball goes off left side - Player 2 scores
    if (ball_x &lt; -BALL_SIZE) {
        score2 += 1;

        if (score2 &gt;= WIN_SCORE) {
            winner = 2;
            state = .game_over;
        } else {
            resetBall(-1);  // Serve toward player 1
        }
    }

    // Ball goes off right side - Player 1 scores
    if (ball_x &gt; SCREEN_WIDTH) {
        score1 += 1;

        if (score1 &gt;= WIN_SCORE) {
            winner = 1;
            state = .game_over;
        } else {
            resetBall(1);  // Serve toward player 2
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="state-machine-in-update"><a class="header" href="#state-machine-in-update">State Machine in Update</a></h2>
<p>Restructure <code>update()</code> to handle game states:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        // Always check player count
        IS_TWO_PLAYER = player_count() &gt;= 2;

        match STATE {
            GameState::Title =&gt; {
                // Press A to start
                if button_pressed(0, BUTTON_A) != 0 {
                    reset_game();
                    STATE = GameState::Playing;
                }
            }

            GameState::Playing =&gt; {
                // Normal gameplay
                update_paddle(&amp;mut PADDLE1_Y, 0);

                if IS_TWO_PLAYER {
                    update_paddle(&amp;mut PADDLE2_Y, 1);
                } else {
                    update_ai(&amp;mut PADDLE2_Y);
                }

                update_ball();
            }

            GameState::GameOver =&gt; {
                // Press A to restart
                if button_pressed(0, BUTTON_A) != 0 || button_pressed(1, BUTTON_A) != 0 {
                    reset_game();
                    STATE = GameState::Playing;
                }
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // Always check player count
    is_two_player = player_count() &gt;= 2;

    switch (state) {
        case TITLE:
            // Press A to start
            if (button_pressed(0, EWZX_BUTTON_A) != 0) {
                reset_game();
                state = PLAYING;
            }
            break;

        case PLAYING:
            // Normal gameplay
            update_paddle(&amp;paddle1_y, 0);

            if (is_two_player) {
                update_paddle(&amp;paddle2_y, 1);
            } else {
                update_ai(&amp;paddle2_y);
            }

            update_ball();
            break;

        case GAME_OVER:
            // Press A to restart
            if (button_pressed(0, EWZX_BUTTON_A) != 0 || button_pressed(1, EWZX_BUTTON_A) != 0) {
                reset_game();
                state = PLAYING;
            }
            break;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Always check player count
    is_two_player = player_count() &gt;= 2;

    switch (state) {
        .title =&gt; {
            // Press A to start
            if (button_pressed(0, Button.a) != 0) {
                resetGame();
                state = .playing;
            }
        },

        .playing =&gt; {
            // Normal gameplay
            updatePaddle(&amp;paddle1_y, 0);

            if (is_two_player) {
                updatePaddle(&amp;paddle2_y, 1);
            } else {
                updateAi(&amp;paddle2_y);
            }

            updateBall();
        },

        .game_over =&gt; {
            // Press A to restart
            if (button_pressed(0, Button.a) != 0 or button_pressed(1, Button.a) != 0) {
                resetGame();
                state = .playing;
            }
        },
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="update-init"><a class="header" href="#update-init">Update Init</a></h2>
<p>Start on title screen:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);
        reset_game();
        STATE = GameState::Title;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF);
    reset_game();
    state = TITLE;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_clear_color(0x1a1a2eFF);
    resetGame();
    state = .title;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="render-scores"><a class="header" href="#render-scores">Render Scores</a></h2>
<p>Add a helper for drawing text:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_text_bytes(text: &amp;[u8], x: f32, y: f32, size: f32, color: u32) {
    unsafe {
        draw_text(text.as_ptr(), text.len() as u32, x, y, size, color);
    }
}
<span class="boring">}</span></code></pre>
<p>Add score display in render:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render_scores() {
    unsafe {
        // Convert scores to single digits
        let score1_char = b'0' + (SCORE1 % 10) as u8;
        let score2_char = b'0' + (SCORE2 % 10) as u8;

        // Draw scores
        draw_text(&amp;[score1_char], 1, SCREEN_WIDTH / 4.0, 30.0, 48.0, COLOR_PLAYER1);
        draw_text(&amp;[score2_char], 1, SCREEN_WIDTH * 3.0 / 4.0, 30.0, 48.0, COLOR_PLAYER2);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void draw_text_bytes(const uint8_t* text, uint32_t len, float x, float y, float size, uint32_t color) {
    draw_text(text, len, x, y, size, color);
}
</code></pre>
<p>Add score display in render:</p>
<pre><code class="language-c">void render_scores(void) {
    // Convert scores to single digits
    uint8_t score1_char = '0' + (score1 % 10);
    uint8_t score2_char = '0' + (score2 % 10);

    // Draw scores
    draw_text(&amp;score1_char, 1, SCREEN_WIDTH / 4.0f, 30.0f, 48.0f, COLOR_PLAYER1);
    draw_text(&amp;score2_char, 1, SCREEN_WIDTH * 3.0f / 4.0f, 30.0f, 48.0f, COLOR_PLAYER2);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn drawTextBytes(text: []const u8, x: f32, y: f32, size: f32, color: u32) void {
    draw_text(text.ptr, @intCast(text.len), x, y, size, color);
}
</code></pre>
<p>Add score display in render:</p>
<pre><code class="language-zig">fn renderScores() void {
    // Convert scores to single digits
    const score1_char = '0' + @as(u8, @intCast(score1 % 10));
    const score2_char = '0' + @as(u8, @intCast(score2 % 10));

    // Draw scores
    draw_text(&amp;score1_char, 1, SCREEN_WIDTH / 4.0, 30.0, 48.0, COLOR_PLAYER1);
    draw_text(&amp;score2_char, 1, SCREEN_WIDTH * 3.0 / 4.0, 30.0, 48.0, COLOR_PLAYER2);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="render-states"><a class="header" href="#render-states">Render States</a></h2>
<p>Update <code>render()</code> to show different screens:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        match STATE {
            GameState::Title =&gt; {
                render_court();
                render_title();
            }

            GameState::Playing =&gt; {
                render_court();
                render_scores();
                render_paddles();
                render_ball();
                render_mode_indicator();
            }

            GameState::GameOver =&gt; {
                render_court();
                render_scores();
                render_paddles();
                render_ball();
                render_game_over();
            }
        }
    }
}

fn render_title() {
    unsafe {
        draw_text_bytes(b"PADDLE", SCREEN_WIDTH / 2.0 - 100.0, 150.0, 64.0, COLOR_WHITE);

        if IS_TWO_PLAYER {
            draw_text_bytes(b"2 PLAYER MODE", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
        } else {
            draw_text_bytes(b"1 PLAYER VS AI", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
        }

        draw_text_bytes(b"Press A to Start", SCREEN_WIDTH / 2.0 - 120.0, 350.0, 24.0, COLOR_GRAY);
    }
}

fn render_game_over() {
    unsafe {
        // Dark overlay
        draw_rect(SCREEN_WIDTH / 4.0, SCREEN_HEIGHT / 3.0,
                  SCREEN_WIDTH / 2.0, SCREEN_HEIGHT / 3.0, 0x000000CC);

        // Winner text
        let (text, color) = if WINNER == 1 {
            (b"PLAYER 1 WINS!" as &amp;[u8], COLOR_PLAYER1)
        } else if IS_TWO_PLAYER {
            (b"PLAYER 2 WINS!" as &amp;[u8], COLOR_PLAYER2)
        } else {
            (b"AI WINS!" as &amp;[u8], COLOR_PLAYER2)
        };

        draw_text(text.as_ptr(), text.len() as u32,
                  SCREEN_WIDTH / 2.0 - 120.0, SCREEN_HEIGHT / 2.0 - 20.0, 32.0, color);

        draw_text_bytes(b"Press A to Play Again",
                       SCREEN_WIDTH / 2.0 - 140.0, SCREEN_HEIGHT / 2.0 + 30.0, 20.0, COLOR_GRAY);
    }
}

fn render_mode_indicator() {
    unsafe {
        if IS_TWO_PLAYER {
            draw_text_bytes(b"2P", 10.0, 10.0, 16.0, COLOR_GRAY);
        } else {
            draw_text_bytes(b"vs AI", 10.0, 10.0, 16.0, COLOR_GRAY);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    switch (state) {
        case TITLE:
            render_court();
            render_title();
            break;

        case PLAYING:
            render_court();
            render_scores();
            render_paddles();
            render_ball();
            render_mode_indicator();
            break;

        case GAME_OVER:
            render_court();
            render_scores();
            render_paddles();
            render_ball();
            render_game_over();
            break;
    }
}

void render_title(void) {
    draw_text_bytes((const uint8_t*)"PADDLE", 6, SCREEN_WIDTH / 2.0f - 100.0f, 150.0f, 64.0f, COLOR_WHITE);

    if (is_two_player) {
        draw_text_bytes((const uint8_t*)"2 PLAYER MODE", 13, SCREEN_WIDTH / 2.0f - 100.0f, 250.0f, 24.0f, COLOR_WHITE);
    } else {
        draw_text_bytes((const uint8_t*)"1 PLAYER VS AI", 14, SCREEN_WIDTH / 2.0f - 100.0f, 250.0f, 24.0f, COLOR_WHITE);
    }

    draw_text_bytes((const uint8_t*)"Press A to Start", 16, SCREEN_WIDTH / 2.0f - 120.0f, 350.0f, 24.0f, COLOR_GRAY);
}

void render_game_over(void) {
    // Dark overlay
    draw_rect(SCREEN_WIDTH / 4.0f, SCREEN_HEIGHT / 3.0f,
              SCREEN_WIDTH / 2.0f, SCREEN_HEIGHT / 3.0f, 0x000000CC);

    // Winner text
    const uint8_t* text;
    uint32_t text_len;
    uint32_t color;

    if (winner == 1) {
        text = (const uint8_t*)"PLAYER 1 WINS!";
        text_len = 14;
        color = COLOR_PLAYER1;
    } else if (is_two_player) {
        text = (const uint8_t*)"PLAYER 2 WINS!";
        text_len = 14;
        color = COLOR_PLAYER2;
    } else {
        text = (const uint8_t*)"AI WINS!";
        text_len = 8;
        color = COLOR_PLAYER2;
    }

    draw_text(text, text_len,
              SCREEN_WIDTH / 2.0f - 120.0f, SCREEN_HEIGHT / 2.0f - 20.0f, 32.0f, color);

    draw_text_bytes((const uint8_t*)"Press A to Play Again", 21,
                   SCREEN_WIDTH / 2.0f - 140.0f, SCREEN_HEIGHT / 2.0f + 30.0f, 20.0f, COLOR_GRAY);
}

void render_mode_indicator(void) {
    if (is_two_player) {
        draw_text_bytes((const uint8_t*)"2P", 2, 10.0f, 10.0f, 16.0f, COLOR_GRAY);
    } else {
        draw_text_bytes((const uint8_t*)"vs AI", 5, 10.0f, 10.0f, 16.0f, COLOR_GRAY);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    switch (state) {
        .title =&gt; {
            renderCourt();
            renderTitle();
        },

        .playing =&gt; {
            renderCourt();
            renderScores();
            renderPaddles();
            renderBall();
            renderModeIndicator();
        },

        .game_over =&gt; {
            renderCourt();
            renderScores();
            renderPaddles();
            renderBall();
            renderGameOver();
        },
    }
}

fn renderTitle() void {
    drawTextBytes("PADDLE", SCREEN_WIDTH / 2.0 - 100.0, 150.0, 64.0, COLOR_WHITE);

    if (is_two_player) {
        drawTextBytes("2 PLAYER MODE", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    } else {
        drawTextBytes("1 PLAYER VS AI", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    }

    drawTextBytes("Press A to Start", SCREEN_WIDTH / 2.0 - 120.0, 350.0, 24.0, COLOR_GRAY);
}

fn renderGameOver() void {
    // Dark overlay
    draw_rect(SCREEN_WIDTH / 4.0, SCREEN_HEIGHT / 3.0,
              SCREEN_WIDTH / 2.0, SCREEN_HEIGHT / 3.0, 0x000000CC);

    // Winner text
    const text: []const u8 = if (winner == 1)
        "PLAYER 1 WINS!"
    else if (is_two_player)
        "PLAYER 2 WINS!"
    else
        "AI WINS!";

    const color: u32 = if (winner == 1) COLOR_PLAYER1 else COLOR_PLAYER2;

    draw_text(text.ptr, @intCast(text.len),
              SCREEN_WIDTH / 2.0 - 120.0, SCREEN_HEIGHT / 2.0 - 20.0, 32.0, color);

    drawTextBytes("Press A to Play Again",
                 SCREEN_WIDTH / 2.0 - 140.0, SCREEN_HEIGHT / 2.0 + 30.0, 20.0, COLOR_GRAY);
}

fn renderModeIndicator() void {
    if (is_two_player) {
        drawTextBytes("2P", 10.0, 10.0, 16.0, COLOR_GRAY);
    } else {
        drawTextBytes("vs AI", 10.0, 10.0, 16.0, COLOR_GRAY);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="build-and-test-4"><a class="header" href="#build-and-test-4">Build and Test</a></h2>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>The game now has:</p>
<ul>
<li>Title screen with mode indicator</li>
<li>Score display during play</li>
<li>Game over screen with winner</li>
<li>Press A to start or restart</li>
<li>First to 5 points wins</li>
</ul>
<hr>
<p><strong>Next:</strong> <a href="#part-7-sound-effects">Part 7: Sound Effects</a> - Add audio feedback.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-7-sound-effects"><a class="header" href="#part-7-sound-effects">Part 7: Sound Effects</a></h1>
<p>Games feel incomplete without audio. So far we’ve been using <code>draw_rect()</code> for everything—but you can’t draw a sound! This is where Nethercore’s asset pipeline comes in.</p>
<h2 id="what-youll-learn-7"><a class="header" href="#what-youll-learn-7">What You’ll Learn</a></h2>
<ul>
<li>Setting up an assets folder</li>
<li>Creating <code>nether.toml</code> to bundle assets</li>
<li>Using <code>nether build</code> instead of <code>cargo build</code></li>
<li>Loading sounds with <code>rom_sound()</code></li>
<li>Playing sounds with <code>play_sound()</code> and stereo panning</li>
</ul>
<h2 id="why-assets-now"><a class="header" href="#why-assets-now">Why Assets Now?</a></h2>
<p>Up until now, we’ve built and tested like this:</p>
<pre><code class="language-bash">cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>This works great for graphics—<code>draw_rect()</code> handles everything. But sounds need actual audio files. That’s where <code>nether build</code> comes in: it bundles your code <em>and</em> assets into a single ROM file.</p>
<h2 id="create-the-assets-folder"><a class="header" href="#create-the-assets-folder">Create the Assets Folder</a></h2>
<p>Create an <code>assets/</code> folder in your project:</p>
<pre><code class="language-bash">mkdir assets
</code></pre>
<h2 id="get-sound-files"><a class="header" href="#get-sound-files">Get Sound Files</a></h2>
<p>You need three WAV files for the game:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Sound</th><th>Description</th><th>Duration</th></tr>
</thead>
<tbody>
<tr><td><code>hit.wav</code></td><td>Quick beep for paddle/wall hits</td><td>~0.1s</td></tr>
<tr><td><code>score.wav</code></td><td>Descending tone when someone scores</td><td>~0.2s</td></tr>
<tr><td><code>win.wav</code></td><td>Victory fanfare when game ends</td><td>~0.5s</td></tr>
</tbody>
</table>
</div>
<p><strong>Download sample sounds</strong> from the <a href="https://github.com/nethercore-systems/nethercore/tree/main/docs/book/src/tutorials/paddle/assets">tutorial assets</a>, or create your own with:</p>
<ul>
<li><a href="https://sfxr.me">JSFXR</a> — Generate retro sound effects in your browser</li>
<li><a href="https://freesound.org">Freesound.org</a> — CC-licensed sounds</li>
<li><a href="https://www.audacityteam.org">Audacity</a> — Record and edit audio</li>
</ul>
<p>Put them in your <code>assets/</code> folder:</p>
<pre><code>paddle/
├── Cargo.toml
├── nether.toml          ← We'll create this next
├── assets/
│   ├── hit.wav
│   ├── score.wav
│   └── win.wav
└── src/
    └── lib.rs
</code></pre>
<h2 id="create-nethertoml"><a class="header" href="#create-nethertoml">Create nether.toml</a></h2>
<p>Create <code>nether.toml</code> in your project root. This manifest tells Nethercore about your game and its assets:</p>
<pre><code class="language-toml">[game]
id = "paddle"
title = "Paddle"
author = "Your Name"
version = "0.1.0"

# Sound assets
[[assets.sounds]]
id = "hit"
path = "assets/hit.wav"

[[assets.sounds]]
id = "score"
path = "assets/score.wav"

[[assets.sounds]]
id = "win"
path = "assets/win.wav"
</code></pre>
<p>Each asset has:</p>
<ul>
<li><strong>id</strong> — The name you’ll use to load it in code</li>
<li><strong>path</strong> — File location relative to <code>nether.toml</code></li>
</ul>
<h2 id="build-with-nether-build"><a class="header" href="#build-with-nether-build">Build with nether build</a></h2>
<p>Now use <code>nether build</code> instead of <code>cargo build</code>:</p>
<pre><code class="language-bash">nether build
</code></pre>
<p>This command:</p>
<ol>
<li>Compiles your Rust code to WASM</li>
<li>Converts WAV files to the optimized format (22050 Hz mono)</li>
<li>Bundles everything into a <code>paddle.nczx</code> ROM file</li>
</ol>
<p>You’ll see output like:</p>
<pre><code>Building paddle...
  Compiling paddle v0.1.0
  Converting hit.wav → hit.ewzsnd
  Converting score.wav → score.ewzsnd
  Converting win.wav → win.ewzsnd
  Packing paddle.nczx (28 KB)
Done!
</code></pre>
<h2 id="run-your-game"><a class="header" href="#run-your-game">Run Your Game</a></h2>
<p>Now run the ROM:</p>
<pre><code class="language-bash">nether run paddle.nczx
</code></pre>
<p>Or just:</p>
<pre><code class="language-bash">nether run
</code></pre>
<p>This builds and runs in one step.</p>
<h2 id="add-audio-ffi"><a class="header" href="#add-audio-ffi">Add Audio FFI</a></h2>
<p>Add the audio functions to your FFI imports:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...

    // ROM loading
    fn rom_sound(id_ptr: *const u8, id_len: u32) -&gt; u32;

    // Audio playback
    fn play_sound(sound: u32, volume: f32, pan: f32);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// ROM loading
EWZX_IMPORT uint32_t rom_sound(const uint8_t* id_ptr, uint32_t id_len);

// Audio playback
EWZX_IMPORT void play_sound(uint32_t sound, float volume, float pan);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// ROM loading
pub extern fn rom_sound(id_ptr: [*]const u8, id_len: u32) u32;

// Audio playback
pub extern fn play_sound(sound: u32, volume: f32, pan: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="sound-handles"><a class="header" href="#sound-handles">Sound Handles</a></h2>
<p>Add static variables to store sound handles:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SFX_HIT: u32 = 0;
static mut SFX_SCORE: u32 = 0;
static mut SFX_WIN: u32 = 0;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t SFX_HIT = 0;
static uint32_t SFX_SCORE = 0;
static uint32_t SFX_WIN = 0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var SFX_HIT: u32 = 0;
var SFX_SCORE: u32 = 0;
var SFX_WIN: u32 = 0;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="load-sounds-in-init"><a class="header" href="#load-sounds-in-init">Load Sounds in init()</a></h2>
<p>Update <code>init()</code> to load sounds from the ROM:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        set_clear_color(0x1a1a2eFF);

        // Load sounds from ROM
        SFX_HIT = rom_sound(b"hit".as_ptr(), 3);
        SFX_SCORE = rom_sound(b"score".as_ptr(), 5);
        SFX_WIN = rom_sound(b"win".as_ptr(), 3);

        reset_game();
        STATE = GameState::Title;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void init() {
    set_clear_color(0x1a1a2eFF);

    // Load sounds from ROM
    SFX_HIT = rom_sound("hit", 3);
    SFX_SCORE = rom_sound("score", 5);
    SFX_WIN = rom_sound("win", 3);

    reset_game();
    STATE = TITLE;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_clear_color(0x1a1a2eFF);

    // Load sounds from ROM
    SFX_HIT = rom_sound("hit", 3);
    SFX_SCORE = rom_sound("score", 5);
    SFX_WIN = rom_sound("win", 3);

    reset_game();
    STATE = .Title;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>The <code>rom_sound()</code> function loads the sound directly from the bundled ROM—the string IDs match what you put in <code>nether.toml</code>.</p>
<h2 id="play-sounds"><a class="header" href="#play-sounds">Play Sounds</a></h2>
<p>Now add sound effects to game events:</p>
<h3 id="wall-bounce"><a class="header" href="#wall-bounce">Wall Bounce</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In update_ball(), after wall bounce:
if BALL_Y &lt;= 0.0 {
    BALL_Y = 0.0;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3, 0.0);  // Center pan
}

if BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE {
    BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3, 0.0);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// In update_ball(), after wall bounce:
if (BALL_Y &lt;= 0.0f) {
    BALL_Y = 0.0f;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3f, 0.0f);  // Center pan
}

if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
    BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3f, 0.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// In update_ball(), after wall bounce:
if (BALL_Y &lt;= 0.0) {
    BALL_Y = 0.0;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3, 0.0);  // Center pan
}

if (BALL_Y &gt;= SCREEN_HEIGHT - BALL_SIZE) {
    BALL_Y = SCREEN_HEIGHT - BALL_SIZE;
    BALL_VY = -BALL_VY;
    play_sound(SFX_HIT, 0.3, 0.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="paddle-hit"><a class="header" href="#paddle-hit">Paddle Hit</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// In paddle 1 collision:
play_sound(SFX_HIT, 0.5, -0.5);  // Pan left

// In paddle 2 collision:
play_sound(SFX_HIT, 0.5, 0.5);   // Pan right
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// In paddle 1 collision:
play_sound(SFX_HIT, 0.5f, -0.5f);  // Pan left

// In paddle 2 collision:
play_sound(SFX_HIT, 0.5f, 0.5f);   // Pan right
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// In paddle 1 collision:
play_sound(SFX_HIT, 0.5, -0.5);  // Pan left

// In paddle 2 collision:
play_sound(SFX_HIT, 0.5, 0.5);   // Pan right
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="scoring"><a class="header" href="#scoring">Scoring</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When player 2 scores (ball exits left):
SCORE2 += 1;
play_sound(SFX_SCORE, 0.6, 0.5);  // Pan right (scorer's side)

// When player 1 scores (ball exits right):
SCORE1 += 1;
play_sound(SFX_SCORE, 0.6, -0.5);  // Pan left (scorer's side)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// When player 2 scores (ball exits left):
SCORE2 += 1;
play_sound(SFX_SCORE, 0.6f, 0.5f);  // Pan right (scorer's side)

// When player 1 scores (ball exits right):
SCORE1 += 1;
play_sound(SFX_SCORE, 0.6f, -0.5f);  // Pan left (scorer's side)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// When player 2 scores (ball exits left):
SCORE2 += 1;
play_sound(SFX_SCORE, 0.6, 0.5);  // Pan right (scorer's side)

// When player 1 scores (ball exits right):
SCORE1 += 1;
play_sound(SFX_SCORE, 0.6, -0.5);  // Pan left (scorer's side)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="win"><a class="header" href="#win">Win</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// When either player wins:
if SCORE1 &gt;= WIN_SCORE || SCORE2 &gt;= WIN_SCORE {
    STATE = GameState::GameOver;
    play_sound(SFX_WIN, 0.8, 0.0);  // Center, louder
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// When either player wins:
if (SCORE1 &gt;= WIN_SCORE || SCORE2 &gt;= WIN_SCORE) {
    STATE = GAME_OVER;
    play_sound(SFX_WIN, 0.8f, 0.0f);  // Center, louder
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// When either player wins:
if (SCORE1 &gt;= WIN_SCORE or SCORE2 &gt;= WIN_SCORE) {
    STATE = .GameOver;
    play_sound(SFX_WIN, 0.8, 0.0);  // Center, louder
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="understanding-play_sound"><a class="header" href="#understanding-play_sound">Understanding play_sound()</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_sound(sound: u32, volume: f32, pan: f32);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void play_sound(uint32_t sound, float volume, float pan);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn play_sound(sound: u32, volume: f32, pan: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Parameter</th><th>Range</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><code>sound</code></td><td>Handle</td><td>Sound handle from <code>rom_sound()</code></td></tr>
<tr><td><code>volume</code></td><td>0.0 - 1.0</td><td>0 = silent, 1 = full volume</td></tr>
<tr><td><code>pan</code></td><td>-1.0 - 1.0</td><td>-1 = left, 0 = center, 1 = right</td></tr>
</tbody>
</table>
</div>
<h2 id="audio-specs"><a class="header" href="#audio-specs">Audio Specs</a></h2>
<p>Nethercore uses these audio settings:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Property</th><th>Value</th></tr>
</thead>
<tbody>
<tr><td>Sample rate</td><td>22050 Hz</td></tr>
<tr><td>Format</td><td>16-bit mono PCM</td></tr>
<tr><td>Channels</td><td>Stereo output</td></tr>
</tbody>
</table>
</div>
<p>The <code>nether build</code> command automatically converts your WAV files to this format.</p>
<h2 id="sound-design-tips"><a class="header" href="#sound-design-tips">Sound Design Tips</a></h2>
<ol>
<li><strong>Keep sounds short</strong> — 0.1 to 0.5 seconds is plenty for effects</li>
<li><strong>Use panning</strong> — Stereo positioning helps players track action</li>
<li><strong>Vary volume</strong> — Important sounds louder, ambient sounds quieter</li>
<li><strong>Match your aesthetic</strong> — Simple sounds fit retro games</li>
</ol>
<h2 id="build-and-test-5"><a class="header" href="#build-and-test-5">Build and Test</a></h2>
<p>Rebuild with your sound assets:</p>
<pre><code class="language-bash">nether build
nether run
</code></pre>
<p>The game now has:</p>
<ul>
<li>“Ping” sound when ball hits walls or paddles</li>
<li>Different panning for left/right paddle hits</li>
<li>Descending “whomp” when someone scores</li>
<li>Victory fanfare when a player wins</li>
</ul>
<h2 id="bonus-sprite-graphics"><a class="header" href="#bonus-sprite-graphics">Bonus: Sprite Graphics</a></h2>
<p>Now that we have the asset pipeline set up, we can also use image sprites instead of <code>draw_rect()</code>. This is optional—the game works fine with rectangles—but sprites look nicer!</p>
<h3 id="add-texture-assets"><a class="header" href="#add-texture-assets">Add Texture Assets</a></h3>
<p>Download <code>paddle.png</code> and <code>ball.png</code> from the <a href="https://github.com/nethercore-systems/nethercore/tree/main/docs/book/src/tutorials/paddle/assets">tutorial assets</a>, then add them to <code>nether.toml</code>:</p>
<pre><code class="language-toml"># Texture assets
[[assets.textures]]
id = "paddle"
path = "assets/paddle.png"

[[assets.textures]]
id = "ball"
path = "assets/ball.png"
</code></pre>
<h3 id="add-texture-ffi"><a class="header" href="#add-texture-ffi">Add Texture FFI</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...

    // Texture loading and drawing
    fn rom_texture(id_ptr: *const u8, id_len: u32) -&gt; u32;
    fn texture_bind(texture: u32);
    fn draw_sprite(x: f32, y: f32, w: f32, h: f32);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Texture loading and drawing
EWZX_IMPORT uint32_t rom_texture(const uint8_t* id_ptr, uint32_t id_len);
EWZX_IMPORT void texture_bind(uint32_t texture);
EWZX_IMPORT void draw_sprite(float x, float y, float w, float h);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Texture loading and drawing
pub extern fn rom_texture(id_ptr: [*]const u8, id_len: u32) u32;
pub extern fn texture_bind(texture: u32) void;
pub extern fn draw_sprite(x: f32, y: f32, w: f32, h: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="load-textures"><a class="header" href="#load-textures">Load Textures</a></h3>
<p>Add handles and load in <code>init()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TEX_PADDLE: u32 = 0;
static mut TEX_BALL: u32 = 0;

// In init():
TEX_PADDLE = rom_texture(b"paddle".as_ptr(), 6);
TEX_BALL = rom_texture(b"ball".as_ptr(), 4);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t TEX_PADDLE = 0;
static uint32_t TEX_BALL = 0;

// In init():
TEX_PADDLE = rom_texture("paddle", 6);
TEX_BALL = rom_texture("ball", 4);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var TEX_PADDLE: u32 = 0;
var TEX_BALL: u32 = 0;

// In init():
TEX_PADDLE = rom_texture("paddle", 6);
TEX_BALL = rom_texture("ball", 4);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="draw-sprites"><a class="header" href="#draw-sprites">Draw Sprites</a></h3>
<p>Replace <code>draw_rect()</code> calls in <code>render()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Instead of: draw_rect(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
texture_bind(TEX_PADDLE);
draw_sprite(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Second paddle
draw_sprite(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, PADDLE2_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Instead of: draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
texture_bind(TEX_BALL);
draw_sprite(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Instead of: draw_rect(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
texture_bind(TEX_PADDLE);
draw_sprite(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Second paddle
draw_sprite(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, PADDLE2_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Instead of: draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
texture_bind(TEX_BALL);
draw_sprite(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Instead of: draw_rect(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT, COLOR_PLAYER1);
texture_bind(TEX_PADDLE);
draw_sprite(PADDLE_MARGIN, PADDLE1_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Second paddle
draw_sprite(SCREEN_WIDTH - PADDLE_MARGIN - PADDLE_WIDTH, PADDLE2_Y, PADDLE_WIDTH, PADDLE_HEIGHT);

// Instead of: draw_rect(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE, COLOR_WHITE);
texture_bind(TEX_BALL);
draw_sprite(BALL_X, BALL_Y, BALL_SIZE, BALL_SIZE);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>The sprite will be tinted by the bound texture. You can also use <code>draw_sprite_colored()</code> if you want to tint sprites with different colors per player.</p>
<h2 id="new-workflow-summary"><a class="header" href="#new-workflow-summary">New Workflow Summary</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Before (Parts 1-6)</th><th>Now (Part 7+)</th></tr>
</thead>
<tbody>
<tr><td><code>cargo build --target wasm32-unknown-unknown --release</code></td><td><code>nether build</code></td></tr>
<tr><td><code>nether run target/.../paddle.wasm</code></td><td><code>nether run</code></td></tr>
<tr><td>No assets needed</td><td>Assets bundled in ROM</td></tr>
</tbody>
</table>
</div>
<p>From now on, just use <code>nether build</code> and <code>nether run</code>!</p>
<hr>
<p><strong>Next:</strong> <a href="#part-8-polish--publishing">Part 8: Polish &amp; Publishing</a> — Final touches and releasing your game.</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="part-8-polish--publishing"><a class="header" href="#part-8-polish--publishing">Part 8: Polish &amp; Publishing</a></h1>
<p>Your Paddle game is complete! Let’s add some final polish and publish it to the Nethercore Archive.</p>
<h2 id="what-youll-learn-8"><a class="header" href="#what-youll-learn-8">What You’ll Learn</a></h2>
<ul>
<li>Adding control hints</li>
<li>Final nether.toml configuration</li>
<li>Building a release ROM</li>
<li>Publishing to nethercore.systems</li>
</ul>
<h2 id="add-control-hints"><a class="header" href="#add-control-hints">Add Control Hints</a></h2>
<p>Let’s add helpful text on the title screen:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render_title() {
    unsafe {
        // Title
        draw_text_bytes(b"PADDLE", SCREEN_WIDTH / 2.0 - 100.0, 150.0, 64.0, COLOR_WHITE);

        // Mode indicator
        if IS_TWO_PLAYER {
            draw_text_bytes(b"2 PLAYER MODE", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
        } else {
            draw_text_bytes(b"1 PLAYER VS AI", SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
        }

        // Start prompt
        draw_text_bytes(b"Press A to Start", SCREEN_WIDTH / 2.0 - 120.0, 350.0, 24.0, COLOR_GRAY);

        // Controls hint
        draw_text_bytes(b"Controls: Left Stick or D-Pad Up/Down",
                       250.0, 450.0, 18.0, COLOR_GRAY);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void render_title() {
    // Title
    draw_text("PADDLE", 6, SCREEN_WIDTH / 2.0 - 100.0, 150.0, 64.0, COLOR_WHITE);

    // Mode indicator
    if (IS_TWO_PLAYER) {
        draw_text("2 PLAYER MODE", 13, SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    } else {
        draw_text("1 PLAYER VS AI", 14, SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    }

    // Start prompt
    draw_text("Press A to Start", 16, SCREEN_WIDTH / 2.0 - 120.0, 350.0, 24.0, COLOR_GRAY);

    // Controls hint
    draw_text("Controls: Left Stick or D-Pad Up/Down", 38,
              250.0, 450.0, 18.0, COLOR_GRAY);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn render_title() void {
    // Title
    draw_text("PADDLE", "PADDLE".len, SCREEN_WIDTH / 2.0 - 100.0, 150.0, 64.0, COLOR_WHITE);

    // Mode indicator
    if (IS_TWO_PLAYER) {
        draw_text("2 PLAYER MODE", "2 PLAYER MODE".len, SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    } else {
        draw_text("1 PLAYER VS AI", "1 PLAYER VS AI".len, SCREEN_WIDTH / 2.0 - 100.0, 250.0, 24.0, COLOR_WHITE);
    }

    // Start prompt
    draw_text("Press A to Start", "Press A to Start".len, SCREEN_WIDTH / 2.0 - 120.0, 350.0, 24.0, COLOR_GRAY);

    // Controls hint
    draw_text("Controls: Left Stick or D-Pad Up/Down", "Controls: Left Stick or D-Pad Up/Down".len,
              250.0, 450.0, 18.0, COLOR_GRAY);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="complete-nethertoml"><a class="header" href="#complete-nethertoml">Complete nether.toml</a></h2>
<p>In <a href="#part-7-sound-effects">Part 7</a>, we created our <code>nether.toml</code>. Here’s the complete version with all metadata for publishing:</p>
<pre><code class="language-toml">[game]
id = "paddle"
title = "Paddle"
author = "Your Name"
version = "1.0.0"
description = "Classic Paddle game with AI and multiplayer support"

# Sound assets
[[assets.sounds]]
id = "hit"
path = "assets/hit.wav"

[[assets.sounds]]
id = "score"
path = "assets/score.wav"

[[assets.sounds]]
id = "win"
path = "assets/win.wav"

# Texture assets (optional - for sprite graphics)
[[assets.textures]]
id = "paddle"
path = "assets/paddle.png"

[[assets.textures]]
id = "ball"
path = "assets/ball.png"
</code></pre>
<h3 id="project-structure"><a class="header" href="#project-structure">Project Structure</a></h3>
<p>Your final project should look like:</p>
<pre><code>paddle/
├── Cargo.toml
├── nether.toml
├── assets/
│   ├── hit.wav
│   ├── score.wav
│   ├── win.wav
│   ├── paddle.png    (optional)
│   └── ball.png      (optional)
└── src/
    └── lib.rs
</code></pre>
<h2 id="build-for-release"><a class="header" href="#build-for-release">Build for Release</a></h2>
<h3 id="using-nether-build"><a class="header" href="#using-nether-build">Using nether build</a></h3>
<p>Build your game with all assets bundled:</p>
<pre><code class="language-bash">nether build
</code></pre>
<p>This creates a <code>.nczx</code> ROM file containing:</p>
<ul>
<li>Your compiled WASM code</li>
<li>All converted and compressed assets</li>
<li>Game metadata</li>
</ul>
<h3 id="verify-the-build"><a class="header" href="#verify-the-build">Verify the Build</a></h3>
<p>Check your ROM was created:</p>
<pre><code class="language-bash">ls -la *.nczx
</code></pre>
<p>You should see something like:</p>
<pre><code>-rw-r--r-- 1 user user 45678 Dec 20 12:00 paddle.nczx
</code></pre>
<h2 id="test-your-release-build"><a class="header" href="#test-your-release-build">Test Your Release Build</a></h2>
<p>Run the final ROM:</p>
<pre><code class="language-bash">nether run paddle.nczx
</code></pre>
<h2 id="final-checklist"><a class="header" href="#final-checklist">Final Checklist</a></h2>
<p>Before publishing, verify:</p>
<ul>
<li><input disabled="" type="checkbox"> Title screen displays correctly</li>
<li><input disabled="" type="checkbox"> Both players can control paddles</li>
<li><input disabled="" type="checkbox"> AI works when only one player</li>
<li><input disabled="" type="checkbox"> Ball bounces correctly off walls and paddles</li>
<li><input disabled="" type="checkbox"> Scores track correctly</li>
<li><input disabled="" type="checkbox"> Game ends at 5 points</li>
<li><input disabled="" type="checkbox"> Victory screen shows correct winner</li>
<li><input disabled="" type="checkbox"> All sound effects play with proper panning</li>
<li><input disabled="" type="checkbox"> Game restarts correctly</li>
</ul>
<h2 id="publishing-to-nethercore-archive"><a class="header" href="#publishing-to-nethercore-archive">Publishing to Nethercore Archive</a></h2>
<h3 id="1-create-an-account"><a class="header" href="#1-create-an-account">1. Create an Account</a></h3>
<p>Visit <a href="https://nethercore.systems/register">nethercore.systems/register</a> to create your developer account.</p>
<h3 id="2-prepare-assets"><a class="header" href="#2-prepare-assets">2. Prepare Assets</a></h3>
<p>You’ll need:</p>
<ul>
<li><strong>Icon</strong> (64×64 PNG) — Shows in the game library</li>
<li><strong>Screenshot(s)</strong> (optional) — Shows on your game’s page</li>
</ul>
<h3 id="3-upload-your-game"><a class="header" href="#3-upload-your-game">3. Upload Your Game</a></h3>
<ol>
<li>Log in to <a href="https://nethercore.systems">nethercore.systems</a></li>
<li>Go to your <a href="https://nethercore.systems/dashboard">Dashboard</a></li>
<li>Click “Upload New Game”</li>
<li>Fill in the details:
<ul>
<li>Title: “Paddle”</li>
<li>Description: Your game description</li>
<li>Category: Arcade</li>
</ul>
</li>
<li>Upload your <code>.nczx</code> ROM file</li>
<li>Add your icon and screenshots</li>
<li>Click “Publish”</li>
</ol>
<h3 id="4-share-your-game"><a class="header" href="#4-share-your-game">4. Share Your Game</a></h3>
<p>Once published, your game has a unique page at:</p>
<pre><code>nethercore.systems/game/paddle
</code></pre>
<p>Share this link! Anyone with the Nethercore player can play your game.</p>
<h2 id="what-youve-built"><a class="header" href="#what-youve-built">What You’ve Built</a></h2>
<p>Congratulations! Your Paddle game includes:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Feature</th><th>Implementation</th></tr>
</thead>
<tbody>
<tr><td><strong>Graphics</strong></td><td>Court, paddles, ball with <code>draw_rect()</code></td></tr>
<tr><td><strong>Input</strong></td><td>Analog stick and D-pad with <code>left_stick_y()</code>, <code>button_held()</code></td></tr>
<tr><td><strong>Physics</strong></td><td>Ball movement, wall bouncing, paddle collision</td></tr>
<tr><td><strong>AI</strong></td><td>Simple ball-following AI opponent</td></tr>
<tr><td><strong>Multiplayer</strong></td><td>Automatic online play via rollback netcode</td></tr>
<tr><td><strong>Game Flow</strong></td><td>Title, Playing, GameOver states</td></tr>
<tr><td><strong>Scoring</strong></td><td>Point tracking, win conditions</td></tr>
<tr><td><strong>Audio</strong></td><td>Sound effects loaded from ROM with stereo panning</td></tr>
<tr><td><strong>Assets</strong></td><td>Sounds bundled with <code>nether build</code></td></tr>
</tbody>
</table>
</div>
<h2 id="whats-next"><a class="header" href="#whats-next">What’s Next?</a></h2>
<h3 id="enhance-your-paddle-game"><a class="header" href="#enhance-your-paddle-game">Enhance Your Paddle Game</a></h3>
<p>Ideas to try:</p>
<ul>
<li>Add ball speed increase after each hit</li>
<li>Create power-ups that spawn randomly</li>
<li>Add particle effects when scoring</li>
<li>Implement 4-player mode</li>
<li>Use sprite textures for paddles and ball</li>
</ul>
<h3 id="build-more-games"><a class="header" href="#build-more-games">Build More Games</a></h3>
<p>Check out these resources:</p>
<ul>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples">Example Games</a></strong> — 28+ examples</li>
<li><strong><a href="#cheat-sheet">API Reference</a></strong> — All available functions</li>
<li><strong><a href="#nethercore-asset-pipeline">Asset Pipeline</a></strong> — Advanced asset workflows</li>
<li><strong><a href="#render-modes-guide">Render Modes Guide</a></strong> — 3D graphics</li>
</ul>
<h3 id="join-the-community"><a class="header" href="#join-the-community">Join the Community</a></h3>
<ul>
<li>Share your game in <a href="https://github.com/nethercore/nethercore/discussions">GitHub Discussions</a></li>
<li>Report bugs or request features</li>
<li>Help other developers</li>
</ul>
<h2 id="complete-source-code"><a class="header" href="#complete-source-code">Complete Source Code</a></h2>
<p>The final source code is available at:</p>
<pre><code>nethercore/examples/paddle/
</code></pre>
<p>You can compare your code or use it as a reference.</p>
<hr>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<p>In this tutorial, you learned:</p>
<ol>
<li><strong>Setup</strong> — Creating an Nethercore project</li>
<li><strong>Drawing</strong> — Using <code>draw_rect()</code> for 2D graphics</li>
<li><strong>Input</strong> — Reading sticks and buttons</li>
<li><strong>Physics</strong> — Ball movement and collision</li>
<li><strong>AI</strong> — Simple opponent behavior</li>
<li><strong>Multiplayer</strong> — How rollback netcode “just works”</li>
<li><strong>Game Flow</strong> — State machines for menus</li>
<li><strong>Assets</strong> — Using <code>nether.toml</code> and <code>nether build</code> for sounds</li>
<li><strong>Audio</strong> — Loading and playing sound effects from ROM</li>
<li><strong>Publishing</strong> — Sharing your game with the world</li>
</ol>
<p><strong>You’re now an Nethercore game developer!</strong></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="render-modes-guide"><a class="header" href="#render-modes-guide">Render Modes Guide</a></h1>
<p>Nethercore ZX supports 4 rendering modes, each with different lighting and material features.</p>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Name</th><th>Lighting</th><th>Best For</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Unlit</td><td>None</td><td>Flat colors, UI, retro 2D</td></tr>
<tr><td>1</td><td>Matcap</td><td>Pre-baked</td><td>Stylized, toon, sculpted look</td></tr>
<tr><td>2</td><td>Metallic-Roughness</td><td>PBR-style Blinn-Phong</td><td>Realistic materials</td></tr>
<tr><td>3</td><td>Specular-Shininess</td><td>Traditional Blinn-Phong</td><td>Classic 3D, arcade</td></tr>
</tbody>
</table>
</div>
<p>Set the mode once in <code>init()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(2); // PBR-style lighting
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(2); // PBR-style lighting
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(2); // PBR-style lighting
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="mode-0-unlit"><a class="header" href="#mode-0-unlit">Mode 0: Unlit</a></h2>
<p>No lighting calculations. Colors come directly from textures and <code>set_color()</code>.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Fastest rendering</li>
<li>Flat, solid colors</li>
<li>No shadows or highlights</li>
<li>Perfect for 2D sprites, UI, or intentionally flat aesthetics</li>
</ul>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(0);
}

fn render() {
    // Color comes purely from texture + set_color tint
    texture_bind(sprite_tex);
    set_color(0xFFFFFFFF);
    draw_mesh(quad);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(0);
}

EWZX_EXPORT void render(void) {
    // Color comes purely from texture + set_color tint
    texture_bind(sprite_tex);
    set_color(0xFFFFFFFF);
    draw_mesh(quad);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(0);
}

export fn render() void {
    // Color comes purely from texture + set_color tint
    texture_bind(sprite_tex);
    set_color(0xFFFFFFFF);
    draw_mesh(quad);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Use cases:</strong></p>
<ul>
<li>2D games with sprite-based graphics</li>
<li>UI elements</li>
<li>Retro flat-shaded PS1 style</li>
<li>Unlit portions of scenes (skyboxes, emissive objects)</li>
</ul>
<hr>
<h2 id="mode-1-matcap"><a class="header" href="#mode-1-matcap">Mode 1: Matcap</a></h2>
<p>Uses matcap textures for pre-baked lighting. Fast and stylized.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Lighting baked into matcap textures</li>
<li>No dynamic lights</li>
<li>Great for stylized/toon looks</li>
<li>Multiple matcaps can be layered</li>
</ul>
<p><strong>Texture Slots:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Slot</th><th>Purpose</th><th>Blend Mode</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Albedo (UV-mapped)</td><td>Base color</td></tr>
<tr><td>1-3</td><td>Matcap (normal-mapped)</td><td>Configurable</td></tr>
</tbody>
</table>
</div>
<p><strong>Matcap Blend Modes:</strong></p>
<ul>
<li><strong>0 (Multiply):</strong> Darkens (shadows, AO)</li>
<li><strong>1 (Add):</strong> Brightens (highlights, rim)</li>
<li><strong>2 (HSV Modulate):</strong> Hue/saturation shift</li>
</ul>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(1);
    SHADOW_MATCAP = rom_texture(b"matcap_shadow".as_ptr(), 13);
    HIGHLIGHT_MATCAP = rom_texture(b"matcap_highlight".as_ptr(), 16);
}

fn render() {
    texture_bind(character_albedo);
    matcap_set(1, SHADOW_MATCAP);
    matcap_blend_mode(1, 0); // Multiply
    matcap_set(2, HIGHLIGHT_MATCAP);
    matcap_blend_mode(2, 1); // Add
    draw_mesh(character);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(1);
    SHADOW_MATCAP = rom_texture("matcap_shadow", 13);
    HIGHLIGHT_MATCAP = rom_texture("matcap_highlight", 16);
}

EWZX_EXPORT void render(void) {
    texture_bind(character_albedo);
    matcap_set(1, SHADOW_MATCAP);
    matcap_blend_mode(1, 0); // Multiply
    matcap_set(2, HIGHLIGHT_MATCAP);
    matcap_blend_mode(2, 1); // Add
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(1);
    SHADOW_MATCAP = rom_texture("matcap_shadow", 13);
    HIGHLIGHT_MATCAP = rom_texture("matcap_highlight", 16);
}

export fn render() void {
    texture_bind(character_albedo);
    matcap_set(1, SHADOW_MATCAP);
    matcap_blend_mode(1, 0); // Multiply
    matcap_set(2, HIGHLIGHT_MATCAP);
    matcap_blend_mode(2, 1); // Add
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Use cases:</strong></p>
<ul>
<li>Stylized/cartoon characters</li>
<li>Sculpt-like rendering</li>
<li>Fast mobile-friendly lighting</li>
<li>Consistent lighting regardless of scene</li>
</ul>
<hr>
<h2 id="mode-2-metallic-roughness"><a class="header" href="#mode-2-metallic-roughness">Mode 2: Metallic-Roughness</a></h2>
<p>PBR-inspired Blinn-Phong with metallic/roughness workflow.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Up to 4 dynamic lights</li>
<li>Metallic/roughness material properties</li>
<li>MRE texture support (Metallic/Roughness/Emissive)</li>
<li>Rim lighting</li>
<li>Procedural sky ambient</li>
<li>Energy-conserving Gotanda normalization</li>
</ul>
<p><strong>Texture Slots:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Slot</th><th>Purpose</th><th>Channels</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Albedo</td><td>RGB: Diffuse color</td></tr>
<tr><td>1</td><td>MRE</td><td>R: Metallic, G: Roughness, B: Emissive</td></tr>
</tbody>
</table>
</div>
<p><strong>Material Functions:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>material_metallic(0.0);    // 0 = dielectric, 1 = metal
material_roughness(0.5);   // 0 = mirror, 1 = rough
material_emissive(0.0);    // Self-illumination
material_rim(0.2, 0.15);   // Rim light intensity and power
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">material_metallic(0.0f);    // 0 = dielectric, 1 = metal
material_roughness(0.5f);   // 0 = mirror, 1 = rough
material_emissive(0.0f);    // Self-illumination
material_rim(0.2f, 0.15f);  // Rim light intensity and power
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">material_metallic(0.0);    // 0 = dielectric, 1 = metal
material_roughness(0.5);   // 0 = mirror, 1 = rough
material_emissive(0.0);    // Self-illumination
material_rim(0.2, 0.15);   // Rim light intensity and power
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(2);
}

fn render() {
    // Set up lighting
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF);
    light_enable(0);

    // Shiny metal
    material_metallic(1.0);
    material_roughness(0.2);
    material_rim(0.1, 0.2);
    texture_bind(sword_tex);
    draw_mesh(sword);

    // Rough stone
    material_metallic(0.0);
    material_roughness(0.9);
    material_rim(0.0, 0.0);
    texture_bind(stone_tex);
    draw_mesh(wall);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(2);
}

EWZX_EXPORT void render(void) {
    // Set up lighting
    light_set(0, 0.5f, -0.7f, 0.5f);
    light_color(0, 0xFFF2E6FF);
    light_enable(0);

    // Shiny metal
    material_metallic(1.0f);
    material_roughness(0.2f);
    material_rim(0.1f, 0.2f);
    texture_bind(sword_tex);
    draw_mesh(sword);

    // Rough stone
    material_metallic(0.0f);
    material_roughness(0.9f);
    material_rim(0.0f, 0.0f);
    texture_bind(stone_tex);
    draw_mesh(wall);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(2);
}

export fn render() void {
    // Set up lighting
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF);
    light_enable(0);

    // Shiny metal
    material_metallic(1.0);
    material_roughness(0.2);
    material_rim(0.1, 0.2);
    texture_bind(sword_tex);
    draw_mesh(sword);

    // Rough stone
    material_metallic(0.0);
    material_roughness(0.9);
    material_rim(0.0, 0.0);
    texture_bind(stone_tex);
    draw_mesh(wall);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Use cases:</strong></p>
<ul>
<li>Realistic materials (metal, plastic, wood)</li>
<li>PBR asset pipelines</li>
<li>Games requiring material variety</li>
<li>Modern 3D aesthetics</li>
</ul>
<hr>
<h2 id="mode-3-specular-shininess"><a class="header" href="#mode-3-specular-shininess">Mode 3: Specular-Shininess</a></h2>
<p>Traditional Blinn-Phong with direct specular color control.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Up to 4 dynamic lights</li>
<li>Shininess-based specular</li>
<li>Direct specular color control</li>
<li>Rim lighting</li>
<li>Energy-conserving Gotanda normalization</li>
</ul>
<p><strong>Texture Slots:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Slot</th><th>Purpose</th><th>Channels</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Albedo</td><td>RGB: Diffuse color</td></tr>
<tr><td>1</td><td>SSE</td><td>R: Specular intensity, G: Shininess, B: Emissive</td></tr>
<tr><td>2</td><td>Specular</td><td>RGB: Specular highlight color</td></tr>
</tbody>
</table>
</div>
<p><strong>Material Functions:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>material_shininess(0.7);           // 0-1 → maps to 1-256
material_specular(0xFFD700FF);     // Specular highlight color
material_emissive(0.0);            // Self-illumination
material_rim(0.2, 0.15);           // Rim light
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">material_shininess(0.7f);           // 0-1 → maps to 1-256
material_specular(0xFFD700FF);      // Specular highlight color
material_emissive(0.0f);            // Self-illumination
material_rim(0.2f, 0.15f);          // Rim light
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">material_shininess(0.7);           // 0-1 → maps to 1-256
material_specular(0xFFD700FF);     // Specular highlight color
material_emissive(0.0);            // Self-illumination
material_rim(0.2, 0.15);           // Rim light
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Shininess Values:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Shininess</th><th>Appearance</th></tr>
</thead>
<tbody>
<tr><td>0.0-0.2</td><td>1-52</td><td>Very soft (cloth, skin)</td></tr>
<tr><td>0.2-0.4</td><td>52-103</td><td>Broad (leather, wood)</td></tr>
<tr><td>0.4-0.6</td><td>103-154</td><td>Medium (plastic)</td></tr>
<tr><td>0.6-0.8</td><td>154-205</td><td>Tight (polished metal)</td></tr>
<tr><td>0.8-1.0</td><td>205-256</td><td>Mirror (chrome, glass)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(3);
}

fn render() {
    // Gold armor
    set_color(0xE6B84DFF);
    material_shininess(0.8);
    material_specular(0xFFD700FF);
    material_rim(0.2, 0.15);
    draw_mesh(armor);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7);
    material_specular(0xFFFFFFFF);
    material_rim(0.3, 0.25);
    draw_mesh(character);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(3);
}

EWZX_EXPORT void render(void) {
    // Gold armor
    set_color(0xE6B84DFF);
    material_shininess(0.8f);
    material_specular(0xFFD700FF);
    material_rim(0.2f, 0.15f);
    draw_mesh(armor);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7f);
    material_specular(0xFFFFFFFF);
    material_rim(0.3f, 0.25f);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(3);
}

export fn render() void {
    // Gold armor
    set_color(0xE6B84DFF);
    material_shininess(0.8);
    material_specular(0xFFD700FF);
    material_rim(0.2, 0.15);
    draw_mesh(armor);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7);
    material_specular(0xFFFFFFFF);
    material_rim(0.3, 0.25);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Use cases:</strong></p>
<ul>
<li>Classic 3D game aesthetics</li>
<li>Colored specular highlights (metals)</li>
<li>Artist-friendly workflow</li>
<li>Fighting games, action games</li>
</ul>
<hr>
<h2 id="choosing-a-mode"><a class="header" href="#choosing-a-mode">Choosing a Mode</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>If you need…</th><th>Use Mode</th></tr>
</thead>
<tbody>
<tr><td>Fastest rendering, no lighting</td><td>0 (Unlit)</td></tr>
<tr><td>Stylized, consistent lighting</td><td>1 (Matcap)</td></tr>
<tr><td>PBR workflow with MRE textures</td><td>2 (Metallic-Roughness)</td></tr>
<tr><td>Colored specular, artist control</td><td>3 (Specular-Shininess)</td></tr>
</tbody>
</table>
</div>
<p><strong>Performance:</strong> All lit modes (1-3) have similar performance. Mode 0 is fastest.</p>
<p><strong>Compatibility:</strong> All modes work with procedural meshes and skeletal animation.</p>
<hr>
<h2 id="common-setup"><a class="header" href="#common-setup">Common Setup</a></h2>
<p>All lit modes benefit from proper sky and light setup:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(2); // or 1 or 3

    // Sky provides ambient light
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    sky_set_sun(0.5, 0.7, 0.5, 0xFFF2E6FF, 0.95);
}

fn render() {
    draw_sky();

    // Main light (match sun direction)
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF);
    light_intensity(0, 1.0);
    light_enable(0);

    // Fill light
    light_set(1, -0.8, -0.3, 0.0);
    light_color(1, 0x8899BBFF);
    light_intensity(1, 0.3);
    light_enable(1);

    // Draw scene...
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(2); // or 1 or 3

    // Sky provides ambient light
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    sky_set_sun(0.5f, 0.7f, 0.5f, 0xFFF2E6FF, 0.95f);
}

EWZX_EXPORT void render(void) {
    draw_sky();

    // Main light (match sun direction)
    light_set(0, 0.5f, -0.7f, 0.5f);
    light_color(0, 0xFFF2E6FF);
    light_intensity(0, 1.0f);
    light_enable(0);

    // Fill light
    light_set(1, -0.8f, -0.3f, 0.0f);
    light_color(1, 0x8899BBFF);
    light_intensity(1, 0.3f);
    light_enable(1);

    // Draw scene...
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(2); // or 1 or 3

    // Sky provides ambient light
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    sky_set_sun(0.5, 0.7, 0.5, 0xFFF2E6FF, 0.95);
}

export fn render() void {
    draw_sky();

    // Main light (match sun direction)
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF);
    light_intensity(0, 1.0);
    light_enable(0);

    // Fill light
    light_set(1, -0.8, -0.3, 0.0);
    light_color(1, 0x8899BBFF);
    light_intensity(1, 0.3);
    light_enable(1);

    // Draw scene...
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rollback-safety-guide"><a class="header" href="#rollback-safety-guide">Rollback Safety Guide</a></h1>
<p>Writing deterministic code for Nethercore’s rollback netcode.</p>
<h2 id="how-rollback-works"><a class="header" href="#how-rollback-works">How Rollback Works</a></h2>
<p>Nethercore uses GGRS for deterministic rollback netcode:</p>
<ol>
<li><strong>Every tick</strong>, your <code>update()</code> receives inputs from all players</li>
<li><strong>GGRS synchronizes</strong> inputs across the network</li>
<li><strong>On misprediction</strong>, the game state is restored from a snapshot and replayed</li>
</ol>
<p>For this to work, your <code>update()</code> must be <strong>deterministic</strong>: same inputs → same state.</p>
<hr>
<h2 id="the-golden-rules"><a class="header" href="#the-golden-rules">The Golden Rules</a></h2>
<h3 id="1-use-random-for-all-randomness"><a class="header" href="#1-use-random-for-all-randomness">1. Use <code>random()</code> for All Randomness</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - Deterministic
let spawn_x = (random() % 320) as f32;
let damage = 10 + (random() % 5) as i32;

// BAD - Non-deterministic
let spawn_x = system_time_nanos() % 320;  // Different on each client!
let damage = 10 + (thread_rng().next_u32() % 5); // Different seeds!
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// GOOD - Deterministic
float spawn_x = (float)(random_u32() % 320);
int32_t damage = 10 + (int32_t)(random_u32() % 5);

// BAD - Non-deterministic
float spawn_x = (float)(time(NULL) % 320);  // Different on each client!
int32_t damage = 10 + (rand() % 5); // Different seeds!
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// GOOD - Deterministic
const spawn_x: f32 = @floatFromInt(random_u32() % 320);
const damage: i32 = 10 + @intCast(random_u32() % 5);

// BAD - Non-deterministic
const spawn_x: f32 = @floatFromInt(std.time.nanoTimestamp() % 320);  // Different on each client!
const damage: i32 = 10 + @intCast(rand.next() % 5); // Different seeds!
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>The <code>random()</code> function returns values from a synchronized seed, ensuring all clients get the same sequence.</p>
<hr>
<h3 id="2-keep-state-in-static-variables"><a class="header" href="#2-keep-state-in-static-variables">2. Keep State in Static Variables</a></h3>
<p>All game state must live in WASM linear memory (global statics):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - State in WASM memory (snapshotted)
static mut PLAYER_X: f32 = 0.0;
static mut ENEMIES: [Enemy; 10] = [Enemy::new(); 10];

// BAD - State outside WASM memory
// (external systems, thread-locals, etc. are not snapshotted)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// GOOD - State in WASM memory (snapshotted)
static float player_x = 0.0f;
static Enemy enemies[10] = {0};

// BAD - State outside WASM memory
// (external systems, thread-locals, etc. are not snapshotted)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// GOOD - State in WASM memory (snapshotted)
var player_x: f32 = 0.0;
var enemies: [10]Enemy = [_]Enemy{Enemy{}} ** 10;

// BAD - State outside WASM memory
// (external systems, thread-locals, etc. are not snapshotted)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="3-same-inputs--same-state"><a class="header" href="#3-same-inputs--same-state">3. Same Inputs = Same State</a></h3>
<p>Your <code>update()</code> must produce identical results given identical inputs:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // All calculations based only on:
    // - Current state (in WASM memory)
    // - Player inputs (from GGRS)
    // - delta_time() / elapsed_time() / tick_count() (synchronized)
    // - random() (synchronized)

    let dt = delta_time();
    for p in 0..player_count() {
        if button_pressed(p, BUTTON_A) != 0 {
            players[p].jump();
        }
        players[p].x += left_stick_x(p) * SPEED * dt;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // All calculations based only on:
    // - Current state (in WASM memory)
    // - Player inputs (from GGRS)
    // - delta_time() / elapsed_time() / tick_count() (synchronized)
    // - random_u32() (synchronized)

    float dt = delta_time();
    for (uint32_t p = 0; p &lt; player_count(); p++) {
        if (button_pressed(p, EWZX_BUTTON_A) != 0) {
            player_jump(&amp;players[p]);
        }
        players[p].x += left_stick_x(p) * SPEED * dt;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // All calculations based only on:
    // - Current state (in WASM memory)
    // - Player inputs (from GGRS)
    // - delta_time() / elapsed_time() / tick_count() (synchronized)
    // - random_u32() (synchronized)

    const dt = delta_time();
    var p: u32 = 0;
    while (p &lt; player_count()) : (p += 1) {
        if (button_pressed(p, Button.a) != 0) {
            players[p].jump();
        }
        players[p].x += left_stick_x(p) * SPEED * dt;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="4-render-is-skipped-during-rollback"><a class="header" href="#4-render-is-skipped-during-rollback">4. Render is Skipped During Rollback</a></h3>
<p><code>render()</code> is <strong>not</strong> called during rollback replay. Don’t put game logic in <code>render()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// GOOD - Logic in update()
fn update() {
    ANIMATION_FRAME = (tick_count() as u32 / 6) % 4;
}

fn render() {
    // Just draw, no state changes
    draw_sprite_region(..., ANIMATION_FRAME as f32 * 32.0, ...);
}

// BAD - Logic in render()
fn render() {
    ANIMATION_FRAME += 1;  // Skipped during rollback = desynced!
    draw_sprite_region(...);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// GOOD - Logic in update()
EWZX_EXPORT void update(void) {
    animation_frame = (tick_count() / 6) % 4;
}

EWZX_EXPORT void render(void) {
    // Just draw, no state changes
    draw_sprite_region(..., (float)animation_frame * 32.0f, ...);
}

// BAD - Logic in render()
EWZX_EXPORT void render(void) {
    animation_frame++;  // Skipped during rollback = desynced!
    draw_sprite_region(...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// GOOD - Logic in update()
export fn update() void {
    animation_frame = (tick_count() / 6) % 4;
}

export fn render() void {
    // Just draw, no state changes
    draw_sprite_region(..., @as(f32, @floatFromInt(animation_frame)) * 32.0, ...);
}

// BAD - Logic in render()
export fn render() void {
    animation_frame += 1;  // Skipped during rollback = desynced!
    draw_sprite_region(...);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="common-pitfalls"><a class="header" href="#common-pitfalls">Common Pitfalls</a></h2>
<h3 id="floating-point-non-determinism"><a class="header" href="#floating-point-non-determinism">Floating Point Non-Determinism</a></h3>
<p>Floating point operations can vary across CPUs. Nethercore handles most cases, but be careful with:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Potentially problematic
let angle = (y / x).atan();  // atan can differ slightly

// Safer alternatives
// - Use integer math where possible
// - Use lookup tables for trig
// - Accept small visual differences (for rendering only)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Potentially problematic
float angle = atanf(y / x);  // atan can differ slightly

// Safer alternatives
// - Use integer math where possible
// - Use lookup tables for trig
// - Accept small visual differences (for rendering only)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Potentially problematic
const angle = std.math.atan(y / x);  // atan can differ slightly

// Safer alternatives
// - Use integer math where possible
// - Use lookup tables for trig
// - Accept small visual differences (for rendering only)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="order-dependent-iteration"><a class="header" href="#order-dependent-iteration">Order-Dependent Iteration</a></h3>
<p>HashMap iteration order is non-deterministic:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD - Non-deterministic order
for (id, enemy) in enemies.iter() {
    enemy.update();  // Order matters for collisions!
}

// GOOD - Fixed order
for i in 0..enemies.len() {
    enemies[i].update();
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// BAD - Non-deterministic order
// (using a hash map or unordered container)

// GOOD - Fixed order
for (size_t i = 0; i &lt; enemy_count; i++) {
    enemy_update(&amp;enemies[i]);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// BAD - Non-deterministic order
// (using a hash map)

// GOOD - Fixed order
var i: usize = 0;
while (i &lt; enemies.len) : (i += 1) {
    enemies[i].update();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="external-state"><a class="header" href="#external-state">External State</a></h3>
<p>Never read from external sources in <code>update()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// BAD
let now = SystemTime::now();  // Different on each client
let file = read_file("data.txt");  // Files can differ
let response = http_get("api.com");  // Network varies

// GOOD - All data from ROM or synchronized state
let data = rom_data(b"level".as_ptr(), 5, ...);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// BAD
time_t now = time(NULL);  // Different on each client
// Reading files or network requests  // Can differ

// GOOD - All data from ROM or synchronized state
uint32_t data = rom_data((uint32_t)"level", 5, ...);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// BAD
const now = std.time.timestamp();  // Different on each client
// Reading files or network requests  // Can differ

// GOOD - All data from ROM or synchronized state
const data = rom_data("level".ptr, 5, ...);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="audio-and-visual-effects"><a class="header" href="#audio-and-visual-effects">Audio and Visual Effects</a></h2>
<p>Audio and particles are often non-critical for gameplay:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Core gameplay - must be deterministic
    if player_hit_enemy() {
        ENEMY_HEALTH -= DAMAGE;

        // Audio/VFX triggers are fine here
        // (they'll replay during rollback, but that's OK)
        play_sound(HIT_SFX, 1.0, 0.0);
    }
}

fn render() {
    // Visual-only effects
    spawn_particles(PLAYER_X, PLAYER_Y);  // Not critical
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // Core gameplay - must be deterministic
    if (player_hit_enemy()) {
        enemy_health -= DAMAGE;

        // Audio/VFX triggers are fine here
        // (they'll replay during rollback, but that's OK)
        play_sound(HIT_SFX, 1.0f, 0.0f);
    }
}

EWZX_EXPORT void render(void) {
    // Visual-only effects
    spawn_particles(player_x, player_y);  // Not critical
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Core gameplay - must be deterministic
    if (player_hit_enemy()) {
        enemy_health -= DAMAGE;

        // Audio/VFX triggers are fine here
        // (they'll replay during rollback, but that's OK)
        play_sound(HIT_SFX, 1.0, 0.0);
    }
}

export fn render() void {
    // Visual-only effects
    spawn_particles(player_x, player_y);  // Not critical
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="memory-snapshotting"><a class="header" href="#memory-snapshotting">Memory Snapshotting</a></h2>
<p>Nethercore automatically snapshots your WASM linear memory:</p>
<pre><code>What's Snapshotted (RAM):        What's NOT Snapshotted:
├── Static variables             ├── GPU textures (VRAM)
├── Heap allocations             ├── Audio buffers
├── Stack (function locals)      ├── Mesh data
└── Resource handles (u32s)      └── Resource data
</code></pre>
<p><strong>Tip:</strong> Keep your game state small for faster snapshots. Only handles (u32) live in RAM; actual texture/mesh/audio data stays in host memory.</p>
<hr>
<h2 id="testing-determinism"><a class="header" href="#testing-determinism">Testing Determinism</a></h2>
<h3 id="local-testing"><a class="header" href="#local-testing">Local Testing</a></h3>
<p>Run the same inputs twice and compare state:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // After each update, log state hash
    let hash = calculate_state_hash();
    log_fmt(b"Tick {} hash: {}", tick_count(), hash);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    // After each update, log state hash
    uint32_t hash = calculate_state_hash();
    log_fmt((uint32_t)"Tick %u hash: %u", tick_count(), hash);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // After each update, log state hash
    const hash = calculate_state_hash();
    log_fmt("Tick {} hash: {}", .{tick_count(), hash});
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="multiplayer-testing"><a class="header" href="#multiplayer-testing">Multiplayer Testing</a></h3>
<ol>
<li>Start a local game with 2 players</li>
<li>Give identical inputs</li>
<li>Verify states match</li>
</ol>
<hr>
<h2 id="debug-checklist"><a class="header" href="#debug-checklist">Debug Checklist</a></h2>
<p>If you see desync:</p>
<ol>
<li><strong>Check <code>random()</code> usage</strong> - All randomness from <code>random()</code>?</li>
<li><strong>Check iteration order</strong> - Using fixed-order arrays?</li>
<li><strong>Check floating point</strong> - Sensitive calculations reproducible?</li>
<li><strong>Check <code>render()</code> logic</strong> - Any state changes in render?</li>
<li><strong>Check external reads</strong> - System time, files, network?</li>
<li><strong>Check audio timing</strong> - Audio triggering consistent?</li>
</ol>
<hr>
<h2 id="example-deterministic-enemy-ai"><a class="header" href="#example-deterministic-enemy-ai">Example: Deterministic Enemy AI</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut ENEMIES: [Enemy; 10] = [Enemy::new(); 10];
static mut ENEMY_COUNT: usize = 0;

#[derive(Clone, Copy)]
struct Enemy {
    x: f32,
    y: f32,
    health: i32,
    ai_state: u8,
    ai_timer: u32,
}

impl Enemy {
    const fn new() -&gt; Self {
        Self { x: 0.0, y: 0.0, health: 100, ai_state: 0, ai_timer: 0 }
    }

    fn update(&amp;mut self, player_x: f32, player_y: f32) {
        match self.ai_state {
            0 =&gt; {
                // Idle - random chance to start patrol
                if random() % 100 &lt; 5 {  // 5% chance per tick
                    self.ai_state = 1;
                    self.ai_timer = 60 + (random() % 60);  // 1-2 seconds
                }
            }
            1 =&gt; {
                // Patrol - move toward random target
                self.ai_timer -= 1;
                if self.ai_timer == 0 {
                    self.ai_state = 0;
                }
                // Movement...
            }
            _ =&gt; {}
        }
    }
}

fn update() {
    unsafe {
        let px = PLAYER_X;
        let py = PLAYER_Y;

        // Fixed iteration order
        for i in 0..ENEMY_COUNT {
            ENEMIES[i].update(px, py);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">typedef struct {
    float x;
    float y;
    int32_t health;
    uint8_t ai_state;
    uint32_t ai_timer;
} Enemy;

static Enemy enemies[10] = {0};
static size_t enemy_count = 0;

void enemy_update(Enemy* enemy, float player_x, float player_y) {
    switch (enemy-&gt;ai_state) {
        case 0:
            // Idle - random chance to start patrol
            if (random_u32() % 100 &lt; 5) {  // 5% chance per tick
                enemy-&gt;ai_state = 1;
                enemy-&gt;ai_timer = 60 + (random_u32() % 60);  // 1-2 seconds
            }
            break;
        case 1:
            // Patrol - move toward random target
            enemy-&gt;ai_timer--;
            if (enemy-&gt;ai_timer == 0) {
                enemy-&gt;ai_state = 0;
            }
            // Movement...
            break;
    }
}

EWZX_EXPORT void update(void) {
    float px = player_x;
    float py = player_y;

    // Fixed iteration order
    for (size_t i = 0; i &lt; enemy_count; i++) {
        enemy_update(&amp;enemies[i], px, py);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const Enemy = struct {
    x: f32 = 0.0,
    y: f32 = 0.0,
    health: i32 = 100,
    ai_state: u8 = 0,
    ai_timer: u32 = 0,

    pub fn update(self: *Enemy, player_x: f32, player_y: f32) void {
        switch (self.ai_state) {
            0 =&gt; {
                // Idle - random chance to start patrol
                if (random_u32() % 100 &lt; 5) {  // 5% chance per tick
                    self.ai_state = 1;
                    self.ai_timer = 60 + (random_u32() % 60);  // 1-2 seconds
                }
            },
            1 =&gt; {
                // Patrol - move toward random target
                self.ai_timer -= 1;
                if (self.ai_timer == 0) {
                    self.ai_state = 0;
                }
                // Movement...
            },
            else =&gt; {},
        }
    }
};

var enemies: [10]Enemy = [_]Enemy{Enemy{}} ** 10;
var enemy_count: usize = 0;

export fn update() void {
    const px = player_x;
    const py = player_y;

    // Fixed iteration order
    var i: usize = 0;
    while (i &lt; enemy_count) : (i += 1) {
        enemies[i].update(px, py);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>This AI is deterministic because:</p>
<ul>
<li><code>random()</code> is synchronized</li>
<li>Array iteration has fixed order</li>
<li>All state is in WASM memory</li>
<li>No external dependencies</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="nethercore-asset-pipeline"><a class="header" href="#nethercore-asset-pipeline">Nethercore Asset Pipeline</a></h1>
<p>Convert 3D models, textures, and audio into optimized Nethercore formats.</p>
<hr>
<h2 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h2>
<p>Getting assets into an Nethercore game is 3 steps:</p>
<p><strong>1. Export from your 3D tool</strong> (Blender, Maya, etc.) as glTF, GLB, or OBJ</p>
<p><strong>2. Create <code>assets.toml</code>:</strong></p>
<pre><code class="language-toml">[output]
dir = "assets/"

[meshes]
player = "models/player.gltf"
enemy = "models/enemy.glb"

[textures]
grass = "textures/grass.png"

[sounds]
jump = "audio/jump.wav"
</code></pre>
<p><strong>3. Build and use:</strong></p>
<pre><code class="language-bash">nether-export build assets.toml
</code></pre>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static PLAYER_MESH: &amp;[u8] = include_bytes!("assets/player.ewzmesh");
static GRASS_TEX: &amp;[u8] = include_bytes!("assets/grass.ewztex");

fn init() {
    let player = load_zmesh(PLAYER_MESH.as_ptr() as u32, PLAYER_MESH.len() as u32);
    let grass = load_ztex(GRASS_TEX.as_ptr() as u32, GRASS_TEX.len() as u32);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Embed assets at compile time (platform-specific)
extern const unsigned char player_ewzmesh_data[];
extern const unsigned int player_ewzmesh_size;
extern const unsigned char grass_ewztex_data[];
extern const unsigned int grass_ewztex_size;

EWZX_EXPORT void init(void) {
    uint32_t player = load_zmesh((uint32_t)player_ewzmesh_data, player_ewzmesh_size);
    uint32_t grass = load_ztex((uint32_t)grass_ewztex_data, grass_ewztex_size);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const player_mesh = @embedFile("assets/player.ewzmesh");
const grass_tex = @embedFile("assets/grass.ewztex");

export fn init() void {
    const player = load_zmesh(@intFromPtr(player_mesh.ptr), player_mesh.len);
    const grass = load_ztex(@intFromPtr(grass_tex.ptr), grass_tex.len);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>One manifest, one command, simple FFI calls.</p>
<hr>
<h2 id="supported-input-formats"><a class="header" href="#supported-input-formats">Supported Input Formats</a></h2>
<h3 id="3d-models"><a class="header" href="#3d-models">3D Models</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Extension</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>glTF 2.0</strong></td><td><code>.gltf</code>, <code>.glb</code></td><td>Implemented</td></tr>
<tr><td><strong>OBJ</strong></td><td><code>.obj</code></td><td>Implemented</td></tr>
</tbody>
</table>
</div>
<p><strong>Recommendation:</strong> Use glTF for new projects. It’s the “JPEG of 3D” - efficient, well-documented, and supported everywhere.</p>
<h3 id="textures"><a class="header" href="#textures">Textures</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>PNG</strong></td><td>Implemented</td></tr>
<tr><td><strong>JPG</strong></td><td>Implemented</td></tr>
</tbody>
</table>
</div>
<h3 id="audio"><a class="header" href="#audio">Audio</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>WAV</strong></td><td>Implemented</td></tr>
</tbody>
</table>
</div>
<h3 id="fonts"><a class="header" href="#fonts">Fonts</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Status</th></tr>
</thead>
<tbody>
<tr><td><strong>TTF</strong></td><td>Planned</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="manifest-based-asset-pipeline"><a class="header" href="#manifest-based-asset-pipeline">Manifest-Based Asset Pipeline</a></h2>
<p>Define all your game assets in a single <code>assets.toml</code> file, then build everything with one command.</p>
<h3 id="assetstoml-reference"><a class="header" href="#assetstoml-reference">assets.toml Reference</a></h3>
<pre><code class="language-toml"># Output configuration
[output]
dir = "assets/"                  # Output directory for converted files
# rust = "src/assets.rs"         # Planned: Generated Rust module

# 3D Models
[meshes]
player = "models/player.gltf"                           # Simple: just the path
enemy = "models/enemy.glb"
level = { path = "models/level.obj", format = "POS_UV_NORMAL" }  # With options

# Textures
[textures]
player_diffuse = "textures/player.png"

# Audio
[sounds]
jump = "audio/jump.wav"

# Fonts (planned)
# [fonts]
# ui = { path = "fonts/roboto.ttf", size = 16 }
</code></pre>
<h3 id="build-commands"><a class="header" href="#build-commands">Build Commands</a></h3>
<pre><code class="language-bash"># Build all assets from manifest
nether-export build assets.toml

# Validate manifest without building
nether-export check assets.toml

# Convert individual files
nether-export mesh player.gltf -o player.ewzmesh
nether-export texture grass.png -o grass.ewztex
nether-export audio jump.wav -o jump.ewzsnd
</code></pre>
<h3 id="output-files"><a class="header" href="#output-files">Output Files</a></h3>
<p>Running <code>nether-export build assets.toml</code> generates binary asset files:</p>
<ul>
<li><code>player.ewzmesh</code>, <code>enemy.ewzmesh</code>, <code>level.ewzmesh</code></li>
<li><code>player_diffuse.ewztex</code></li>
<li><code>jump.ewzsnd</code></li>
</ul>
<hr>
<h2 id="output-file-formats"><a class="header" href="#output-file-formats">Output File Formats</a></h2>
<h3 id="netherzmesh-ewzmesh"><a class="header" href="#netherzmesh-ewzmesh">NetherZMesh (.ewzmesh)</a></h3>
<p>Binary format for 3D meshes with GPU-optimized packed vertex data. POD format (no magic bytes).</p>
<p><strong>Header (12 bytes):</strong></p>
<pre><code>Offset | Type | Description
-------|------|----------------------------------
0x00   | u32  | Vertex count
0x04   | u32  | Index count
0x08   | u8   | Vertex format flags (0-15)
0x09   | u8   | Reserved (padding)
0x0A   | u16  | Reserved (padding)
0x0C   | data | Vertex data (vertex_count * stride bytes)
0x??   | u16[]| Index data (index_count * 2 bytes)
</code></pre>
<p>Stride is calculated from the format flags at runtime.</p>
<h3 id="netherztexture-ewztex"><a class="header" href="#netherztexture-ewztex">NetherZTexture (.ewztex)</a></h3>
<p>Binary format for textures. POD format (no magic bytes).</p>
<p><strong>Current Header (4 bytes):</strong></p>
<pre><code>Offset | Type | Description
-------|------|----------------------------------
0x00   | u16  | Width in pixels (max 65535)
0x02   | u16  | Height in pixels (max 65535)
0x04   | u8[] | Pixel data (RGBA8, width * height * 4 bytes)
</code></pre>
<p><strong>⚠️ Format Change (Dec 12, 2024):</strong></p>
<ul>
<li><strong>Old format</strong> (before commit 3ed67ef): 8-byte header with <code>u32 width + u32 height</code></li>
<li><strong>Current format</strong>: 4-byte header with <code>u16 width + u16 height</code></li>
<li>If you have old <code>.ewztex</code> files, regenerate them with:
<pre><code class="language-bash">nether-export texture &lt;source.png&gt; -o &lt;output.ewztex&gt;
</code></pre>
</li>
<li><strong>Symptom of old format</strong>: “invalid dimensions” error during load</li>
</ul>
<h3 id="netherzsound-ewzsnd"><a class="header" href="#netherzsound-ewzsnd">NetherZSound (.ewzsnd)</a></h3>
<p>Binary format for audio. POD format (no magic bytes).</p>
<p><strong>Header (4 bytes):</strong></p>
<pre><code>Offset | Type  | Description
-------|-------|----------------------------------
0x00   | u32   | Sample count
0x04   | i16[] | PCM samples (22050Hz mono)
</code></pre>
<hr>
<h2 id="vertex-formats"><a class="header" href="#vertex-formats">Vertex Formats</a></h2>
<p>The Nethercore runtime supports 16 vertex format combinations, controlled by format flags.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FORMAT_UV: u8 = 1;      // Texture coordinates
const FORMAT_COLOR: u8 = 2;   // Per-vertex color
const FORMAT_NORMAL: u8 = 4;  // Surface normals
const FORMAT_SKINNED: u8 = 8; // Bone weights for skeletal animation
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define FORMAT_UV      1   // Texture coordinates
#define FORMAT_COLOR   2   // Per-vertex color
#define FORMAT_NORMAL  4   // Surface normals
#define FORMAT_SKINNED 8   // Bone weights for skeletal animation
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const FORMAT_UV: u8 = 1;      // Texture coordinates
const FORMAT_COLOR: u8 = 2;   // Per-vertex color
const FORMAT_NORMAL: u8 = 4;  // Surface normals
const FORMAT_SKINNED: u8 = 8; // Bone weights for skeletal animation
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="all-16-formats"><a class="header" href="#all-16-formats">All 16 Formats</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Name</th><th>Packed Stride</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>POS</td><td>8 bytes</td></tr>
<tr><td>1</td><td>POS_UV</td><td>12 bytes</td></tr>
<tr><td>2</td><td>POS_COLOR</td><td>12 bytes</td></tr>
<tr><td>3</td><td>POS_UV_COLOR</td><td>16 bytes</td></tr>
<tr><td>4</td><td>POS_NORMAL</td><td>12 bytes</td></tr>
<tr><td>5</td><td>POS_UV_NORMAL</td><td>16 bytes</td></tr>
<tr><td>6</td><td>POS_COLOR_NORMAL</td><td>16 bytes</td></tr>
<tr><td>7</td><td>POS_UV_COLOR_NORMAL</td><td>20 bytes</td></tr>
<tr><td>8</td><td>POS_SKINNED</td><td>16 bytes</td></tr>
<tr><td>9</td><td>POS_UV_SKINNED</td><td>20 bytes</td></tr>
<tr><td>10</td><td>POS_COLOR_SKINNED</td><td>20 bytes</td></tr>
<tr><td>11</td><td>POS_UV_COLOR_SKINNED</td><td>24 bytes</td></tr>
<tr><td>12</td><td>POS_NORMAL_SKINNED</td><td>20 bytes</td></tr>
<tr><td>13</td><td>POS_UV_NORMAL_SKINNED</td><td>24 bytes</td></tr>
<tr><td>14</td><td>POS_COLOR_NORMAL_SKINNED</td><td>24 bytes</td></tr>
<tr><td>15</td><td>POS_UV_COLOR_NORMAL_SKINNED</td><td>28 bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>Common formats:</strong></p>
<ul>
<li><strong>Format 5 (POS_UV_NORMAL)</strong>: Most common for textured, lit meshes</li>
<li><strong>Format 13 (POS_UV_NORMAL_SKINNED)</strong>: Animated characters</li>
</ul>
<hr>
<h2 id="packed-vertex-data"><a class="header" href="#packed-vertex-data">Packed Vertex Data</a></h2>
<p>The runtime automatically packs vertex data using GPU-optimized formats for smaller memory footprint and faster uploads.</p>
<h3 id="attribute-encoding"><a class="header" href="#attribute-encoding">Attribute Encoding</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Attribute</th><th>Packed Format</th><th>Size</th><th>Notes</th></tr>
</thead>
<tbody>
<tr><td>Position</td><td>Float16x4</td><td>8 bytes</td><td>x, y, z, w=1.0</td></tr>
<tr><td>UV</td><td>Unorm16x2</td><td>4 bytes</td><td>65536 values in [0,1], better precision than f16</td></tr>
<tr><td>Color</td><td>Unorm8x4</td><td>4 bytes</td><td>RGBA, alpha=255 if not provided</td></tr>
<tr><td>Normal</td><td>Octahedral u32</td><td>4 bytes</td><td>~0.02° angular precision</td></tr>
<tr><td>Bone Indices</td><td>Uint8x4</td><td>4 bytes</td><td>Up to 256 bones</td></tr>
<tr><td>Bone Weights</td><td>Unorm8x4</td><td>4 bytes</td><td>Normalized to [0,255]</td></tr>
</tbody>
</table>
</div>
<h3 id="octahedral-normal-encoding"><a class="header" href="#octahedral-normal-encoding">Octahedral Normal Encoding</a></h3>
<p>Normals use octahedral encoding for uniform angular precision with 66% size reduction:</p>
<pre><code>Standard normal: 3 floats × 4 bytes = 12 bytes
Octahedral:      1 u32              =  4 bytes
</code></pre>
<p><strong>How it works:</strong></p>
<ol>
<li>Project 3D unit vector onto octahedron surface</li>
<li>Unfold octahedron to 2D square [-1, 1]²</li>
<li>Pack as 2× snorm16 into single u32</li>
</ol>
<p><strong>Precision:</strong> ~0.02° worst-case angular error - uniform across the entire sphere.</p>
<p>The vertex shader decodes the normal automatically.</p>
<h3 id="memory-savings"><a class="header" href="#memory-savings">Memory Savings</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Unpacked</th><th>Packed</th><th>Savings</th></tr>
</thead>
<tbody>
<tr><td>POS_UV_NORMAL</td><td>32 bytes</td><td>16 bytes</td><td>50%</td></tr>
<tr><td>POS_UV_NORMAL_SKINNED</td><td>52 bytes</td><td>24 bytes</td><td>54%</td></tr>
<tr><td>Full format (15)</td><td>64 bytes</td><td>28 bytes</td><td>56%</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="skeletal-animation"><a class="header" href="#skeletal-animation">Skeletal Animation</a></h2>
<h3 id="vertex-skinning-data"><a class="header" href="#vertex-skinning-data">Vertex Skinning Data</a></h3>
<p>Each skinned vertex stores:</p>
<ul>
<li><strong>Bone Indices</strong>: Uint8x4 (4 bytes) - which bones affect this vertex (0-255)</li>
<li><strong>Bone Weights</strong>: Unorm8x4 (4 bytes) - influence weights, normalized</li>
</ul>
<h3 id="bone-matrices"><a class="header" href="#bone-matrices">Bone Matrices</a></h3>
<p>Bone transforms use 3×4 affine matrices (not 4×4):</p>
<pre><code>set_bones(matrices_ptr, count)
</code></pre>
<p><strong>3×4 Matrix Layout (column-major, 12 floats per bone):</strong></p>
<pre><code>[m00, m10, m20]  ← column 0 (X basis)
[m01, m11, m21]  ← column 1 (Y basis)
[m02, m12, m22]  ← column 2 (Z basis)
[m03, m13, m23]  ← column 3 (translation)
</code></pre>
<p>The bottom row <code>[0, 0, 0, 1]</code> is implicit (affine transform).</p>
<p><strong>Limits:</strong></p>
<ul>
<li>Maximum 256 bones per skeleton</li>
<li>48 bytes per bone (vs 64 bytes for 4×4) - 25% memory savings</li>
</ul>
<hr>
<h2 id="tool-reference"><a class="header" href="#tool-reference">Tool Reference</a></h2>
<h3 id="nether-export"><a class="header" href="#nether-export">nether-export</a></h3>
<p>The asset conversion CLI tool.</p>
<p><strong>Build from manifest:</strong></p>
<pre><code class="language-bash">nether-export build assets.toml           # Build all assets
nether-export check assets.toml           # Validate only
</code></pre>
<p><strong>Convert individual files:</strong></p>
<pre><code class="language-bash"># Meshes
nether-export mesh player.gltf -o player.ewzmesh
nether-export mesh level.obj -o level.ewzmesh --format POS_UV_NORMAL

# Textures
nether-export texture grass.png -o grass.ewztex

# Audio
nether-export audio jump.wav -o jump.ewzsnd
</code></pre>
<hr>
<h2 id="loading-assets-ffi"><a class="header" href="#loading-assets-ffi">Loading Assets (FFI)</a></h2>
<h3 id="netherz-format-loading-recommended"><a class="header" href="#netherz-format-loading-recommended">NetherZ Format Loading (Recommended)</a></h3>
<p>The simplest way to load assets is using the NetherZ format functions. These parse the POD headers host-side and upload to GPU.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// FFI declarations
extern "C" {
    fn load_zmesh(data_ptr: u32, data_len: u32) -&gt; u32;
    fn load_ztex(data_ptr: u32, data_len: u32) -&gt; u32;
    fn load_zsound(data_ptr: u32, data_len: u32) -&gt; u32;
}

// Embed assets at compile time
static PLAYER_MESH: &amp;[u8] = include_bytes!("assets/player.ewzmesh");
static GRASS_TEX: &amp;[u8] = include_bytes!("assets/grass.ewztex");
static JUMP_SFX: &amp;[u8] = include_bytes!("assets/jump.ewzsnd");

fn init() {
    let player = load_zmesh(PLAYER_MESH.as_ptr() as u32, PLAYER_MESH.len() as u32);
    let grass = load_ztex(GRASS_TEX.as_ptr() as u32, GRASS_TEX.len() as u32);
    let jump = load_zsound(JUMP_SFX.as_ptr() as u32, JUMP_SFX.len() as u32);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// FFI declarations
EWZX_IMPORT uint32_t load_zmesh(uint32_t data_ptr, uint32_t data_len);
EWZX_IMPORT uint32_t load_ztex(uint32_t data_ptr, uint32_t data_len);
EWZX_IMPORT uint32_t load_zsound(uint32_t data_ptr, uint32_t data_len);

// Embed assets at compile time (platform-specific)
extern const unsigned char player_ewzmesh_data[];
extern const unsigned int player_ewzmesh_size;
extern const unsigned char grass_ewztex_data[];
extern const unsigned int grass_ewztex_size;
extern const unsigned char jump_ewzsnd_data[];
extern const unsigned int jump_ewzsnd_size;

EWZX_EXPORT void init(void) {
    uint32_t player = load_zmesh((uint32_t)player_ewzmesh_data, player_ewzmesh_size);
    uint32_t grass = load_ztex((uint32_t)grass_ewztex_data, grass_ewztex_size);
    uint32_t jump = load_zsound((uint32_t)jump_ewzsnd_data, jump_ewzsnd_size);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// FFI declarations
pub extern fn load_zmesh(data_ptr: u32, data_len: u32) u32;
pub extern fn load_ztex(data_ptr: u32, data_len: u32) u32;
pub extern fn load_zsound(data_ptr: u32, data_len: u32) u32;

// Embed assets at compile time
const player_mesh = @embedFile("assets/player.ewzmesh");
const grass_tex = @embedFile("assets/grass.ewztex");
const jump_sfx = @embedFile("assets/jump.ewzsnd");

export fn init() void {
    const player = load_zmesh(@intFromPtr(player_mesh.ptr), player_mesh.len);
    const grass = load_ztex(@intFromPtr(grass_tex.ptr), grass_tex.len);
    const jump = load_zsound(@intFromPtr(jump_sfx.ptr), jump_sfx.len);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="raw-data-loading-advanced"><a class="header" href="#raw-data-loading-advanced">Raw Data Loading (Advanced)</a></h3>
<p>For fine-grained control, you can bypass the NetherZ format and provide raw data directly:</p>
<p><strong>Convenience API</strong> (f32 input, auto-packed):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn load_mesh(data_ptr: u32, vertex_count: u32, format: u8) -&gt; u32;
    fn load_mesh_indexed(data_ptr: u32, vertex_count: u32, index_ptr: u32, index_count: u32, format: u8) -&gt; u32;
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh(uint32_t data_ptr, uint32_t vertex_count, uint8_t format);
EWZX_IMPORT uint32_t load_mesh_indexed(uint32_t data_ptr, uint32_t vertex_count, uint32_t index_ptr, uint32_t index_count, uint8_t format);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh(data_ptr: u32, vertex_count: u32, format: u8) u32;
pub extern fn load_mesh_indexed(data_ptr: u32, vertex_count: u32, index_ptr: u32, index_count: u32, format: u8) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Power User API</strong> (pre-packed data):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>extern "C" {
    fn load_mesh_packed(data_ptr: u32, vertex_count: u32, format: u8) -&gt; u32;
    fn load_mesh_indexed_packed(data_ptr: u32, vertex_count: u32, index_ptr: u32, index_count: u32, format: u8) -&gt; u32;
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh_packed(uint32_t data_ptr, uint32_t vertex_count, uint8_t format);
EWZX_IMPORT uint32_t load_mesh_indexed_packed(uint32_t data_ptr, uint32_t vertex_count, uint32_t index_ptr, uint32_t index_count, uint8_t format);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh_packed(data_ptr: u32, vertex_count: u32, format: u8) u32;
pub extern fn load_mesh_indexed_packed(data_ptr: u32, vertex_count: u32, index_ptr: u32, index_count: u32, format: u8) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="constraints"><a class="header" href="#constraints">Constraints</a></h2>
<p>Nethercore enforces these limits:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Resource</th><th>Limit</th></tr>
</thead>
<tbody>
<tr><td>ROM size</td><td>12 MB</td></tr>
<tr><td>VRAM</td><td>4 MB</td></tr>
<tr><td>Bones per skeleton</td><td>256</td></tr>
</tbody>
</table>
</div>
<p>All assets are embedded in the WASM binary at compile time. There is no runtime asset loading - this ensures deterministic builds required for rollback netcode.</p>
<hr>
<h2 id="starter-assets"><a class="header" href="#starter-assets">Starter Assets</a></h2>
<p>Don’t have assets yet? Here are some ready-to-use procedural assets you can copy directly into your game.</p>
<h3 id="procedural-textures"><a class="header" href="#procedural-textures">Procedural Textures</a></h3>
<p><strong>Checkerboard (8x8)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const CHECKERBOARD: [u8; 256] = {
    let mut pixels = [0u8; 256];
    let white = [0xFF, 0xFF, 0xFF, 0xFF];
    let gray = [0x88, 0x88, 0x88, 0xFF];
    let mut y = 0;
    while y &lt; 8 {
        let mut x = 0;
        while x &lt; 8 {
            let idx = (y * 8 + x) * 4;
            let color = if (x + y) % 2 == 0 { white } else { gray };
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
            x += 1;
        }
        y += 1;
    }
    pixels
};
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static const uint8_t CHECKERBOARD[256] = {
    0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,
    0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,
    0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,
    0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,
    0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,
    0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,  0x88, 0x88, 0x88, 0xFF,  0xFF, 0xFF, 0xFF, 0xFF,
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const CHECKERBOARD: [256]u8 = blk: {
    var pixels: [256]u8 = undefined;
    const white = [4]u8{ 0xFF, 0xFF, 0xFF, 0xFF };
    const gray = [4]u8{ 0x88, 0x88, 0x88, 0xFF };
    var y: usize = 0;
    while (y &lt; 8) : (y += 1) {
        var x: usize = 0;
        while (x &lt; 8) : (x += 1) {
            const idx = (y * 8 + x) * 4;
            const color = if ((x + y) % 2 == 0) white else gray;
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
        }
    }
    break :blk pixels;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Player Sprite (8x8)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const PLAYER_SPRITE: [u8; 256] = {
    let mut pixels = [0u8; 256];
    let white = [0xFF, 0xFF, 0xFF, 0xFF];
    let trans = [0x00, 0x00, 0x00, 0x00];
    let pattern: [[u8; 8]; 8] = [
        [0, 0, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [0, 0, 1, 0, 0, 1, 0, 0],
        [0, 0, 1, 0, 0, 1, 0, 0],
    ];
    let mut y = 0;
    while y &lt; 8 {
        let mut x = 0;
        while x &lt; 8 {
            let idx = (y * 8 + x) * 4;
            let color = if pattern[y][x] == 1 { white } else { trans };
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
            x += 1;
        }
        y += 1;
    }
    pixels
};
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static void generate_player_sprite(uint8_t pixels[256]) {
    const uint8_t white[4] = {0xFF, 0xFF, 0xFF, 0xFF};
    const uint8_t trans[4] = {0x00, 0x00, 0x00, 0x00};
    const uint8_t pattern[8][8] = {
        {0, 0, 1, 1, 1, 1, 0, 0},
        {0, 1, 1, 1, 1, 1, 1, 0},
        {0, 1, 1, 1, 1, 1, 1, 0},
        {0, 0, 1, 1, 1, 1, 0, 0},
        {0, 1, 1, 1, 1, 1, 1, 0},
        {1, 1, 1, 1, 1, 1, 1, 1},
        {0, 0, 1, 0, 0, 1, 0, 0},
        {0, 0, 1, 0, 0, 1, 0, 0},
    };
    for (int y = 0; y &lt; 8; y++) {
        for (int x = 0; x &lt; 8; x++) {
            int idx = (y * 8 + x) * 4;
            const uint8_t *color = pattern[y][x] == 1 ? white : trans;
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const PLAYER_SPRITE: [256]u8 = blk: {
    var pixels: [256]u8 = undefined;
    const white = [4]u8{ 0xFF, 0xFF, 0xFF, 0xFF };
    const trans = [4]u8{ 0x00, 0x00, 0x00, 0x00 };
    const pattern = [8][8]u8{
        .{ 0, 0, 1, 1, 1, 1, 0, 0 },
        .{ 0, 1, 1, 1, 1, 1, 1, 0 },
        .{ 0, 1, 1, 1, 1, 1, 1, 0 },
        .{ 0, 0, 1, 1, 1, 1, 0, 0 },
        .{ 0, 1, 1, 1, 1, 1, 1, 0 },
        .{ 1, 1, 1, 1, 1, 1, 1, 1 },
        .{ 0, 0, 1, 0, 0, 1, 0, 0 },
        .{ 0, 0, 1, 0, 0, 1, 0, 0 },
    };
    var y: usize = 0;
    while (y &lt; 8) : (y += 1) {
        var x: usize = 0;
        while (x &lt; 8) : (x += 1) {
            const idx = (y * 8 + x) * 4;
            const color = if (pattern[y][x] == 1) white else trans;
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
        }
    }
    break :blk pixels;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Coin/Collectible (8x8)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const COIN_SPRITE: [u8; 256] = {
    let mut pixels = [0u8; 256];
    let gold = [0xFF, 0xD7, 0x00, 0xFF];
    let shine = [0xFF, 0xFF, 0x88, 0xFF];
    let trans = [0x00, 0x00, 0x00, 0x00];
    let pattern: [[u8; 8]; 8] = [
        [0, 0, 1, 1, 1, 1, 0, 0],
        [0, 1, 2, 2, 1, 1, 1, 0],
        [1, 2, 2, 1, 1, 1, 1, 1],
        [1, 2, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [1, 1, 1, 1, 1, 1, 1, 1],
        [0, 1, 1, 1, 1, 1, 1, 0],
        [0, 0, 1, 1, 1, 1, 0, 0],
    ];
    let mut y = 0;
    while y &lt; 8 {
        let mut x = 0;
        while x &lt; 8 {
            let idx = (y * 8 + x) * 4;
            let color = match pattern[y][x] {
                0 =&gt; trans, 1 =&gt; gold, _ =&gt; shine,
            };
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
            x += 1;
        }
        y += 1;
    }
    pixels
};
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static void generate_coin_sprite(uint8_t pixels[256]) {
    const uint8_t gold[4] = {0xFF, 0xD7, 0x00, 0xFF};
    const uint8_t shine[4] = {0xFF, 0xFF, 0x88, 0xFF};
    const uint8_t trans[4] = {0x00, 0x00, 0x00, 0x00};
    const uint8_t pattern[8][8] = {
        {0, 0, 1, 1, 1, 1, 0, 0},
        {0, 1, 2, 2, 1, 1, 1, 0},
        {1, 2, 2, 1, 1, 1, 1, 1},
        {1, 2, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1},
        {1, 1, 1, 1, 1, 1, 1, 1},
        {0, 1, 1, 1, 1, 1, 1, 0},
        {0, 0, 1, 1, 1, 1, 0, 0},
    };
    for (int y = 0; y &lt; 8; y++) {
        for (int x = 0; x &lt; 8; x++) {
            int idx = (y * 8 + x) * 4;
            const uint8_t *color = (pattern[y][x] == 0) ? trans : (pattern[y][x] == 1) ? gold : shine;
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const COIN_SPRITE: [256]u8 = blk: {
    var pixels: [256]u8 = undefined;
    const gold = [4]u8{ 0xFF, 0xD7, 0x00, 0xFF };
    const shine = [4]u8{ 0xFF, 0xFF, 0x88, 0xFF };
    const trans = [4]u8{ 0x00, 0x00, 0x00, 0x00 };
    const pattern = [8][8]u8{
        .{ 0, 0, 1, 1, 1, 1, 0, 0 },
        .{ 0, 1, 2, 2, 1, 1, 1, 0 },
        .{ 1, 2, 2, 1, 1, 1, 1, 1 },
        .{ 1, 2, 1, 1, 1, 1, 1, 1 },
        .{ 1, 1, 1, 1, 1, 1, 1, 1 },
        .{ 1, 1, 1, 1, 1, 1, 1, 1 },
        .{ 0, 1, 1, 1, 1, 1, 1, 0 },
        .{ 0, 0, 1, 1, 1, 1, 0, 0 },
    };
    var y: usize = 0;
    while (y &lt; 8) : (y += 1) {
        var x: usize = 0;
        while (x &lt; 8) : (x += 1) {
            const idx = (y * 8 + x) * 4;
            const color = if (pattern[y][x] == 0) trans else if (pattern[y][x] == 1) gold else shine;
            pixels[idx] = color[0];
            pixels[idx + 1] = color[1];
            pixels[idx + 2] = color[2];
            pixels[idx + 3] = color[3];
        }
    }
    break :blk pixels;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="procedural-sounds"><a class="header" href="#procedural-sounds">Procedural Sounds</a></h3>
<p><strong>Beep (short hit sound)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_beep() -&gt; [i16; 2205] {
    let mut samples = [0i16; 2205]; // 0.1 sec @ 22050 Hz
    for i in 0..2205 {
        let t = i as f32 / 22050.0;
        let envelope = 1.0 - (i as f32 / 2205.0);
        let value = libm::sinf(2.0 * core::f32::consts::PI * 440.0 * t) * envelope;
        samples[i] = (value * 32767.0 * 0.3) as i16;
    }
    samples
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;math.h&gt;

void generate_beep(int16_t samples[2205]) {
    for (int i = 0; i &lt; 2205; i++) {
        float t = (float)i / 22050.0f;
        float envelope = 1.0f - ((float)i / 2205.0f);
        float value = sinf(2.0f * 3.14159265f * 440.0f * t) * envelope;
        samples[i] = (int16_t)(value * 32767.0f * 0.3f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn generate_beep() [2205]i16 {
    var samples: [2205]i16 = undefined;
    for (0..2205) |i| {
        const t = @as(f32, @floatFromInt(i)) / 22050.0;
        const envelope = 1.0 - (@as(f32, @floatFromInt(i)) / 2205.0);
        const value = @sin(2.0 * std.math.pi * 440.0 * t) * envelope;
        samples[i] = @intFromFloat(value * 32767.0 * 0.3);
    }
    return samples;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Jump sound (ascending)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_jump() -&gt; [i16; 4410] {
    let mut samples = [0i16; 4410]; // 0.2 sec
    for i in 0..4410 {
        let t = i as f32 / 22050.0;
        let progress = i as f32 / 4410.0;
        let freq = 200.0 + (400.0 * progress); // 200 → 600 Hz
        let envelope = 1.0 - progress;
        let value = libm::sinf(2.0 * core::f32::consts::PI * freq * t) * envelope;
        samples[i] = (value * 32767.0 * 0.3) as i16;
    }
    samples
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void generate_jump(int16_t samples[4410]) {
    for (int i = 0; i &lt; 4410; i++) {
        float t = (float)i / 22050.0f;
        float progress = (float)i / 4410.0f;
        float freq = 200.0f + (400.0f * progress); // 200 → 600 Hz
        float envelope = 1.0f - progress;
        float value = sinf(2.0f * 3.14159265f * freq * t) * envelope;
        samples[i] = (int16_t)(value * 32767.0f * 0.3f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn generate_jump() [4410]i16 {
    var samples: [4410]i16 = undefined;
    for (0..4410) |i| {
        const t = @as(f32, @floatFromInt(i)) / 22050.0;
        const progress = @as(f32, @floatFromInt(i)) / 4410.0;
        const freq = 200.0 + (400.0 * progress); // 200 → 600 Hz
        const envelope = 1.0 - progress;
        const value = @sin(2.0 * std.math.pi * freq * t) * envelope;
        samples[i] = @intFromFloat(value * 32767.0 * 0.3);
    }
    return samples;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Coin collect (sparkle)</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_collect() -&gt; [i16; 6615] {
    let mut samples = [0i16; 6615]; // 0.3 sec
    for i in 0..6615 {
        let t = i as f32 / 22050.0;
        let progress = i as f32 / 6615.0;
        // Two frequencies for shimmer effect
        let f1 = 880.0;
        let f2 = 1320.0; // Perfect fifth
        let envelope = 1.0 - progress;
        let v1 = libm::sinf(2.0 * core::f32::consts::PI * f1 * t);
        let v2 = libm::sinf(2.0 * core::f32::consts::PI * f2 * t);
        let value = (v1 + v2 * 0.5) * envelope;
        samples[i] = (value * 32767.0 * 0.2) as i16;
    }
    samples
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void generate_collect(int16_t samples[6615]) {
    for (int i = 0; i &lt; 6615; i++) {
        float t = (float)i / 22050.0f;
        float progress = (float)i / 6615.0f;
        // Two frequencies for shimmer effect
        float f1 = 880.0f;
        float f2 = 1320.0f; // Perfect fifth
        float envelope = 1.0f - progress;
        float v1 = sinf(2.0f * 3.14159265f * f1 * t);
        float v2 = sinf(2.0f * 3.14159265f * f2 * t);
        float value = (v1 + v2 * 0.5f) * envelope;
        samples[i] = (int16_t)(value * 32767.0f * 0.2f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn generate_collect() [6615]i16 {
    var samples: [6615]i16 = undefined;
    for (0..6615) |i| {
        const t = @as(f32, @floatFromInt(i)) / 22050.0;
        const progress = @as(f32, @floatFromInt(i)) / 6615.0;
        // Two frequencies for shimmer effect
        const f1 = 880.0;
        const f2 = 1320.0; // Perfect fifth
        const envelope = 1.0 - progress;
        const v1 = @sin(2.0 * std.math.pi * f1 * t);
        const v2 = @sin(2.0 * std.math.pi * f2 * t);
        const value = (v1 + v2 * 0.5) * envelope;
        samples[i] = @intFromFloat(value * 32767.0 * 0.2);
    }
    return samples;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="using-starter-assets"><a class="header" href="#using-starter-assets">Using Starter Assets</a></h3>
<p>Load procedural assets in your <code>init()</code>:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PLAYER_TEX: u32 = 0;
static mut JUMP_SFX: u32 = 0;

#[no_mangle]
pub extern "C" fn init() {
    unsafe {
        // Load texture
        PLAYER_TEX = load_texture(8, 8, PLAYER_SPRITE.as_ptr());
        texture_filter(0); // Nearest-neighbor for crisp pixels

        // Load sound
        let jump = generate_jump();
        JUMP_SFX = load_sound(jump.as_ptr(), (jump.len() * 2) as u32);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t PLAYER_TEX = 0;
static uint32_t JUMP_SFX = 0;

EWZX_EXPORT void init(void) {
    // Load texture
    uint8_t player_sprite[256];
    generate_player_sprite(player_sprite);
    PLAYER_TEX = load_texture(8, 8, (uint32_t)player_sprite);
    texture_filter(0); // Nearest-neighbor for crisp pixels

    // Load sound
    int16_t jump[4410];
    generate_jump(jump);
    JUMP_SFX = load_sound((uint32_t)jump, sizeof(jump));
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var PLAYER_TEX: u32 = 0;
var JUMP_SFX: u32 = 0;

export fn init() void {
    // Load texture
    PLAYER_TEX = load_texture(8, 8, @intFromPtr(&amp;PLAYER_SPRITE));
    texture_filter(0); // Nearest-neighbor for crisp pixels

    // Load sound
    const jump = generate_jump();
    JUMP_SFX = load_sound(@intFromPtr(&amp;jump), jump.len * 2);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="nethertoml-vs-include_bytes"><a class="header" href="#nethertoml-vs-include_bytes">nether.toml vs include_bytes!()</a></h2>
<p>There are two ways to include assets in your game:</p>
<h3 id="method-1-nethertoml--rom-packing"><a class="header" href="#method-1-nethertoml--rom-packing">Method 1: nether.toml + ROM Packing</a></h3>
<p>Best for: Production games with many assets</p>
<pre><code class="language-toml"># nether.toml
[game]
id = "my-game"
title = "My Game"

[[assets.textures]]
id = "player"
path = "assets/player.png"

[[assets.sounds]]
id = "jump"
path = "assets/jump.wav"
</code></pre>
<p>Load with ROM functions:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let player_tex = rom_texture(b"player".as_ptr(), 6);
let jump_sfx = rom_sound(b"jump".as_ptr(), 4);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t player_tex = rom_texture((uint32_t)"player", 6);
uint32_t jump_sfx = rom_sound((uint32_t)"jump", 4);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const player_tex = rom_texture(@intFromPtr("player".ptr), 6);
const jump_sfx = rom_sound(@intFromPtr("jump".ptr), 4);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Benefits:</p>
<ul>
<li>Assets are pre-processed and compressed</li>
<li>Single <code>.nczx</code> ROM file</li>
<li>Automatic GPU format conversion</li>
</ul>
<h3 id="method-2-include_bytes--procedural"><a class="header" href="#method-2-include_bytes--procedural">Method 2: include_bytes!() + Procedural</a></h3>
<p>Best for: Small games, prototyping, tutorials</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Compile-time embedding
static TEXTURE_DATA: &amp;[u8] = include_bytes!("../assets/player.ewztex");

// Or generate at runtime
const PIXELS: [u8; 256] = generate_pixels();
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Compile-time embedding (platform-specific)
extern const unsigned char player_ewztex_data[];
extern const unsigned int player_ewztex_size;

// Or generate at runtime
uint8_t pixels[256];
generate_pixels(pixels);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Compile-time embedding
const texture_data = @embedFile("../assets/player.ewztex");

// Or generate at runtime
const pixels: [256]u8 = generate_pixels();
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Benefits:</p>
<ul>
<li>Simple, no build step</li>
<li>Good for procedural content</li>
<li>Self-contained WASM file</li>
</ul>
<h3 id="which-should-i-use"><a class="header" href="#which-should-i-use">Which Should I Use?</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Scenario</th><th>Recommendation</th></tr>
</thead>
<tbody>
<tr><td>Learning/prototyping</td><td>include_bytes!() or procedural</td></tr>
<tr><td>Simple arcade games</td><td>Either works</td></tr>
<tr><td>Complex games with many assets</td><td>nether.toml + ROM</td></tr>
<tr><td>Games with large textures</td><td>nether.toml (compression)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="planned-features"><a class="header" href="#planned-features">Planned Features</a></h2>
<p>The following features are planned but not yet implemented:</p>
<ul>
<li><strong>Font conversion</strong> - TTF/OTF to bitmap font atlas (.ewzfont)</li>
<li><strong>Watch mode</strong> - <code>nether-export build --watch</code> for auto-rebuild on changes</li>
<li><strong>Rust code generation</strong> - Auto-generated asset loading module</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="publishing-your-game"><a class="header" href="#publishing-your-game">Publishing Your Game</a></h1>
<p>This guide covers everything you need to know about packaging and publishing your Nethercore game.</p>
<h2 id="overview-1"><a class="header" href="#overview-1">Overview</a></h2>
<p>The publishing process:</p>
<ol>
<li><strong>Build</strong> your game (compile to WASM)</li>
<li><strong>Pack</strong> assets into a ROM file (optional)</li>
<li><strong>Test</strong> the final build</li>
<li><strong>Upload</strong> to nethercore.systems</li>
<li><strong>Share</strong> with the world</li>
</ol>
<h2 id="building-for-release"><a class="header" href="#building-for-release">Building for Release</a></h2>
<h3 id="using-nether-cli-recommended"><a class="header" href="#using-nether-cli-recommended">Using nether-cli (Recommended)</a></h3>
<p>The nether CLI handles compilation and packaging:</p>
<pre><code class="language-bash"># Build WASM
nether build

# Package into ROM
nether pack

# Or do both
nether build &amp;&amp; nether pack
</code></pre>
<h3 id="manual-build"><a class="header" href="#manual-build">Manual Build</a></h3>
<p>If you prefer manual control:</p>
<pre><code class="language-bash"># Build optimized WASM
cargo build --target wasm32-unknown-unknown --release

# Your WASM file
ls target/wasm32-unknown-unknown/release/your_game.wasm
</code></pre>
<h2 id="game-manifest-nethertoml"><a class="header" href="#game-manifest-nethertoml">Game Manifest (nether.toml)</a></h2>
<p>Create <code>nether.toml</code> in your project root:</p>
<pre><code class="language-toml">[game]
id = "my-game"              # Unique identifier (lowercase, hyphens ok)
title = "My Game"           # Display name
author = "Your Name"        # Creator credit
version = "1.0.0"           # Semantic version
description = "A fun game"  # Short description

[build]
script = "cargo build --target wasm32-unknown-unknown --release"
wasm = "target/wasm32-unknown-unknown/release/my_game.wasm"

# Optional: Assets to include in ROM
[[assets.textures]]
id = "player"
path = "assets/player.png"

[[assets.meshes]]
id = "level"
path = "assets/level.ewzmesh"

[[assets.sounds]]
id = "jump"
path = "assets/jump.wav"
</code></pre>
<h2 id="rom-file-format"><a class="header" href="#rom-file-format">ROM File Format</a></h2>
<p>Nethercore ROMs (<code>.nczx</code> files) bundle:</p>
<ul>
<li>Your compiled WASM game</li>
<li>Pre-processed assets (textures, meshes, sounds)</li>
<li>Game metadata</li>
</ul>
<p>Benefits of ROM packaging:</p>
<ul>
<li><strong>Faster loading</strong> - Assets are already GPU-ready</li>
<li><strong>Single file</strong> - Easy to distribute</li>
<li><strong>Verified</strong> - Content integrity checked</li>
</ul>
<h2 id="testing-your-build"><a class="header" href="#testing-your-build">Testing Your Build</a></h2>
<p>Always test the final build:</p>
<pre><code class="language-bash"># Test the WASM directly
nether run target/wasm32-unknown-unknown/release/my_game.wasm

# Or test the packed ROM
nether run my_game.nczx
</code></pre>
<p>Verify:</p>
<ul>
<li>Game starts correctly</li>
<li>All assets load</li>
<li>No console errors</li>
<li>Multiplayer works (test with two controllers)</li>
</ul>
<h2 id="upload-requirements"><a class="header" href="#upload-requirements">Upload Requirements</a></h2>
<h3 id="required-files"><a class="header" href="#required-files">Required Files</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Format</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Game</td><td><code>.wasm</code> or <code>.nczx</code></td><td>Your compiled game</td></tr>
<tr><td>Icon</td><td>64×64 PNG</td><td>Library thumbnail</td></tr>
</tbody>
</table>
</div>
<h3 id="optional-files"><a class="header" href="#optional-files">Optional Files</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>File</th><th>Format</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>Screenshots</td><td>PNG</td><td>Game page gallery (up to 5)</td></tr>
<tr><td>Banner</td><td>1280×720 PNG</td><td>Featured games banner</td></tr>
</tbody>
</table>
</div>
<h3 id="metadata"><a class="header" href="#metadata">Metadata</a></h3>
<ul>
<li><strong>Title</strong> - Your game’s name</li>
<li><strong>Description</strong> - What your game is about (Markdown supported)</li>
<li><strong>Category</strong> - Arcade, Puzzle, Action, etc.</li>
<li><strong>Tags</strong> - Searchable keywords</li>
</ul>
<h2 id="publishing-process"><a class="header" href="#publishing-process">Publishing Process</a></h2>
<h3 id="1-create-developer-account"><a class="header" href="#1-create-developer-account">1. Create Developer Account</a></h3>
<p>Visit <a href="https://nethercore.systems/register">nethercore.systems/register</a></p>
<h3 id="2-access-dashboard"><a class="header" href="#2-access-dashboard">2. Access Dashboard</a></h3>
<p>Log in and go to <a href="https://nethercore.systems/dashboard">nethercore.systems/dashboard</a></p>
<h3 id="3-upload-game"><a class="header" href="#3-upload-game">3. Upload Game</a></h3>
<ol>
<li>Click “Upload New Game”</li>
<li>Fill in title and description</li>
<li>Select category and tags</li>
<li>Upload your game file</li>
<li>Upload icon (required) and screenshots (optional)</li>
<li>Click “Publish”</li>
</ol>
<h3 id="4-game-page"><a class="header" href="#4-game-page">4. Game Page</a></h3>
<p>Your game gets a public page:</p>
<pre><code>nethercore.systems/game/your-game-id
</code></pre>
<h2 id="updating-your-game"><a class="header" href="#updating-your-game">Updating Your Game</a></h2>
<p>To release an update:</p>
<ol>
<li>Bump version in <code>nether.toml</code></li>
<li>Build and test new version</li>
<li>Go to Dashboard → Your Game → Edit</li>
<li>Upload new game file</li>
<li>Update version number</li>
<li>Save changes</li>
</ol>
<p>Players with old versions will be prompted to update.</p>
<h2 id="content-guidelines"><a class="header" href="#content-guidelines">Content Guidelines</a></h2>
<p>Games must:</p>
<ul>
<li>Be appropriate for all ages</li>
<li>Not contain malware or harmful code</li>
<li>Not violate copyright</li>
<li>Actually be playable</li>
</ul>
<p>Games must NOT:</p>
<ul>
<li>Contain excessive violence or adult content</li>
<li>Harvest user data</li>
<li>Attempt to break out of the sandbox</li>
<li>Impersonate other developers’ games</li>
</ul>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="wasm-validation-failed"><a class="header" href="#wasm-validation-failed">“WASM validation failed”</a></h3>
<p>Your WASM file may be corrupted or built incorrectly.</p>
<p>Fix:</p>
<pre><code class="language-bash"># Clean build
cargo clean
cargo build --target wasm32-unknown-unknown --release
</code></pre>
<h3 id="asset-not-found"><a class="header" href="#asset-not-found">“Asset not found”</a></h3>
<p>Asset paths in <code>nether.toml</code> are relative to the project root.</p>
<p>Verify:</p>
<pre><code class="language-bash"># Check if file exists
ls assets/player.png
</code></pre>
<h3 id="rom-too-large"><a class="header" href="#rom-too-large">“ROM too large”</a></h3>
<p>Nethercore has size limits for fair distribution.</p>
<p>Reduce size:</p>
<ul>
<li>Compress textures</li>
<li>Use smaller audio sample rates</li>
<li>Remove unused assets</li>
</ul>
<h3 id="game-crashes-on-load"><a class="header" href="#game-crashes-on-load">“Game crashes on load”</a></h3>
<p>Usually a panic in <code>init()</code>.</p>
<p>Debug:</p>
<ol>
<li>Test locally first</li>
<li>Check console for error messages</li>
<li>Simplify <code>init()</code> to isolate the issue</li>
</ol>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<ol>
<li><strong>Test thoroughly</strong> before publishing</li>
<li><strong>Write a good description</strong> - help players find your game</li>
<li><strong>Create an appealing icon</strong> - first impressions matter</li>
<li><strong>Include screenshots</strong> - show off your game</li>
<li><strong>Respond to feedback</strong> - engage with players</li>
<li><strong>Update regularly</strong> - fix bugs, add features</li>
</ol>
<h2 id="distribution-alternatives"><a class="header" href="#distribution-alternatives">Distribution Alternatives</a></h2>
<p>Besides nethercore.systems, you can distribute:</p>
<h3 id="direct-download"><a class="header" href="#direct-download">Direct Download</a></h3>
<p>Share the <code>.wasm</code> or <code>.nczx</code> file directly. Players load it in the Nethercore player.</p>
<h3 id="github-releases"><a class="header" href="#github-releases">GitHub Releases</a></h3>
<p>Host on GitHub as release artifacts.</p>
<h3 id="itchio"><a class="header" href="#itchio">itch.io</a></h3>
<p>Upload as a downloadable file with instructions.</p>
<hr>
<p>Ready to publish? Head to <a href="https://nethercore.systems">nethercore.systems</a> and share your creation with the world!</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="cheat-sheet"><a class="header" href="#cheat-sheet">Cheat Sheet</a></h1>
<p>All Nethercore ZX FFI functions on one page.</p>
<hr>
<h2 id="system"><a class="header" href="#system">System</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>delta_time() -&gt; f32                    // Seconds since last tick
elapsed_time() -&gt; f32                  // Total seconds since start
tick_count() -&gt; u64                    // Current tick number
log(ptr, len)                          // Log message to console
quit()                                 // Exit to library
random() -&gt; u32                        // Deterministic random
player_count() -&gt; u32                  // Number of players (1-4)
local_player_mask() -&gt; u32             // Bitmask of local players
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">float delta_time(void);                // Seconds since last tick
float elapsed_time(void);              // Total seconds since start
uint64_t tick_count(void);             // Current tick number
void log_msg(ptr, len);                // Log message to console
void quit(void);                       // Exit to library
uint32_t random_u32(void);             // Deterministic random
uint32_t player_count(void);           // Number of players (1-4)
uint32_t local_player_mask(void);      // Bitmask of local players
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">delta_time() f32                       // Seconds since last tick
elapsed_time() f32                     // Total seconds since start
tick_count() u64                       // Current tick number
log_msg(ptr, len) void                 // Log message to console
quit() void                            // Exit to library
random_u32() u32                       // Deterministic random
player_count() u32                     // Number of players (1-4)
local_player_mask() u32                // Bitmask of local players
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="configuration-init-only"><a class="header" href="#configuration-init-only">Configuration (Init-Only)</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_tick_rate(fps)                     // 0=24, 1=30, 2=60, 3=120
set_clear_color(0xRRGGBBAA)            // Background color
render_mode(mode)                      // 0=Unlit, 1=Matcap, 2=MR, 3=SS
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void set_tick_rate(uint32_t fps);      // EWZX_TICK_RATE_24/30/60/120
void set_clear_color(uint32_t color);  // Background color
void render_mode(uint32_t mode);       // EWZX_RENDER_LAMBERT/MATCAP/PBR/HYBRID
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">set_tick_rate(fps: u32) void           // 0=24, 1=30, 2=60, 3=120
set_clear_color(color: u32) void       // Background color
render_mode(mode: u32) void            // 0=Unlit, 1=Matcap, 2=MR, 3=SS
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="input"><a class="header" href="#input">Input</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Buttons (player: 0-3, button: 0-13)
button_held(player, button) -&gt; u32     // 1 if held
button_pressed(player, button) -&gt; u32  // 1 if just pressed
button_released(player, button) -&gt; u32 // 1 if just released
buttons_held(player) -&gt; u32            // Bitmask of held
buttons_pressed(player) -&gt; u32         // Bitmask of pressed
buttons_released(player) -&gt; u32        // Bitmask of released

// Sticks (-1.0 to 1.0)
left_stick_x(player) -&gt; f32
left_stick_y(player) -&gt; f32
right_stick_x(player) -&gt; f32
right_stick_y(player) -&gt; f32
left_stick(player, &amp;mut x, &amp;mut y)     // Both axes
right_stick(player, &amp;mut x, &amp;mut y)

// Triggers (0.0 to 1.0)
trigger_left(player) -&gt; f32
trigger_right(player) -&gt; f32
<span class="boring">}</span></code></pre>
<p><strong>Button Constants:</strong> UP=0, DOWN=1, LEFT=2, RIGHT=3, A=4, B=5, X=6, Y=7, LB=8, RB=9, L3=10, R3=11, START=12, SELECT=13
{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Buttons (player: 0-3, button: EWZX_BUTTON_*)
uint32_t button_held(player, button);     // 1 if held
uint32_t button_pressed(player, button);  // 1 if just pressed
uint32_t button_released(player, button); // 1 if just released
uint32_t buttons_held(player);            // Bitmask of held
uint32_t buttons_pressed(player);         // Bitmask of pressed
uint32_t buttons_released(player);        // Bitmask of released

// Sticks (-1.0 to 1.0)
float left_stick_x(player);
float left_stick_y(player);
float right_stick_x(player);
float right_stick_y(player);
void left_stick(player, float* x, float* y);   // Both axes
void right_stick(player, float* x, float* y);

// Triggers (0.0 to 1.0)
float trigger_left(player);
float trigger_right(player);
</code></pre>
<p><strong>Button Constants:</strong> <code>EWZX_BUTTON_UP</code>=0, <code>EWZX_BUTTON_DOWN</code>=1, <code>EWZX_BUTTON_LEFT</code>=2, <code>EWZX_BUTTON_RIGHT</code>=3, <code>EWZX_BUTTON_A</code>=4, <code>EWZX_BUTTON_B</code>=5, <code>EWZX_BUTTON_X</code>=6, <code>EWZX_BUTTON_Y</code>=7, <code>EWZX_BUTTON_L1</code>=8, <code>EWZX_BUTTON_R1</code>=9, <code>EWZX_BUTTON_L3</code>=10, <code>EWZX_BUTTON_R3</code>=11, <code>EWZX_BUTTON_START</code>=12, <code>EWZX_BUTTON_SELECT</code>=13
{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Buttons (player: 0-3, button: Button.*)
button_held(player: u32, button: u32) u32     // 1 if held
button_pressed(player: u32, button: u32) u32  // 1 if just pressed
button_released(player: u32, button: u32) u32 // 1 if just released
buttons_held(player: u32) u32                 // Bitmask of held
buttons_pressed(player: u32) u32              // Bitmask of pressed
buttons_released(player: u32) u32             // Bitmask of released

// Sticks (-1.0 to 1.0)
left_stick_x(player: u32) f32
left_stick_y(player: u32) f32
right_stick_x(player: u32) f32
right_stick_y(player: u32) f32
left_stick(player: u32, x: *f32, y: *f32) void  // Both axes
right_stick(player: u32, x: *f32, y: *f32) void

// Triggers (0.0 to 1.0)
trigger_left(player: u32) f32
trigger_right(player: u32) f32
</code></pre>
<p><strong>Button Constants:</strong> <code>Button.up</code>=0, <code>Button.down</code>=1, <code>Button.left</code>=2, <code>Button.right</code>=3, <code>Button.a</code>=4, <code>Button.b</code>=5, <code>Button.x</code>=6, <code>Button.y</code>=7, <code>Button.l1</code>=8, <code>Button.r1</code>=9, <code>Button.l3</code>=10, <code>Button.r3</code>=11, <code>Button.start</code>=12, <code>Button.select</code>=13
{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="camera"><a class="header" href="#camera">Camera</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>camera_set(x, y, z, target_x, target_y, target_z)
camera_fov(degrees)                    // Default: 60
push_view_matrix(m0..m15)              // Custom 4x4 view matrix
push_projection_matrix(m0..m15)        // Custom 4x4 projection
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void camera_set(x, y, z, target_x, target_y, target_z);
void camera_fov(float degrees);        // Default: 60
void push_view_matrix(m0..m15);        // Custom 4x4 view matrix
void push_projection_matrix(m0..m15);  // Custom 4x4 projection
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">camera_set(x: f32, y: f32, z: f32, target_x: f32, target_y: f32, target_z: f32) void
camera_fov(degrees: f32) void          // Default: 60
// push_view_matrix and push_projection_matrix take 16 f32 parameters
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="transforms"><a class="header" href="#transforms">Transforms</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>push_identity()                        // Reset to identity
transform_set(matrix_ptr)              // Set from 4x4 matrix
push_translate(x, y, z)
push_rotate_x(degrees)
push_rotate_y(degrees)
push_rotate_z(degrees)
push_rotate(degrees, axis_x, axis_y, axis_z)
push_scale(x, y, z)
push_scale_uniform(s)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void push_identity(void);              // Reset to identity
void transform_set(const float* matrix_ptr);  // Set from 4x4 matrix
void push_translate(float x, float y, float z);
void push_rotate_x(float degrees);
void push_rotate_y(float degrees);
void push_rotate_z(float degrees);
void push_rotate(float degrees, float axis_x, float axis_y, float axis_z);
void push_scale(float x, float y, float z);
void push_scale_uniform(float s);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">push_identity() void                   // Reset to identity
transform_set(matrix_ptr: [*]const f32) void  // Set from 4x4 matrix
push_translate(x: f32, y: f32, z: f32) void
push_rotate_x(degrees: f32) void
push_rotate_y(degrees: f32) void
push_rotate_z(degrees: f32) void
push_rotate(degrees: f32, axis_x: f32, axis_y: f32, axis_z: f32) void
push_scale(x: f32, y: f32, z: f32) void
push_scale_uniform(s: f32) void
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="render-state"><a class="header" href="#render-state">Render State</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>set_color(0xRRGGBBAA)                  // Tint color
depth_test(enabled)                    // 0=off, 1=on
cull_mode(mode)                        // 0=none, 1=back, 2=front
blend_mode(mode)                       // 0=none, 1=alpha, 2=add, 3=mul
texture_filter(filter)                 // 0=nearest, 1=linear
uniform_alpha(level)                   // 0-15 dither alpha
dither_offset(x, y)                    // 0-3 pattern offset
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void set_color(uint32_t color);        // Tint color
void depth_test(uint32_t enabled);     // 0=off, 1=on
void cull_mode(uint32_t mode);         // EWZX_CULL_NONE/BACK/FRONT
void blend_mode(uint32_t mode);        // EWZX_BLEND_NONE/ALPHA/ADDITIVE/MULTIPLY
void texture_filter(uint32_t filter);  // 0=nearest, 1=linear
void uniform_alpha(uint32_t level);    // 0-15 dither alpha
void dither_offset(uint32_t x, uint32_t y);  // 0-3 pattern offset
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">set_color(color: u32) void             // Tint color
depth_test(enabled: u32) void          // 0=off, 1=on
cull_mode(mode: u32) void              // CullMode.none/back/front
blend_mode(mode: u32) void             // BlendMode.none/alpha/additive/multiply
texture_filter(filter: u32) void       // 0=nearest, 1=linear
uniform_alpha(level: u32) void         // 0-15 dither alpha
dither_offset(x: u32, y: u32) void     // 0-3 pattern offset
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="textures-1"><a class="header" href="#textures-1">Textures</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_texture(w, h, pixels_ptr) -&gt; u32  // Init-only, returns handle
texture_bind(handle)                   // Bind to slot 0
texture_bind_slot(handle, slot)        // Bind to slot 0-3
matcap_blend_mode(slot, mode)          // 0=mul, 1=add, 2=hsv
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t load_texture(uint32_t w, uint32_t h, const uint8_t* pixels);  // Init-only
void texture_bind(uint32_t handle);    // Bind to slot 0
void texture_bind_slot(uint32_t handle, uint32_t slot);  // Bind to slot 0-3
void matcap_blend_mode(uint32_t slot, uint32_t mode);    // 0=mul, 1=add, 2=hsv
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">load_texture(w: u32, h: u32, pixels: [*]const u8) u32  // Init-only
texture_bind(handle: u32) void         // Bind to slot 0
texture_bind_slot(handle: u32, slot: u32) void  // Bind to slot 0-3
matcap_blend_mode(slot: u32, mode: u32) void    // 0=mul, 1=add, 2=hsv
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="meshes"><a class="header" href="#meshes">Meshes</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Retained (init-only)
load_mesh(data_ptr, vertex_count, format) -&gt; u32
load_mesh_indexed(data_ptr, vcount, idx_ptr, icount, fmt) -&gt; u32
load_mesh_packed(data_ptr, vertex_count, format) -&gt; u32
load_mesh_indexed_packed(data_ptr, vcount, idx_ptr, icount, fmt) -&gt; u32
draw_mesh(handle)

// Immediate
draw_triangles(data_ptr, vertex_count, format)
draw_triangles_indexed(data_ptr, vcount, idx_ptr, icount, fmt)
<span class="boring">}</span></code></pre>
<p><strong>Vertex Formats:</strong> POS=0, UV=1, COLOR=2, UV_COLOR=3, NORMAL=4, UV_NORMAL=5, COLOR_NORMAL=6, UV_COLOR_NORMAL=7, +SKINNED=8
{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Retained (init-only)
uint32_t load_mesh(const float* data, uint32_t vcount, uint32_t fmt);
uint32_t load_mesh_indexed(const float* data, uint32_t vcount,
                           const uint16_t* idx, uint32_t icount, uint32_t fmt);
uint32_t load_mesh_packed(const uint8_t* data, uint32_t vcount, uint32_t fmt);
uint32_t load_mesh_indexed_packed(const uint8_t* data, uint32_t vcount,
                                  const uint16_t* idx, uint32_t icount, uint32_t fmt);
void draw_mesh(uint32_t handle);

// Immediate
void draw_triangles(const float* data, uint32_t vcount, uint32_t fmt);
void draw_triangles_indexed(const float* data, uint32_t vcount,
                            const uint16_t* idx, uint32_t icount, uint32_t fmt);
</code></pre>
<p><strong>Vertex Formats:</strong> <code>EWZX_FORMAT_POS</code>=0, <code>EWZX_FORMAT_UV</code>=1, <code>EWZX_FORMAT_COLOR</code>=2, <code>EWZX_FORMAT_NORMAL</code>=4, <code>EWZX_FORMAT_SKINNED</code>=8 (combinable)
{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Retained (init-only)
load_mesh(data: [*]const f32, vcount: u32, fmt: u32) u32
load_mesh_indexed(data: [*]const f32, vcount: u32, idx: [*]const u16, icount: u32, fmt: u32) u32
draw_mesh(handle: u32) void

// Immediate
draw_triangles(data: [*]const f32, vcount: u32, fmt: u32) void
draw_triangles_indexed(data: [*]const f32, vcount: u32, idx: [*]const u16, icount: u32, fmt: u32) void
</code></pre>
<p><strong>Vertex Formats:</strong> <code>Format.pos</code>=0, <code>Format.uv</code>=1, <code>Format.color</code>=2, <code>Format.normal</code>=4, <code>Format.skinned</code>=8 (combinable)
{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="procedural-meshes-init-only"><a class="header" href="#procedural-meshes-init-only">Procedural Meshes (Init-Only)</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>cube(sx, sy, sz) -&gt; u32
sphere(radius, segments, rings) -&gt; u32
cylinder(r_bot, r_top, height, segments) -&gt; u32
plane(sx, sz, subdiv_x, subdiv_z) -&gt; u32
torus(major_r, minor_r, major_seg, minor_seg) -&gt; u32
capsule(radius, height, segments, rings) -&gt; u32

// With explicit UV naming (same behavior)
cube_uv, sphere_uv, cylinder_uv, plane_uv, torus_uv, capsule_uv
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t cube(float sx, float sy, float sz);
uint32_t sphere(float radius, uint32_t segments, uint32_t rings);
uint32_t cylinder(float r_bot, float r_top, float height, uint32_t segments);
uint32_t plane(float sx, float sz, uint32_t subdiv_x, uint32_t subdiv_z);
uint32_t torus(float major_r, float minor_r, uint32_t major_seg, uint32_t minor_seg);
uint32_t capsule(float radius, float height, uint32_t segments, uint32_t rings);

// With explicit UV naming (same behavior)
cube_uv, sphere_uv, cylinder_uv, plane_uv, torus_uv, capsule_uv
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">cube(sx: f32, sy: f32, sz: f32) u32
sphere(radius: f32, segments: u32, rings: u32) u32
cylinder(r_bot: f32, r_top: f32, height: f32, segments: u32) u32
plane(sx: f32, sz: f32, subdiv_x: u32, subdiv_z: u32) u32
torus(major_r: f32, minor_r: f32, major_seg: u32, minor_seg: u32) u32
capsule(radius: f32, height: f32, segments: u32, rings: u32) u32

// With explicit UV naming (same behavior)
cube_uv, sphere_uv, cylinder_uv, plane_uv, torus_uv, capsule_uv
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="materials"><a class="header" href="#materials">Materials</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Mode 2 (Metallic-Roughness)
material_metallic(value)               // 0.0-1.0
material_roughness(value)              // 0.0-1.0
material_emissive(value)               // Glow intensity
material_rim(intensity, power)         // Rim light
material_albedo(texture)               // Bind to slot 0
material_mre(texture)                  // Bind MRE to slot 1

// Mode 3 (Specular-Shininess)
material_shininess(value)              // 0.0-1.0 → 1-256
material_specular(0xRRGGBBAA)          // Specular color
material_specular_color(r, g, b)       // RGB floats
material_specular_damping(value)

// Override flags
use_uniform_color(enabled)
use_uniform_metallic(enabled)
use_uniform_roughness(enabled)
use_uniform_emissive(enabled)
use_uniform_specular(enabled)
use_matcap_reflection(enabled)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Mode 2 (Metallic-Roughness)
void material_metallic(float value);   // 0.0-1.0
void material_roughness(float value);  // 0.0-1.0
void material_emissive(float value);   // Glow intensity
void material_rim(float intensity, float power);  // Rim light
void material_albedo(uint32_t texture);    // Bind to slot 0
void material_mre(uint32_t texture);       // Bind MRE to slot 1

// Mode 3 (Specular-Shininess)
void material_shininess(float value);  // 0.0-1.0 → 1-256
void material_specular(uint32_t color);    // Specular color
void material_specular_color(float r, float g, float b);
void material_specular_damping(float value);

// Override flags
void use_uniform_color(uint32_t enabled);
void use_uniform_metallic(uint32_t enabled);
void use_uniform_roughness(uint32_t enabled);
void use_uniform_emissive(uint32_t enabled);
void use_uniform_specular(uint32_t enabled);
void use_matcap_reflection(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Mode 2 (Metallic-Roughness)
material_metallic(value: f32) void     // 0.0-1.0
material_roughness(value: f32) void    // 0.0-1.0
material_emissive(value: f32) void     // Glow intensity
material_rim(intensity: f32, power: f32) void  // Rim light
material_albedo(texture: u32) void     // Bind to slot 0
material_mre(texture: u32) void        // Bind MRE to slot 1

// Mode 3 (Specular-Shininess)
material_shininess(value: f32) void    // 0.0-1.0 → 1-256
material_specular(color: u32) void     // Specular color
material_specular_color(r: f32, g: f32, b: f32) void
material_specular_damping(value: f32) void

// Override flags
use_uniform_color(enabled: u32) void
use_uniform_metallic(enabled: u32) void
use_uniform_roughness(enabled: u32) void
use_uniform_emissive(enabled: u32) void
use_uniform_specular(enabled: u32) void
use_matcap_reflection(enabled: u32) void
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="lighting"><a class="header" href="#lighting">Lighting</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Directional lights (index 0-3)
light_set(index, dir_x, dir_y, dir_z)
light_color(index, 0xRRGGBBAA)
light_intensity(index, intensity)      // 0.0-8.0
light_enable(index)
light_disable(index)

// Point lights
light_set_point(index, x, y, z)
light_range(index, range)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Directional lights (index 0-3)
void light_set(uint32_t index, float dir_x, float dir_y, float dir_z);
void light_color(uint32_t index, uint32_t color);
void light_intensity(uint32_t index, float intensity);  // 0.0-8.0
void light_enable(uint32_t index);
void light_disable(uint32_t index);

// Point lights
void light_set_point(uint32_t index, float x, float y, float z);
void light_range(uint32_t index, float range);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Directional lights (index 0-3)
light_set(index: u32, dir_x: f32, dir_y: f32, dir_z: f32) void
light_color(index: u32, color: u32) void
light_intensity(index: u32, intensity: f32) void  // 0.0-8.0
light_enable(index: u32) void
light_disable(index: u32) void

// Point lights
light_set_point(index: u32, x: f32, y: f32, z: f32) void
light_range(index: u32, range: f32) void
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="sky--matcap"><a class="header" href="#sky--matcap">Sky &amp; Matcap</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>sky_set_colors(horizon, zenith)        // 0xRRGGBBAA colors
sky_set_sun(dx, dy, dz, color, sharpness)
draw_sky()                             // Call first in render()
matcap_set(slot, texture)              // Slot 1-3
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void sky_set_colors(uint32_t horizon, uint32_t zenith);
void sky_set_sun(float dx, float dy, float dz, uint32_t color, float sharpness);
void draw_sky(void);                   // Call first in render()
void matcap_set(uint32_t slot, uint32_t texture);  // Slot 1-3
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">sky_set_colors(horizon: u32, zenith: u32) void
sky_set_sun(dx: f32, dy: f32, dz: f32, color: u32, sharpness: f32) void
draw_sky() void                        // Call first in render()
matcap_set(slot: u32, texture: u32) void  // Slot 1-3
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="2d-drawing"><a class="header" href="#2d-drawing">2D Drawing</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>draw_sprite(x, y, w, h, color)
draw_sprite_region(x, y, w, h, src_x, src_y, src_w, src_h, color)
draw_sprite_ex(x, y, w, h, src_x, src_y, src_w, src_h, ox, oy, angle, color)
draw_rect(x, y, w, h, color)
draw_text(ptr, len, x, y, size, color)
load_font(tex, char_w, char_h, first_cp, count) -&gt; u32
load_font_ex(tex, widths_ptr, char_h, first_cp, count) -&gt; u32
font_bind(handle)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void draw_sprite(float x, float y, float w, float h, uint32_t color);
void draw_sprite_region(float x, float y, float w, float h,
                        float src_x, float src_y, float src_w, float src_h, uint32_t color);
void draw_sprite_ex(float x, float y, float w, float h,
                    float src_x, float src_y, float src_w, float src_h,
                    float ox, float oy, float angle, uint32_t color);
void draw_rect(float x, float y, float w, float h, uint32_t color);
void draw_text(const uint8_t* ptr, uint32_t len, float x, float y, float size, uint32_t color);
uint32_t load_font(uint32_t tex, uint32_t char_w, uint32_t char_h, uint32_t first_cp, uint32_t count);
uint32_t load_font_ex(uint32_t tex, const uint8_t* widths, uint32_t char_h, uint32_t first_cp, uint32_t count);
void font_bind(uint32_t handle);
// Helper: EWZX_DRAW_TEXT("Hello", x, y, size, color)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">draw_sprite(x: f32, y: f32, w: f32, h: f32, color: u32) void
draw_sprite_region(x: f32, y: f32, w: f32, h: f32, src_x: f32, src_y: f32, src_w: f32, src_h: f32, color: u32) void
draw_sprite_ex(x: f32, y: f32, w: f32, h: f32, src_x: f32, src_y: f32, src_w: f32, src_h: f32, ox: f32, oy: f32, angle: f32, color: u32) void
draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void
draw_text(ptr: [*]const u8, len: u32, x: f32, y: f32, size: f32, color: u32) void
load_font(tex: u32, char_w: u32, char_h: u32, first_cp: u32, count: u32) u32
load_font_ex(tex: u32, widths: [*]const u8, char_h: u32, first_cp: u32, count: u32) u32
font_bind(handle: u32) void
// Helper: zx.text("Hello", x, y, size, color)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="billboards"><a class="header" href="#billboards">Billboards</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>draw_billboard(w, h, mode, color)      // mode: 1=sphere, 2=cylY, 3=cylX, 4=cylZ
draw_billboard_region(w, h, sx, sy, sw, sh, mode, color)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void draw_billboard(float w, float h, uint32_t mode, uint32_t color);
void draw_billboard_region(float w, float h, float sx, float sy, float sw, float sh, uint32_t mode, uint32_t color);
// Modes: EWZX_BILLBOARD_SPHERICAL, EWZX_BILLBOARD_CYLINDRICAL_Y/X/Z
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">draw_billboard(w: f32, h: f32, mode: u32, color: u32) void
draw_billboard_region(w: f32, h: f32, sx: f32, sy: f32, sw: f32, sh: f32, mode: u32, color: u32) void
// Modes: Billboard.spherical, Billboard.cylindrical_y/x/z
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="skinning"><a class="header" href="#skinning">Skinning</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_skeleton(inverse_bind_ptr, bone_count) -&gt; u32  // Init-only
skeleton_bind(skeleton)                // 0 to disable
set_bones(matrices_ptr, count)         // 12 floats per bone (3x4)
set_bones_4x4(matrices_ptr, count)     // 16 floats per bone (4x4)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t load_skeleton(const float* inverse_bind_ptr, uint32_t bone_count);  // Init-only
void skeleton_bind(uint32_t skeleton); // 0 to disable
void set_bones(const float* matrices_ptr, uint32_t count);  // 12 floats per bone (3x4)
void set_bones_4x4(const float* matrices_ptr, uint32_t count);  // 16 floats per bone (4x4)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">load_skeleton(inverse_bind: [*]const f32, bone_count: u32) u32  // Init-only
skeleton_bind(skeleton: u32) void      // 0 to disable
set_bones(matrices: [*]const f32, count: u32) void  // 12 floats per bone (3x4)
set_bones_4x4(matrices: [*]const f32, count: u32) void  // 16 floats per bone (4x4)
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="animation"><a class="header" href="#animation">Animation</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>keyframes_load(data_ptr, byte_size) -&gt; u32  // Init-only
rom_keyframes(id_ptr, id_len) -&gt; u32        // Init-only
keyframes_bone_count(handle) -&gt; u32
keyframes_frame_count(handle) -&gt; u32
keyframe_bind(handle, frame_index)          // GPU-side, no CPU decode
keyframe_read(handle, frame_index, out_ptr) // Read to WASM for blending
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t keyframes_load(const uint8_t* data, uint32_t byte_size);  // Init-only
uint32_t rom_keyframes(uint32_t id_ptr, uint32_t id_len);          // Init-only
uint32_t keyframes_bone_count(uint32_t handle);
uint32_t keyframes_frame_count(uint32_t handle);
void keyframe_bind(uint32_t handle, uint32_t frame_index);  // GPU-side
void keyframe_read(uint32_t handle, uint32_t frame_index, float* out_ptr);  // Read for blending
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">keyframes_load(data: [*]const u8, byte_size: u32) u32  // Init-only
rom_keyframes(id_ptr: u32, id_len: u32) u32            // Init-only
keyframes_bone_count(handle: u32) u32
keyframes_frame_count(handle: u32) u32
keyframe_bind(handle: u32, frame_index: u32) void      // GPU-side
keyframe_read(handle: u32, frame_index: u32, out: [*]f32) void  // Read for blending
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="audio-1"><a class="header" href="#audio-1">Audio</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>load_sound(data_ptr, byte_len) -&gt; u32  // Init-only, 22kHz 16-bit mono
play_sound(sound, volume, pan)         // Auto-select channel
channel_play(ch, sound, vol, pan, loop)
channel_set(ch, volume, pan)
channel_stop(ch)
music_play(sound, volume)
music_stop()
music_set_volume(volume)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t load_sound(const int16_t* data, uint32_t byte_len);  // Init-only
void play_sound(uint32_t sound, float volume, float pan);  // Auto-select channel
void channel_play(uint32_t ch, uint32_t sound, float vol, float pan, uint32_t loop);
void channel_set(uint32_t ch, float volume, float pan);
void channel_stop(uint32_t ch);
void music_play(uint32_t sound, float volume);
void music_stop(void);
void music_set_volume(float volume);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">load_sound(data: [*]const i16, byte_len: u32) u32  // Init-only
play_sound(sound: u32, volume: f32, pan: f32) void  // Auto-select channel
channel_play(ch: u32, sound: u32, vol: f32, pan: f32, loop: u32) void
channel_set(ch: u32, volume: f32, pan: f32) void
channel_stop(ch: u32) void
music_play(sound: u32, volume: f32) void
music_stop() void
music_set_volume(volume: f32) void
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="save-data"><a class="header" href="#save-data">Save Data</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>save(slot, data_ptr, data_len) -&gt; u32  // 0=ok, 1=bad slot, 2=too big
load(slot, data_ptr, max_len) -&gt; u32   // Returns bytes read
delete(slot) -&gt; u32                    // 0=ok, 1=bad slot
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t save(uint32_t slot, const uint8_t* data, uint32_t len);  // 0=ok, 1=bad slot, 2=too big
uint32_t load(uint32_t slot, uint8_t* data, uint32_t max_len);    // Returns bytes read
uint32_t delete_save(uint32_t slot);   // 0=ok, 1=bad slot
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">save(slot: u32, data: [*]const u8, len: u32) u32  // 0=ok, 1=bad slot, 2=too big
load(slot: u32, data: [*]u8, max_len: u32) u32    // Returns bytes read
delete_save(slot: u32) u32             // 0=ok, 1=bad slot
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="rom-loading-init-only"><a class="header" href="#rom-loading-init-only">ROM Loading (Init-Only)</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rom_texture(id_ptr, id_len) -&gt; u32
rom_mesh(id_ptr, id_len) -&gt; u32
rom_skeleton(id_ptr, id_len) -&gt; u32
rom_font(id_ptr, id_len) -&gt; u32
rom_sound(id_ptr, id_len) -&gt; u32
rom_keyframes(id_ptr, id_len) -&gt; u32
rom_data_len(id_ptr, id_len) -&gt; u32
rom_data(id_ptr, id_len, out_ptr, max_len) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">uint32_t rom_texture(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_mesh(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_skeleton(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_font(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_sound(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_keyframes(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_data_len(uint32_t id_ptr, uint32_t id_len);
uint32_t rom_data(uint32_t id_ptr, uint32_t id_len, uint32_t out_ptr, uint32_t max_len);
// Helpers: EWZX_ROM_TEXTURE("id"), EWZX_ROM_MESH("id"), etc.
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">rom_texture(id_ptr: u32, id_len: u32) u32
rom_mesh(id_ptr: u32, id_len: u32) u32
rom_skeleton(id_ptr: u32, id_len: u32) u32
rom_font(id_ptr: u32, id_len: u32) u32
rom_sound(id_ptr: u32, id_len: u32) u32
rom_keyframes(id_ptr: u32, id_len: u32) u32
rom_data_len(id_ptr: u32, id_len: u32) u32
rom_data(id_ptr: u32, id_len: u32, out_ptr: u32, max_len: u32) u32
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="debug"><a class="header" href="#debug">Debug</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Registration (init-only)
debug_register_i8/i16/i32(name_ptr, name_len, ptr)
debug_register_u8/u16/u32(name_ptr, name_len, ptr)
debug_register_f32(name_ptr, name_len, ptr)
debug_register_bool(name_ptr, name_len, ptr)
debug_register_i32_range(name_ptr, name_len, ptr, min, max)
debug_register_f32_range(name_ptr, name_len, ptr, min, max)
debug_register_u8_range/u16_range/i16_range(...)
debug_register_vec2/vec3/rect/color(name_ptr, name_len, ptr)
debug_register_fixed_i16_q8/i32_q8/i32_q16/i32_q24(...)

// Watch (read-only)
debug_watch_i8/i16/i32/u8/u16/u32/f32/bool(name_ptr, name_len, ptr)
debug_watch_vec2/vec3/rect/color(name_ptr, name_len, ptr)

// Groups
debug_group_begin(name_ptr, name_len)
debug_group_end()

// Frame control
debug_is_paused() -&gt; i32               // 1 if paused
debug_get_time_scale() -&gt; f32          // 1.0 = normal
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Registration (init-only)
void debug_register_i8/i16/i32(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);
void debug_register_u8/u16/u32(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);
void debug_register_f32(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);
void debug_register_bool(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);
void debug_register_i32_range(uint32_t name_ptr, uint32_t name_len, uint32_t ptr, int32_t min, int32_t max);
void debug_register_f32_range(uint32_t name_ptr, uint32_t name_len, uint32_t ptr, float min, float max);
void debug_register_vec2/vec3/rect/color(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);

// Watch (read-only)
void debug_watch_i8/i16/i32/u8/u16/u32/f32/bool(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);
void debug_watch_vec2/vec3/rect/color(uint32_t name_ptr, uint32_t name_len, uint32_t ptr);

// Groups
void debug_group_begin(uint32_t name_ptr, uint32_t name_len);
void debug_group_end(void);

// Frame control
int32_t debug_is_paused(void);         // 1 if paused
float debug_get_time_scale(void);      // 1.0 = normal
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Registration (init-only) - similar pattern for all types
debug_register_f32(name_ptr: u32, name_len: u32, ptr: u32) void
debug_register_i32(name_ptr: u32, name_len: u32, ptr: u32) void
debug_register_bool(name_ptr: u32, name_len: u32, ptr: u32) void
debug_register_i32_range(name_ptr: u32, name_len: u32, ptr: u32, min: i32, max: i32) void
debug_register_f32_range(name_ptr: u32, name_len: u32, ptr: u32, min: f32, max: f32) void
debug_register_vec2/vec3/rect/color(name_ptr: u32, name_len: u32, ptr: u32) void

// Watch (read-only) - similar pattern
debug_watch_f32(name_ptr: u32, name_len: u32, ptr: u32) void
debug_watch_vec2/vec3/rect/color(name_ptr: u32, name_len: u32, ptr: u32) void

// Groups
debug_group_begin(name_ptr: u32, name_len: u32) void
debug_group_end() void

// Frame control
debug_is_paused() i32                  // 1 if paused
debug_get_time_scale() f32             // 1.0 = normal
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Keyboard:</strong> F3=panel, F5=pause, F6=step, F7/F8=time scale</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="system-functions"><a class="header" href="#system-functions">System Functions</a></h1>
<p>Core system functions for time, logging, randomness, and session management.</p>
<h2 id="time-functions"><a class="header" href="#time-functions">Time Functions</a></h2>
<h3 id="delta_time"><a class="header" href="#delta_time">delta_time</a></h3>
<p>Returns the time elapsed since the last tick in seconds.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delta_time() -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float delta_time(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn delta_time() f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Time in seconds since last tick (typically 1/60 = 0.0167 at 60fps)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Frame-rate independent movement
    position.x += velocity.x * delta_time();
    position.y += velocity.y * delta_time();
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Frame-rate independent movement */
    position_x += velocity_x * delta_time();
    position_y += velocity_y * delta_time();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Frame-rate independent movement
    position_x += velocity_x * delta_time();
    position_y += velocity_y * delta_time();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#elapsed_time">elapsed_time</a>, <a href="#tick_count">tick_count</a></p>
<hr>
<h3 id="elapsed_time"><a class="header" href="#elapsed_time">elapsed_time</a></h3>
<p>Returns total elapsed time since game start in seconds.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn elapsed_time() -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float elapsed_time(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn elapsed_time() f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Total seconds since <code>init()</code> was called</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Pulsing effect
    let pulse = (elapsed_time() * 2.0).sin() * 0.5 + 0.5;
    set_color(rgba(255, 255, 255, (pulse * 255.0) as u8));
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Pulsing effect */
    float pulse = sinf(elapsed_time() * 2.0f) * 0.5f + 0.5f;
    set_color(nczx_rgba(255, 255, 255, (uint8_t)(pulse * 255.0f)));
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Pulsing effect
    const pulse = @sin(elapsed_time() * 2.0) * 0.5 + 0.5;
    set_color(rgba(255, 255, 255, @intFromFloat(pulse * 255.0)));
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#delta_time">delta_time</a>, <a href="#tick_count">tick_count</a></p>
<hr>
<h3 id="tick_count"><a class="header" href="#tick_count">tick_count</a></h3>
<p>Returns the current tick number (frame count).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn tick_count() -&gt; u64
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint64_t tick_count(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn tick_count() u64;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Number of ticks since game start</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Every second at 60fps
    if tick_count() % 60 == 0 {
        spawn_enemy();
    }

    // Every other tick
    if tick_count() % 2 == 0 {
        animate_water();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Every second at 60fps */
    if (tick_count() % 60 == 0) {
        spawn_enemy();
    }

    /* Every other tick */
    if (tick_count() % 2 == 0) {
        animate_water();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Every second at 60fps
    if (tick_count() % 60 == 0) {
        spawn_enemy();
    }

    // Every other tick
    if (tick_count() % 2 == 0) {
        animate_water();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#delta_time">delta_time</a>, <a href="#elapsed_time">elapsed_time</a></p>
<hr>
<h2 id="logging"><a class="header" href="#logging">Logging</a></h2>
<h3 id="log"><a class="header" href="#log">log</a></h3>
<p>Outputs a message to the console for debugging.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn log(ptr: *const u8, len: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void log_msg(const uint8_t* ptr, uint32_t len);
// Helper macro: EWZX_LOG("message")
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn log_msg(ptr: [*]const u8, len: u32) void;
// Helper: zx.log("message")
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>ptr</td><td><code>*const u8</code></td><td>Pointer to UTF-8 string data</td></tr>
<tr><td>len</td><td><code>u32</code></td><td>Length of the string in bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    let msg = b"Game initialized!";
    log(msg.as_ptr(), msg.len() as u32);
}

fn update() {
    if player_died {
        let msg = b"Player died";
        log(msg.as_ptr(), msg.len() as u32);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    EWZX_LOG("Game initialized!");
}

EWZX_EXPORT void update(void) {
    if (player_died) {
        EWZX_LOG("Player died");
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const zx = @import("nethercore_zx.zig");

export fn init() void {
    zx.log("Game initialized!");
}

export fn update() void {
    if (player_died) {
        zx.log("Player died");
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<h3 id="quit"><a class="header" href="#quit">quit</a></h3>
<p>Exits the game and returns to the Nethercore library.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn quit()
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void quit(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn quit() void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Quit on Start + Select held for 60 frames
    if buttons_held(0) &amp; ((1 &lt;&lt; BUTTON_START) | (1 &lt;&lt; BUTTON_SELECT)) != 0 {
        quit_timer += 1;
        if quit_timer &gt;= 60 {
            quit();
        }
    } else {
        quit_timer = 0;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Quit on Start + Select held for 60 frames */
    if (buttons_held(0) &amp; ((1 &lt;&lt; EWZX_BUTTON_START) | (1 &lt;&lt; EWZX_BUTTON_SELECT))) {
        quit_timer++;
        if (quit_timer &gt;= 60) {
            quit();
        }
    } else {
        quit_timer = 0;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Quit on Start + Select held for 60 frames
    if (buttons_held(0) &amp; ((1 &lt;&lt; Button.start) | (1 &lt;&lt; Button.select)) != 0) {
        quit_timer += 1;
        if (quit_timer &gt;= 60) {
            quit();
        }
    } else {
        quit_timer = 0;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="randomness"><a class="header" href="#randomness">Randomness</a></h2>
<h3 id="random"><a class="header" href="#random">random</a></h3>
<p>Returns a deterministic random number from the host’s seeded RNG.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn random() -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t random_u32(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn random_u32() u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> A random <code>u32</code> value (0 to 4,294,967,295)</p>
<p><strong>Constraints:</strong> Must use this for all randomness to maintain rollback determinism.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Random integer in range [0, 320)
    let spawn_x = (random() % 320) as f32;

    // Random float 0.0 to 1.0
    let rf = (random() as f32) / (u32::MAX as f32);

    // Random bool
    let coin_flip = random() &amp; 1 == 0;

    // Random float in range [min, max]
    let min = 10.0;
    let max = 50.0;
    let rf = (random() as f32) / (u32::MAX as f32);
    let value = min + rf * (max - min);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Random integer in range [0, 320) */
    float spawn_x = (float)(random_u32() % 320);

    /* Random float 0.0 to 1.0 */
    float rf = (float)random_u32() / (float)UINT32_MAX;

    /* Random bool */
    int coin_flip = (random_u32() &amp; 1) == 0;

    /* Random float in range [min, max] */
    float min = 10.0f;
    float max = 50.0f;
    float value = min + rf * (max - min);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Random integer in range [0, 320)
    const spawn_x: f32 = @floatFromInt(random_u32() % 320);

    // Random float 0.0 to 1.0
    const rf: f32 = @as(f32, @floatFromInt(random_u32())) / @as(f32, @floatFromInt(@as(u32, 0xFFFFFFFF)));

    // Random bool
    const coin_flip = (random_u32() &amp; 1) == 0;

    // Random float in range [min, max]
    const min: f32 = 10.0;
    const max: f32 = 50.0;
    const value = min + rf * (max - min);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Warning:</strong> Never use external random sources (system time, etc.) — this breaks rollback determinism.</p>
<hr>
<h2 id="session-functions"><a class="header" href="#session-functions">Session Functions</a></h2>
<h3 id="player_count"><a class="header" href="#player_count">player_count</a></h3>
<p>Returns the number of players in the current session.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn player_count() -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t player_count(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn player_count() u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Number of players (1-4)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Process all players
    for p in 0..player_count() {
        process_player_input(p);
        update_player_state(p);
    }
}

fn render() {
    // Draw viewport split for multiplayer
    match player_count() {
        1 =&gt; draw_fullscreen_viewport(0),
        2 =&gt; {
            draw_half_viewport(0, 0);   // Left half
            draw_half_viewport(1, 1);   // Right half
        }
        _ =&gt; draw_quad_viewports(),
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Process all players */
    for (uint32_t p = 0; p &lt; player_count(); p++) {
        process_player_input(p);
        update_player_state(p);
    }
}

EWZX_EXPORT void render(void) {
    /* Draw viewport split for multiplayer */
    switch (player_count()) {
        case 1: draw_fullscreen_viewport(0); break;
        case 2:
            draw_half_viewport(0, 0);   /* Left half */
            draw_half_viewport(1, 1);   /* Right half */
            break;
        default: draw_quad_viewports(); break;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Process all players
    var p: u32 = 0;
    while (p &lt; player_count()) : (p += 1) {
        process_player_input(p);
        update_player_state(p);
    }
}

export fn render() void {
    // Draw viewport split for multiplayer
    switch (player_count()) {
        1 =&gt; draw_fullscreen_viewport(0),
        2 =&gt; {
            draw_half_viewport(0, 0);   // Left half
            draw_half_viewport(1, 1);   // Right half
        },
        else =&gt; draw_quad_viewports(),
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#local_player_mask">local_player_mask</a></p>
<hr>
<h3 id="local_player_mask"><a class="header" href="#local_player_mask">local_player_mask</a></h3>
<p>Returns a bitmask indicating which players are local to this client.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn local_player_mask() -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t local_player_mask(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn local_player_mask() u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Bitmask where bit N is set if player N is local</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    let mask = local_player_mask();

    // Check if specific player is local
    let p0_local = (mask &amp; 1) != 0;  // Player 0
    let p1_local = (mask &amp; 2) != 0;  // Player 1
    let p2_local = (mask &amp; 4) != 0;  // Player 2
    let p3_local = (mask &amp; 8) != 0;  // Player 3

    // Only show local player's UI
    for p in 0..player_count() {
        if (mask &amp; (1 &lt;&lt; p)) != 0 {
            draw_player_ui(p);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    uint32_t mask = local_player_mask();

    /* Check if specific player is local */
    int p0_local = (mask &amp; 1) != 0;  /* Player 0 */
    int p1_local = (mask &amp; 2) != 0;  /* Player 1 */
    int p2_local = (mask &amp; 4) != 0;  /* Player 2 */
    int p3_local = (mask &amp; 8) != 0;  /* Player 3 */

    /* Only show local player's UI */
    for (uint32_t p = 0; p &lt; player_count(); p++) {
        if (mask &amp; (1 &lt;&lt; p)) {
            draw_player_ui(p);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    const mask = local_player_mask();

    // Check if specific player is local
    const p0_local = (mask &amp; 1) != 0;  // Player 0
    const p1_local = (mask &amp; 2) != 0;  // Player 1
    const p2_local = (mask &amp; 4) != 0;  // Player 2
    const p3_local = (mask &amp; 8) != 0;  // Player 3

    // Only show local player's UI
    var p: u32 = 0;
    while (p &lt; player_count()) : (p += 1) {
        if (mask &amp; (@as(u32, 1) &lt;&lt; @intCast(p)) != 0) {
            draw_player_ui(p);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="multiplayer-model"><a class="header" href="#multiplayer-model">Multiplayer Model</a></h3>
<p>Nethercore supports up to 4 players in any combination:</p>
<ul>
<li>4 local players (couch co-op)</li>
<li>1 local + 3 remote (online)</li>
<li>2 local + 2 remote (mixed)</li>
</ul>
<p>All inputs are synchronized via GGRS rollback netcode. Your <code>update()</code> processes all players uniformly — the host handles synchronization automatically.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // This code works for any local/remote mix
    for p in 0..player_count() {
        let input = get_player_input(p);
        update_player(p, input);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* This code works for any local/remote mix */
    for (uint32_t p = 0; p &lt; player_count(); p++) {
        Input input = get_player_input(p);
        update_player(p, input);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // This code works for any local/remote mix
    var p: u32 = 0;
    while (p &lt; player_count()) : (p += 1) {
        const input = get_player_input(p);
        update_player(p, input);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="input-functions"><a class="header" href="#input-functions">Input Functions</a></h1>
<p>Controller input handling for buttons, analog sticks, and triggers.</p>
<h2 id="controller-layout"><a class="header" href="#controller-layout">Controller Layout</a></h2>
<p>Nethercore ZX uses a modern PS2/Xbox-style controller:</p>
<pre><code>         [LB]                    [RB]
         [LT]                    [RT]
        +-----------------------------+
       |  [^]              [Y]        |
       | [&lt;][&gt;]    [=][=]  [X] [B]    |
       |  [v]              [A]        |
       |       [SELECT] [START]       |
       |        [L3]     [R3]         |
        +-----------------------------+
           Left      Right
           Stick     Stick
</code></pre>
<ul>
<li><strong>D-Pad:</strong> 4 directions (digital)</li>
<li><strong>Face buttons:</strong> A, B, X, Y (digital)</li>
<li><strong>Shoulder bumpers:</strong> LB, RB (digital)</li>
<li><strong>Triggers:</strong> LT, RT (analog 0.0-1.0)</li>
<li><strong>Sticks:</strong> Left + Right (analog -1.0 to 1.0, clickable L3/R3)</li>
<li><strong>Menu:</strong> Start, Select (digital)</li>
</ul>
<h2 id="button-constants-1"><a class="header" href="#button-constants-1">Button Constants</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// D-Pad
const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_LEFT: u32 = 2;
const BUTTON_RIGHT: u32 = 3;

// Face buttons
const BUTTON_A: u32 = 4;
const BUTTON_B: u32 = 5;
const BUTTON_X: u32 = 6;
const BUTTON_Y: u32 = 7;

// Shoulder bumpers
const BUTTON_LB: u32 = 8;
const BUTTON_RB: u32 = 9;

// Stick clicks
const BUTTON_L3: u32 = 10;
const BUTTON_R3: u32 = 11;

// Menu
const BUTTON_START: u32 = 12;
const BUTTON_SELECT: u32 = 13;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// D-Pad
#define EWZX_BUTTON_UP      0
#define EWZX_BUTTON_DOWN    1
#define EWZX_BUTTON_LEFT    2
#define EWZX_BUTTON_RIGHT   3

// Face buttons
#define EWZX_BUTTON_A       4
#define EWZX_BUTTON_B       5
#define EWZX_BUTTON_X       6
#define EWZX_BUTTON_Y       7

// Shoulder bumpers
#define EWZX_BUTTON_L1      8
#define EWZX_BUTTON_R1      9

// Stick clicks
#define EWZX_BUTTON_L3      10
#define EWZX_BUTTON_R3      11

// Menu
#define EWZX_BUTTON_START   12
#define EWZX_BUTTON_SELECT  13
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const Button = struct {
    // D-Pad
    pub const up: u32 = 0;
    pub const down: u32 = 1;
    pub const left: u32 = 2;
    pub const right: u32 = 3;

    // Face buttons
    pub const a: u32 = 4;
    pub const b: u32 = 5;
    pub const x: u32 = 6;
    pub const y: u32 = 7;

    // Shoulder bumpers
    pub const l1: u32 = 8;
    pub const r1: u32 = 9;

    // Stick clicks
    pub const l3: u32 = 10;
    pub const r3: u32 = 11;

    // Menu
    pub const start: u32 = 12;
    pub const select: u32 = 13;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="individual-button-queries"><a class="header" href="#individual-button-queries">Individual Button Queries</a></h2>
<h3 id="button_held"><a class="header" href="#button_held">button_held</a></h3>
<p>Check if a button is currently held down.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn button_held(player: u32, button: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t button_held(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn button_held(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
<tr><td>button</td><td><code>u32</code></td><td>Button constant (0-13)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>1</code> if held, <code>0</code> otherwise</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Continuous movement while held
    if button_held(0, BUTTON_RIGHT) != 0 {
        player.x += MOVE_SPEED * delta_time();
    }
    if button_held(0, BUTTON_LEFT) != 0 {
        player.x -= MOVE_SPEED * delta_time();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Continuous movement while held */
    if (button_held(0, EWZX_BUTTON_RIGHT)) {
        player_x += MOVE_SPEED * delta_time();
    }
    if (button_held(0, EWZX_BUTTON_LEFT)) {
        player_x -= MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Continuous movement while held
    if (button_held(0, Button.right) != 0) {
        player_x += MOVE_SPEED * delta_time();
    }
    if (button_held(0, Button.left) != 0) {
        player_x -= MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#button_pressed">button_pressed</a>, <a href="#button_released">button_released</a></p>
<hr>
<h3 id="button_pressed"><a class="header" href="#button_pressed">button_pressed</a></h3>
<p>Check if a button was just pressed this tick (edge detection).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn button_pressed(player: u32, button: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t button_pressed(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn button_pressed(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
<tr><td>button</td><td><code>u32</code></td><td>Button constant (0-13)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>1</code> if just pressed this tick, <code>0</code> otherwise</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Jump only triggers once per press
    if button_pressed(0, BUTTON_A) != 0 &amp;&amp; player.on_ground {
        player.velocity_y = JUMP_VELOCITY;
        play_sound(jump_sfx, 1.0, 0.0);
    }

    // Cycle weapons
    if button_pressed(0, BUTTON_RB) != 0 {
        current_weapon = (current_weapon + 1) % NUM_WEAPONS;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Jump only triggers once per press */
    if (button_pressed(0, EWZX_BUTTON_A) &amp;&amp; on_ground) {
        velocity_y = JUMP_VELOCITY;
        play_sound(jump_sfx, 1.0f, 0.0f);
    }

    /* Cycle weapons */
    if (button_pressed(0, EWZX_BUTTON_R1)) {
        current_weapon = (current_weapon + 1) % NUM_WEAPONS;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Jump only triggers once per press
    if (button_pressed(0, Button.a) != 0 and on_ground) {
        velocity_y = JUMP_VELOCITY;
        play_sound(jump_sfx, 1.0, 0.0);
    }

    // Cycle weapons
    if (button_pressed(0, Button.r1) != 0) {
        current_weapon = (current_weapon + 1) % NUM_WEAPONS;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#button_held">button_held</a>, <a href="#button_released">button_released</a></p>
<hr>
<h3 id="button_released"><a class="header" href="#button_released">button_released</a></h3>
<p>Check if a button was just released this tick.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn button_released(player: u32, button: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t button_released(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn button_released(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
<tr><td>button</td><td><code>u32</code></td><td>Button constant (0-13)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> <code>1</code> if just released this tick, <code>0</code> otherwise</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Variable jump height (release early = smaller jump)
    if button_released(0, BUTTON_A) != 0 &amp;&amp; player.velocity_y &lt; 0.0 {
        player.velocity_y *= 0.5; // Cut upward velocity
    }

    // Charged attack
    if button_released(0, BUTTON_X) != 0 {
        let power = charge_time.min(MAX_CHARGE);
        fire_charged_attack(power);
        charge_time = 0.0;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Variable jump height (release early = smaller jump) */
    if (button_released(0, EWZX_BUTTON_A) &amp;&amp; velocity_y &lt; 0.0f) {
        velocity_y *= 0.5f; /* Cut upward velocity */
    }

    /* Charged attack */
    if (button_released(0, EWZX_BUTTON_X)) {
        float power = nczx_minf(charge_time, MAX_CHARGE);
        fire_charged_attack(power);
        charge_time = 0.0f;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Variable jump height (release early = smaller jump)
    if (button_released(0, Button.a) != 0 and velocity_y &lt; 0.0) {
        velocity_y *= 0.5; // Cut upward velocity
    }

    // Charged attack
    if (button_released(0, Button.x) != 0) {
        const power = @min(charge_time, MAX_CHARGE);
        fire_charged_attack(power);
        charge_time = 0.0;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#button_held">button_held</a>, <a href="#button_pressed">button_pressed</a></p>
<hr>
<h2 id="bulk-button-queries"><a class="header" href="#bulk-button-queries">Bulk Button Queries</a></h2>
<p>For better performance when checking multiple buttons, use bulk queries to reduce FFI overhead.</p>
<h3 id="buttons_held"><a class="header" href="#buttons_held">buttons_held</a></h3>
<p>Get a bitmask of all currently held buttons.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn buttons_held(player: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t buttons_held(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn buttons_held(player: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Bitmask where bit N is set if button N is held</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let held = buttons_held(0);

    // Check multiple buttons efficiently
    if held &amp; (1 &lt;&lt; BUTTON_A) != 0 { /* A held */ }
    if held &amp; (1 &lt;&lt; BUTTON_B) != 0 { /* B held */ }

    // Check for combo (A + B held together)
    let combo = (1 &lt;&lt; BUTTON_A) | (1 &lt;&lt; BUTTON_B);
    if held &amp; combo == combo {
        perform_combo_attack();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    uint32_t held = buttons_held(0);

    /* Check multiple buttons efficiently */
    if (held &amp; (1 &lt;&lt; EWZX_BUTTON_A)) { /* A held */ }
    if (held &amp; (1 &lt;&lt; EWZX_BUTTON_B)) { /* B held */ }

    /* Check for combo (A + B held together) */
    uint32_t combo = (1 &lt;&lt; EWZX_BUTTON_A) | (1 &lt;&lt; EWZX_BUTTON_B);
    if ((held &amp; combo) == combo) {
        perform_combo_attack();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const held = buttons_held(0);

    // Check multiple buttons efficiently
    if (held &amp; (1 &lt;&lt; Button.a) != 0) { /* A held */ }
    if (held &amp; (1 &lt;&lt; Button.b) != 0) { /* B held */ }

    // Check for combo (A + B held together)
    const combo = (1 &lt;&lt; Button.a) | (1 &lt;&lt; Button.b);
    if (held &amp; combo == combo) {
        perform_combo_attack();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#buttons_pressed">buttons_pressed</a>, <a href="#buttons_released">buttons_released</a></p>
<hr>
<h3 id="buttons_pressed"><a class="header" href="#buttons_pressed">buttons_pressed</a></h3>
<p>Get a bitmask of all buttons pressed this tick.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn buttons_pressed(player: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t buttons_pressed(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn buttons_pressed(player: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Bitmask where bit N is set if button N was just pressed</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let pressed = buttons_pressed(0);

    // Check if any face button pressed
    let face_buttons = (1 &lt;&lt; BUTTON_A) | (1 &lt;&lt; BUTTON_B) |
                       (1 &lt;&lt; BUTTON_X) | (1 &lt;&lt; BUTTON_Y);
    if pressed &amp; face_buttons != 0 {
        // Handle menu selection
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    uint32_t pressed = buttons_pressed(0);

    /* Check if any face button pressed */
    uint32_t face_buttons = (1 &lt;&lt; EWZX_BUTTON_A) | (1 &lt;&lt; EWZX_BUTTON_B) |
                            (1 &lt;&lt; EWZX_BUTTON_X) | (1 &lt;&lt; EWZX_BUTTON_Y);
    if (pressed &amp; face_buttons) {
        /* Handle menu selection */
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const pressed = buttons_pressed(0);

    // Check if any face button pressed
    const face_buttons = (1 &lt;&lt; Button.a) | (1 &lt;&lt; Button.b) |
                         (1 &lt;&lt; Button.x) | (1 &lt;&lt; Button.y);
    if (pressed &amp; face_buttons != 0) {
        // Handle menu selection
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="buttons_released"><a class="header" href="#buttons_released">buttons_released</a></h3>
<p>Get a bitmask of all buttons released this tick.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn buttons_released(player: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t buttons_released(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn buttons_released(player: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Bitmask where bit N is set if button N was just released</p>
<hr>
<h2 id="analog-sticks"><a class="header" href="#analog-sticks">Analog Sticks</a></h2>
<h3 id="left_stick_x"><a class="header" href="#left_stick_x">left_stick_x</a></h3>
<p>Get the left stick horizontal axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_stick_x(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float left_stick_x(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn left_stick_x(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Value from <code>-1.0</code> (left) to <code>1.0</code> (right), <code>0.0</code> at center</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let stick_x = left_stick_x(0);

    // Apply deadzone
    let deadzone = 0.15;
    if stick_x.abs() &gt; deadzone {
        player.x += stick_x * MOVE_SPEED * delta_time();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float stick_x = left_stick_x(0);

    /* Apply deadzone */
    float deadzone = 0.15f;
    if (nczx_absf(stick_x) &gt; deadzone) {
        player_x += stick_x * MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const stick_x = left_stick_x(0);

    // Apply deadzone
    const deadzone = 0.15;
    if (@abs(stick_x) &gt; deadzone) {
        player_x += stick_x * MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="left_stick_y"><a class="header" href="#left_stick_y">left_stick_y</a></h3>
<p>Get the left stick vertical axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_stick_y(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float left_stick_y(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn left_stick_y(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Value from <code>-1.0</code> (down) to <code>1.0</code> (up), <code>0.0</code> at center</p>
<hr>
<h3 id="right_stick_x"><a class="header" href="#right_stick_x">right_stick_x</a></h3>
<p>Get the right stick horizontal axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn right_stick_x(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float right_stick_x(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn right_stick_x(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Value from <code>-1.0</code> (left) to <code>1.0</code> (right)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Camera control with right stick
    camera_yaw += right_stick_x(0) * CAMERA_SPEED * delta_time();
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    /* Camera control with right stick */
    camera_yaw += right_stick_x(0) * CAMERA_SPEED * delta_time();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Camera control with right stick
    camera_yaw += right_stick_x(0) * CAMERA_SPEED * delta_time();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="right_stick_y"><a class="header" href="#right_stick_y">right_stick_y</a></h3>
<p>Get the right stick vertical axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn right_stick_y(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float right_stick_y(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn right_stick_y(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Value from <code>-1.0</code> (down) to <code>1.0</code> (up)</p>
<hr>
<h3 id="left_stick"><a class="header" href="#left_stick">left_stick</a></h3>
<p>Get both left stick axes in a single FFI call (more efficient).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_stick(player: u32, out_x: *mut f32, out_y: *mut f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void left_stick(uint32_t player, float* out_x, float* out_y);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn left_stick(player: u32, out_x: *f32, out_y: *f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
<tr><td>out_x</td><td><code>*mut f32</code></td><td>Pointer to write X value</td></tr>
<tr><td>out_y</td><td><code>*mut f32</code></td><td>Pointer to write Y value</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let mut x: f32 = 0.0;
    let mut y: f32 = 0.0;
    left_stick(0, &amp;mut x, &amp;mut y);

    // Calculate magnitude for circular deadzone
    let mag = (x * x + y * y).sqrt();
    if mag &gt; 0.15 {
        let nx = x / mag;
        let ny = y / mag;
        player.x += nx * MOVE_SPEED * delta_time();
        player.y += ny * MOVE_SPEED * delta_time();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float x = 0.0f;
    float y = 0.0f;
    left_stick(0, &amp;x, &amp;y);

    /* Calculate magnitude for circular deadzone */
    float mag = sqrtf(x * x + y * y);
    if (mag &gt; 0.15f) {
        float nx = x / mag;
        float ny = y / mag;
        player_x += nx * MOVE_SPEED * delta_time();
        player_y += ny * MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    var x: f32 = 0.0;
    var y: f32 = 0.0;
    left_stick(0, &amp;x, &amp;y);

    // Calculate magnitude for circular deadzone
    const mag = @sqrt(x * x + y * y);
    if (mag &gt; 0.15) {
        const nx = x / mag;
        const ny = y / mag;
        player_x += nx * MOVE_SPEED * delta_time();
        player_y += ny * MOVE_SPEED * delta_time();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="right_stick"><a class="header" href="#right_stick">right_stick</a></h3>
<p>Get both right stick axes in a single FFI call.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn right_stick(player: u32, out_x: *mut f32, out_y: *mut f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void right_stick(uint32_t player, float* out_x, float* out_y);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn right_stick(player: u32, out_x: *f32, out_y: *f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="analog-triggers"><a class="header" href="#analog-triggers">Analog Triggers</a></h2>
<h3 id="trigger_left"><a class="header" href="#trigger_left">trigger_left</a></h3>
<p>Get the left trigger (LT) value.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trigger_left(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float trigger_left(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn trigger_left(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>player</td><td><code>u32</code></td><td>Player index (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Value from <code>0.0</code> (released) to <code>1.0</code> (fully pressed)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let lt = trigger_left(0);

    // Brake with analog pressure
    if lt &gt; 0.1 {
        vehicle.speed *= 1.0 - (lt * BRAKE_FORCE * delta_time());
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float lt = trigger_left(0);

    /* Brake with analog pressure */
    if (lt &gt; 0.1f) {
        vehicle_speed *= 1.0f - (lt * BRAKE_FORCE * delta_time());
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const lt = trigger_left(0);

    // Brake with analog pressure
    if (lt &gt; 0.1) {
        vehicle_speed *= 1.0 - (lt * BRAKE_FORCE * delta_time());
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="trigger_right"><a class="header" href="#trigger_right">trigger_right</a></h3>
<p>Get the right trigger (RT) value.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn trigger_right(player: u32) -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float trigger_right(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn trigger_right(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Value from <code>0.0</code> (released) to <code>1.0</code> (fully pressed)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    let rt = trigger_right(0);

    // Accelerate with analog pressure
    if rt &gt; 0.1 {
        vehicle.speed += rt * ACCEL_FORCE * delta_time();
    }

    // Aiming zoom
    let zoom = 1.0 + rt * 2.0; // 1x to 3x zoom
    camera_fov(60.0 / zoom);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    float rt = trigger_right(0);

    /* Accelerate with analog pressure */
    if (rt &gt; 0.1f) {
        vehicle_speed += rt * ACCEL_FORCE * delta_time();
    }

    /* Aiming zoom */
    float zoom = 1.0f + rt * 2.0f; /* 1x to 3x zoom */
    camera_fov(60.0f / zoom);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    const rt = trigger_right(0);

    // Accelerate with analog pressure
    if (rt &gt; 0.1) {
        vehicle_speed += rt * ACCEL_FORCE * delta_time();
    }

    // Aiming zoom
    const zoom = 1.0 + rt * 2.0; // 1x to 3x zoom
    camera_fov(60.0 / zoom);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-input-example"><a class="header" href="#complete-input-example">Complete Input Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BUTTON_A: u32 = 4;
const BUTTON_B: u32 = 5;
const MOVE_SPEED: f32 = 100.0;
const DEADZONE: f32 = 0.15;

static mut PLAYER_X: f32 = 0.0;
static mut PLAYER_Y: f32 = 0.0;
static mut ON_GROUND: bool = true;
static mut VEL_Y: f32 = 0.0;

#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        let dt = delta_time();

        // Movement with left stick
        let mut sx: f32 = 0.0;
        let mut sy: f32 = 0.0;
        left_stick(0, &amp;mut sx, &amp;mut sy);

        if sx.abs() &gt; DEADZONE {
            PLAYER_X += sx * MOVE_SPEED * dt;
        }

        // Jump with A button
        if button_pressed(0, BUTTON_A) != 0 &amp;&amp; ON_GROUND {
            VEL_Y = -300.0;
            ON_GROUND = false;
        }

        // Gravity
        VEL_Y += 800.0 * dt;
        PLAYER_Y += VEL_Y * dt;

        // Ground collision
        if PLAYER_Y &gt;= 200.0 {
            PLAYER_Y = 200.0;
            VEL_Y = 0.0;
            ON_GROUND = true;
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define MOVE_SPEED 100.0f
#define DEADZONE 0.15f

static float player_x = 0.0f;
static float player_y = 0.0f;
static int on_ground = 1;
static float vel_y = 0.0f;

EWZX_EXPORT void update(void) {
    float dt = delta_time();

    /* Movement with left stick */
    float sx = 0.0f;
    float sy = 0.0f;
    left_stick(0, &amp;sx, &amp;sy);

    if (nczx_absf(sx) &gt; DEADZONE) {
        player_x += sx * MOVE_SPEED * dt;
    }

    /* Jump with A button */
    if (button_pressed(0, EWZX_BUTTON_A) &amp;&amp; on_ground) {
        vel_y = -300.0f;
        on_ground = 0;
    }

    /* Gravity */
    vel_y += 800.0f * dt;
    player_y += vel_y * dt;

    /* Ground collision */
    if (player_y &gt;= 200.0f) {
        player_y = 200.0f;
        vel_y = 0.0f;
        on_ground = 1;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const MOVE_SPEED: f32 = 100.0;
const DEADZONE: f32 = 0.15;

var player_x: f32 = 0.0;
var player_y: f32 = 0.0;
var on_ground: bool = true;
var vel_y: f32 = 0.0;

export fn update() void {
    const dt = delta_time();

    // Movement with left stick
    var sx: f32 = 0.0;
    var sy: f32 = 0.0;
    left_stick(0, &amp;sx, &amp;sy);

    if (@abs(sx) &gt; DEADZONE) {
        player_x += sx * MOVE_SPEED * dt;
    }

    // Jump with A button
    if (button_pressed(0, Button.a) != 0 and on_ground) {
        vel_y = -300.0;
        on_ground = false;
    }

    // Gravity
    vel_y += 800.0 * dt;
    player_y += vel_y * dt;

    // Ground collision
    if (player_y &gt;= 200.0) {
        player_y = 200.0;
        vel_y = 0.0;
        on_ground = true;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="graphics-configuration"><a class="header" href="#graphics-configuration">Graphics Configuration</a></h1>
<p>Console configuration and render state functions.</p>
<h2 id="configuration-init-only-1"><a class="header" href="#configuration-init-only-1">Configuration (Init-Only)</a></h2>
<p>These functions <strong>must be called in <code>init()</code></strong> and cannot be changed at runtime.</p>
<h3 id="set_tick_rate"><a class="header" href="#set_tick_rate">set_tick_rate</a></h3>
<p>Sets the game’s tick rate (updates per second).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_tick_rate(fps: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_tick_rate(uint32_t fps);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_tick_rate(fps: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Tick Rate</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>24 fps</td></tr>
<tr><td>1</td><td>30 fps</td></tr>
<tr><td>2</td><td>60 fps - <strong>default</strong></td></tr>
<tr><td>3</td><td>120 fps</td></tr>
</tbody>
</table>
</div>
<p><strong>Constraints:</strong> Init-only. Affects GGRS synchronization.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    set_tick_rate(2); // 60 fps
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    set_tick_rate(2); // 60 fps
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_tick_rate(2); // 60 fps
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="set_clear_color"><a class="header" href="#set_clear_color">set_clear_color</a></h3>
<p>Sets the background clear color.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_clear_color(color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_clear_color(uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_clear_color(color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>color</td><td><code>u32</code></td><td>RGBA color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Constraints:</strong> Init-only. Default is <code>0x000000FF</code> (black).</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    set_clear_color(0x1a1a2eFF); // Dark blue
    set_clear_color(0x87CEEBFF); // Sky blue
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    set_clear_color(0x1a1a2eFF); // Dark blue
    set_clear_color(0x87CEEBFF); // Sky blue
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    set_clear_color(0x1a1a2eFF); // Dark blue
    set_clear_color(0x87CEEBFF); // Sky blue
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="render_mode"><a class="header" href="#render_mode">render_mode</a></h3>
<p>Sets the rendering mode (shader pipeline).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render_mode(mode: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void render_mode(uint32_t mode);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn render_mode(mode: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Unlit</td><td>Flat colors, no lighting</td></tr>
<tr><td>1</td><td>Matcap</td><td>Pre-baked lighting via matcap textures</td></tr>
<tr><td>2</td><td>Metallic-Roughness</td><td>PBR-style Blinn-Phong with MRE textures</td></tr>
<tr><td>3</td><td>Specular-Shininess</td><td>Traditional Blinn-Phong</td></tr>
</tbody>
</table>
</div>
<p><strong>Constraints:</strong> Init-only. Default is mode 0 (Unlit).</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(2); // PBR-style lighting
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(2); // PBR-style lighting
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(2); // PBR-style lighting
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#render-modes-guide">Render Modes Guide</a></p>
<hr>
<h2 id="render-state-1"><a class="header" href="#render-state-1">Render State</a></h2>
<p>These functions can be called anytime during <code>render()</code> to change draw state.</p>
<h3 id="set_color"><a class="header" href="#set_color">set_color</a></h3>
<p>Sets the uniform tint color for subsequent draws.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_color(color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_color(uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_color(color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>color</td><td><code>u32</code></td><td>RGBA color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // White (no tint)
    set_color(0xFFFFFFFF);
    draw_mesh(model);

    // Red tint
    set_color(0xFF0000FF);
    draw_mesh(enemy);

    // 50% transparent
    set_color(0xFFFFFF80);
    draw_mesh(ghost);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // White (no tint)
    set_color(0xFFFFFFFF);
    draw_mesh(model);

    // Red tint
    set_color(0xFF0000FF);
    draw_mesh(enemy);

    // 50% transparent
    set_color(0xFFFFFF80);
    draw_mesh(ghost);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // White (no tint)
    set_color(0xFFFFFFFF);
    draw_mesh(model);

    // Red tint
    set_color(0xFF0000FF);
    draw_mesh(enemy);

    // 50% transparent
    set_color(0xFFFFFF80);
    draw_mesh(ghost);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="depth_test"><a class="header" href="#depth_test">depth_test</a></h3>
<p>Enables or disables depth testing.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn depth_test(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void depth_test(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn depth_test(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>enabled</td><td><code>u32</code></td><td><code>1</code> to enable, <code>0</code> to disable</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // 3D scene with depth
    depth_test(1);
    draw_mesh(level);
    draw_mesh(player);

    // UI overlay without depth
    depth_test(0);
    draw_sprite(0.0, 0.0, 100.0, 50.0, 0xFFFFFFFF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // 3D scene with depth
    depth_test(1);
    draw_mesh(level);
    draw_mesh(player);

    // UI overlay without depth
    depth_test(0);
    draw_sprite(0.0f, 0.0f, 100.0f, 50.0f, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // 3D scene with depth
    depth_test(1);
    draw_mesh(level);
    draw_mesh(player);

    // UI overlay without depth
    depth_test(0);
    draw_sprite(0.0, 0.0, 100.0, 50.0, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="cull_mode"><a class="header" href="#cull_mode">cull_mode</a></h3>
<p>Sets face culling mode.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cull_mode(mode: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void cull_mode(uint32_t mode);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn cull_mode(mode: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>None</td><td>Draw both sides</td></tr>
<tr><td>1</td><td>Back</td><td>Cull back faces (default)</td></tr>
<tr><td>2</td><td>Front</td><td>Cull front faces</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Normal geometry
    cull_mode(1); // Back-face culling
    draw_mesh(solid_object);

    // Skybox (inside-out)
    cull_mode(2); // Front-face culling
    draw_mesh(skybox);

    // Double-sided foliage
    cull_mode(0); // No culling
    draw_mesh(leaves);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Normal geometry
    cull_mode(1); // Back-face culling
    draw_mesh(solid_object);

    // Skybox (inside-out)
    cull_mode(2); // Front-face culling
    draw_mesh(skybox);

    // Double-sided foliage
    cull_mode(0); // No culling
    draw_mesh(leaves);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Normal geometry
    cull_mode(1); // Back-face culling
    draw_mesh(solid_object);

    // Skybox (inside-out)
    cull_mode(2); // Front-face culling
    draw_mesh(skybox);

    // Double-sided foliage
    cull_mode(0); // No culling
    draw_mesh(leaves);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="blend_mode"><a class="header" href="#blend_mode">blend_mode</a></h3>
<p>Sets the alpha blending mode.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn blend_mode(mode: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void blend_mode(uint32_t mode);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn blend_mode(mode: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>None</td><td>No blending (opaque)</td></tr>
<tr><td>1</td><td>Alpha</td><td>Standard transparency</td></tr>
<tr><td>2</td><td>Additive</td><td>Add colors (glow effects)</td></tr>
<tr><td>3</td><td>Multiply</td><td>Multiply colors (shadows)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Opaque geometry first
    blend_mode(0);
    draw_mesh(level);
    draw_mesh(player);

    // Transparent objects (sorted back-to-front)
    blend_mode(1);
    draw_mesh(window);

    // Additive glow effects
    blend_mode(2);
    draw_mesh(fire_particles);
    draw_mesh(laser_beam);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Opaque geometry first
    blend_mode(0);
    draw_mesh(level);
    draw_mesh(player);

    // Transparent objects (sorted back-to-front)
    blend_mode(1);
    draw_mesh(window);

    // Additive glow effects
    blend_mode(2);
    draw_mesh(fire_particles);
    draw_mesh(laser_beam);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Opaque geometry first
    blend_mode(0);
    draw_mesh(level);
    draw_mesh(player);

    // Transparent objects (sorted back-to-front)
    blend_mode(1);
    draw_mesh(window);

    // Additive glow effects
    blend_mode(2);
    draw_mesh(fire_particles);
    draw_mesh(laser_beam);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="texture_filter"><a class="header" href="#texture_filter">texture_filter</a></h3>
<p>Sets texture filtering mode.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn texture_filter(filter: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void texture_filter(uint32_t filter);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn texture_filter(filter: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Nearest</td><td>Pixelated (retro look)</td></tr>
<tr><td>1</td><td>Linear</td><td>Smooth (modern look)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Pixel art sprites
    texture_filter(0);
    draw_sprite(0.0, 0.0, 64.0, 64.0, 0xFFFFFFFF);

    // Photo textures
    texture_filter(1);
    draw_mesh(realistic_model);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Pixel art sprites
    texture_filter(0);
    draw_sprite(0.0f, 0.0f, 64.0f, 64.0f, 0xFFFFFFFF);

    // Photo textures
    texture_filter(1);
    draw_mesh(realistic_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Pixel art sprites
    texture_filter(0);
    draw_sprite(0.0, 0.0, 64.0, 64.0, 0xFFFFFFFF);

    // Photo textures
    texture_filter(1);
    draw_mesh(realistic_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="uniform_alpha"><a class="header" href="#uniform_alpha">uniform_alpha</a></h3>
<p>Sets the dither alpha level for PS1-style transparency.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn uniform_alpha(level: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void uniform_alpha(uint32_t level);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn uniform_alpha(level: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>level</td><td><code>u32</code></td><td>Alpha level 0-15 (0 = invisible, 15 = opaque)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Fade in effect
    let alpha = (fade_progress * 15.0) as u32;
    uniform_alpha(alpha);
    draw_mesh(fading_object);

    // Reset to fully opaque
    uniform_alpha(15);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Fade in effect
    uint32_t alpha = (uint32_t)(fade_progress * 15.0f);
    uniform_alpha(alpha);
    draw_mesh(fading_object);

    // Reset to fully opaque
    uniform_alpha(15);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Fade in effect
    const alpha: u32 = @intFromFloat(fade_progress * 15.0);
    uniform_alpha(alpha);
    draw_mesh(fading_object);

    // Reset to fully opaque
    uniform_alpha(15);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#dither_offset">dither_offset</a></p>
<hr>
<h3 id="dither_offset"><a class="header" href="#dither_offset">dither_offset</a></h3>
<p>Sets the dither pattern offset for animated dithering.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn dither_offset(x: u32, y: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void dither_offset(uint32_t x, uint32_t y);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn dither_offset(x: u32, y: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x</td><td><code>u32</code></td><td>X offset 0-3</td></tr>
<tr><td>y</td><td><code>u32</code></td><td>Y offset 0-3</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Animate dither pattern for shimmer effect
    let frame = tick_count() as u32;
    dither_offset(frame % 4, (frame / 4) % 4);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Animate dither pattern for shimmer effect
    uint32_t frame = (uint32_t)tick_count();
    dither_offset(frame % 4, (frame / 4) % 4);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Animate dither pattern for shimmer effect
    const frame: u32 = @intCast(tick_count());
    dither_offset(frame % 4, (frame / 4) % 4);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    // Configure console
    set_tick_rate(2);         // 60 fps
    set_clear_color(0x1a1a2eFF);
    render_mode(2);           // PBR lighting
}

fn render() {
    // Draw 3D scene
    depth_test(1);
    cull_mode(1);
    blend_mode(0);
    texture_filter(1);

    set_color(0xFFFFFFFF);
    draw_mesh(level);
    draw_mesh(player);

    // Draw transparent water
    blend_mode(1);
    set_color(0x4080FF80);
    draw_mesh(water);

    // Draw UI (no depth, alpha blending)
    depth_test(0);
    texture_filter(0);
    draw_sprite(10.0, 10.0, 200.0, 50.0, 0xFFFFFFFF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    // Configure console
    set_tick_rate(2);         // 60 fps
    set_clear_color(0x1a1a2eFF);
    render_mode(2);           // PBR lighting
}

EWZX_EXPORT void render(void) {
    // Draw 3D scene
    depth_test(1);
    cull_mode(1);
    blend_mode(0);
    texture_filter(1);

    set_color(0xFFFFFFFF);
    draw_mesh(level);
    draw_mesh(player);

    // Draw transparent water
    blend_mode(1);
    set_color(0x4080FF80);
    draw_mesh(water);

    // Draw UI (no depth, alpha blending)
    depth_test(0);
    texture_filter(0);
    draw_sprite(10.0f, 10.0f, 200.0f, 50.0f, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    // Configure console
    set_tick_rate(2);         // 60 fps
    set_clear_color(0x1a1a2eFF);
    render_mode(2);           // PBR lighting
}

export fn render() void {
    // Draw 3D scene
    depth_test(1);
    cull_mode(1);
    blend_mode(0);
    texture_filter(1);

    set_color(0xFFFFFFFF);
    draw_mesh(level);
    draw_mesh(player);

    // Draw transparent water
    blend_mode(1);
    set_color(0x4080FF80);
    draw_mesh(water);

    // Draw UI (no depth, alpha blending)
    depth_test(0);
    texture_filter(0);
    draw_sprite(10.0, 10.0, 200.0, 50.0, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="camera-functions"><a class="header" href="#camera-functions">Camera Functions</a></h1>
<p>Camera position, target, and projection control.</p>
<h2 id="camera-setup"><a class="header" href="#camera-setup">Camera Setup</a></h2>
<h3 id="camera_set"><a class="header" href="#camera_set">camera_set</a></h3>
<p>Sets the camera position and look-at target.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn camera_set(x: f32, y: f32, z: f32, target_x: f32, target_y: f32, target_z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void camera_set(float x, float y, float z, float target_x, float target_y, float target_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn camera_set(x: f32, y: f32, z: f32, target_x: f32, target_y: f32, target_z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x, y, z</td><td><code>f32</code></td><td>Camera position in world space</td></tr>
<tr><td>target_x, target_y, target_z</td><td><code>f32</code></td><td>Point the camera looks at</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Fixed camera looking at origin
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // Third-person follow camera
    camera_set(
        player.x,
        player.y + 3.0,
        player.z + 8.0,
        player.x,
        player.y + 1.0,
        player.z
    );
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Fixed camera looking at origin */
    camera_set(0.0f, 5.0f, 10.0f, 0.0f, 0.0f, 0.0f);

    /* Third-person follow camera */
    camera_set(
        player_x,
        player_y + 3.0f,
        player_z + 8.0f,
        player_x,
        player_y + 1.0f,
        player_z
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Fixed camera looking at origin
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // Third-person follow camera
    camera_set(
        player_x,
        player_y + 3.0,
        player_z + 8.0,
        player_x,
        player_y + 1.0,
        player_z
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="camera_fov"><a class="header" href="#camera_fov">camera_fov</a></h3>
<p>Sets the camera field of view.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn camera_fov(fov_degrees: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void camera_fov(float fov_degrees);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn camera_fov(fov_degrees: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>fov_degrees</td><td><code>f32</code></td><td>Vertical FOV in degrees (1-179)</td></tr>
</tbody>
</table>
</div>
<p><strong>Default:</strong> 60 degrees</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Normal gameplay
    camera_fov(60.0);

    // Zoom in for aiming
    if aiming {
        camera_fov(30.0);
    }

    // Wide angle for racing
    camera_fov(90.0);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Normal gameplay */
    camera_fov(60.0f);

    /* Zoom in for aiming */
    if (aiming) {
        camera_fov(30.0f);
    }

    /* Wide angle for racing */
    camera_fov(90.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Normal gameplay
    camera_fov(60.0);

    // Zoom in for aiming
    if (aiming) {
        camera_fov(30.0);
    }

    // Wide angle for racing
    camera_fov(90.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="custom-matrices"><a class="header" href="#custom-matrices">Custom Matrices</a></h2>
<p>For advanced camera control, you can set the view and projection matrices directly.</p>
<h3 id="push_view_matrix"><a class="header" href="#push_view_matrix">push_view_matrix</a></h3>
<p>Sets a custom view matrix (camera transform).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_view_matrix(
    m0: f32, m1: f32, m2: f32, m3: f32,
    m4: f32, m5: f32, m6: f32, m7: f32,
    m8: f32, m9: f32, m10: f32, m11: f32,
    m12: f32, m13: f32, m14: f32, m15: f32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_view_matrix(
    float m0, float m1, float m2, float m3,
    float m4, float m5, float m6, float m7,
    float m8, float m9, float m10, float m11,
    float m12, float m13, float m14, float m15
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// 16 individual f32 parameters for the 4x4 matrix
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong> 16 floats representing a 4x4 column-major matrix.</p>
<p><strong>Matrix Layout (column-major):</strong></p>
<pre><code>| m0  m4  m8  m12 |
| m1  m5  m9  m13 |
| m2  m6  m10 m14 |
| m3  m7  m11 m15 |
</code></pre>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Using glam for matrix math
    let eye = Vec3::new(0.0, 5.0, 10.0);
    let target = Vec3::new(0.0, 0.0, 0.0);
    let up = Vec3::Y;
    let view = Mat4::look_at_rh(eye, target, up);

    let cols = view.to_cols_array();
    push_view_matrix(
        cols[0], cols[1], cols[2], cols[3],
        cols[4], cols[5], cols[6], cols[7],
        cols[8], cols[9], cols[10], cols[11],
        cols[12], cols[13], cols[14], cols[15]
    );
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Using a math library for matrix calculation */
    float view[16];
    mat4_look_at(view, eye, target, up);

    push_view_matrix(
        view[0], view[1], view[2], view[3],
        view[4], view[5], view[6], view[7],
        view[8], view[9], view[10], view[11],
        view[12], view[13], view[14], view[15]
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Using a math library for matrix calculation
    const view = look_at(eye, target, up);

    // Pass 16 individual floats to push_view_matrix
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="push_projection_matrix"><a class="header" href="#push_projection_matrix">push_projection_matrix</a></h3>
<p>Sets a custom projection matrix.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_projection_matrix(
    m0: f32, m1: f32, m2: f32, m3: f32,
    m4: f32, m5: f32, m6: f32, m7: f32,
    m8: f32, m9: f32, m10: f32, m11: f32,
    m12: f32, m13: f32, m14: f32, m15: f32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_projection_matrix(
    float m0, float m1, float m2, float m3,
    float m4, float m5, float m6, float m7,
    float m8, float m9, float m10, float m11,
    float m12, float m13, float m14, float m15
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// 16 individual f32 parameters for the 4x4 matrix
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Custom perspective projection
    let aspect = 16.0 / 9.0;
    let fov = 60.0_f32.to_radians();
    let near = 0.1;
    let far = 1000.0;
    let proj = Mat4::perspective_rh(fov, aspect, near, far);

    let cols = proj.to_cols_array();
    push_projection_matrix(
        cols[0], cols[1], cols[2], cols[3],
        cols[4], cols[5], cols[6], cols[7],
        cols[8], cols[9], cols[10], cols[11],
        cols[12], cols[13], cols[14], cols[15]
    );

    // Orthographic projection for 2D
    let ortho = Mat4::orthographic_rh(0.0, 960.0, 540.0, 0.0, -1.0, 1.0);
    // ... push_projection_matrix with ortho values
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Custom perspective projection */
    float aspect = 16.0f / 9.0f;
    float fov = 60.0f * 3.14159f / 180.0f;
    float near = 0.1f;
    float far = 1000.0f;
    float proj[16];
    mat4_perspective(proj, fov, aspect, near, far);

    push_projection_matrix(
        proj[0], proj[1], proj[2], proj[3],
        proj[4], proj[5], proj[6], proj[7],
        proj[8], proj[9], proj[10], proj[11],
        proj[12], proj[13], proj[14], proj[15]
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Custom perspective projection
    const aspect = 16.0 / 9.0;
    const fov = 60.0 * std.math.pi / 180.0;
    const near = 0.1;
    const far = 1000.0;
    const proj = perspective(fov, aspect, near, far);

    // Pass 16 individual floats to push_projection_matrix
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="camera-patterns"><a class="header" href="#camera-patterns">Camera Patterns</a></h2>
<h3 id="orbiting-camera"><a class="header" href="#orbiting-camera">Orbiting Camera</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut ORBIT_ANGLE: f32 = 0.0;
static mut ORBIT_DISTANCE: f32 = 10.0;
static mut ORBIT_HEIGHT: f32 = 5.0;

fn update() {
    unsafe {
        // Rotate with right stick
        ORBIT_ANGLE += right_stick_x(0) * 2.0 * delta_time();

        // Zoom with triggers
        ORBIT_DISTANCE -= trigger_right(0) * 5.0 * delta_time();
        ORBIT_DISTANCE += trigger_left(0) * 5.0 * delta_time();
        ORBIT_DISTANCE = ORBIT_DISTANCE.clamp(5.0, 20.0);
    }
}

fn render() {
    unsafe {
        let cam_x = ORBIT_ANGLE.cos() * ORBIT_DISTANCE;
        let cam_z = ORBIT_ANGLE.sin() * ORBIT_DISTANCE;
        camera_set(cam_x, ORBIT_HEIGHT, cam_z, 0.0, 0.0, 0.0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float orbit_angle = 0.0f;
static float orbit_distance = 10.0f;
static float orbit_height = 5.0f;

EWZX_EXPORT void update(void) {
    /* Rotate with right stick */
    orbit_angle += right_stick_x(0) * 2.0f * delta_time();

    /* Zoom with triggers */
    orbit_distance -= trigger_right(0) * 5.0f * delta_time();
    orbit_distance += trigger_left(0) * 5.0f * delta_time();
    orbit_distance = nczx_clampf(orbit_distance, 5.0f, 20.0f);
}

EWZX_EXPORT void render(void) {
    float cam_x = cosf(orbit_angle) * orbit_distance;
    float cam_z = sinf(orbit_angle) * orbit_distance;
    camera_set(cam_x, orbit_height, cam_z, 0.0f, 0.0f, 0.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var orbit_angle: f32 = 0.0;
var orbit_distance: f32 = 10.0;
var orbit_height: f32 = 5.0;

export fn update() void {
    // Rotate with right stick
    orbit_angle += right_stick_x(0) * 2.0 * delta_time();

    // Zoom with triggers
    orbit_distance -= trigger_right(0) * 5.0 * delta_time();
    orbit_distance += trigger_left(0) * 5.0 * delta_time();
    orbit_distance = zx.clampf(orbit_distance, 5.0, 20.0);
}

export fn render() void {
    const cam_x = @cos(orbit_angle) * orbit_distance;
    const cam_z = @sin(orbit_angle) * orbit_distance;
    camera_set(cam_x, orbit_height, cam_z, 0.0, 0.0, 0.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="first-person-camera"><a class="header" href="#first-person-camera">First-Person Camera</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut CAM_X: f32 = 0.0;
static mut CAM_Y: f32 = 1.7; // Eye height
static mut CAM_Z: f32 = 0.0;
static mut CAM_YAW: f32 = 0.0;
static mut CAM_PITCH: f32 = 0.0;

fn update() {
    unsafe {
        // Look with right stick
        CAM_YAW += right_stick_x(0) * 3.0 * delta_time();
        CAM_PITCH -= right_stick_y(0) * 2.0 * delta_time();
        CAM_PITCH = CAM_PITCH.clamp(-1.4, 1.4); // Limit look up/down

        // Move with left stick
        let forward_x = CAM_YAW.sin();
        let forward_z = CAM_YAW.cos();
        let right_x = forward_z;
        let right_z = -forward_x;

        let speed = 5.0 * delta_time();
        CAM_X += left_stick_y(0) * forward_x * speed;
        CAM_Z += left_stick_y(0) * forward_z * speed;
        CAM_X += left_stick_x(0) * right_x * speed;
        CAM_Z += left_stick_x(0) * right_z * speed;
    }
}

fn render() {
    unsafe {
        let look_x = CAM_X + CAM_YAW.sin() * CAM_PITCH.cos();
        let look_y = CAM_Y + CAM_PITCH.sin();
        let look_z = CAM_Z + CAM_YAW.cos() * CAM_PITCH.cos();
        camera_set(CAM_X, CAM_Y, CAM_Z, look_x, look_y, look_z);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float cam_x = 0.0f;
static float cam_y = 1.7f; /* Eye height */
static float cam_z = 0.0f;
static float cam_yaw = 0.0f;
static float cam_pitch = 0.0f;

EWZX_EXPORT void update(void) {
    /* Look with right stick */
    cam_yaw += right_stick_x(0) * 3.0f * delta_time();
    cam_pitch -= right_stick_y(0) * 2.0f * delta_time();
    cam_pitch = nczx_clampf(cam_pitch, -1.4f, 1.4f);

    /* Move with left stick */
    float forward_x = sinf(cam_yaw);
    float forward_z = cosf(cam_yaw);
    float right_x = forward_z;
    float right_z = -forward_x;

    float speed = 5.0f * delta_time();
    cam_x += left_stick_y(0) * forward_x * speed;
    cam_z += left_stick_y(0) * forward_z * speed;
    cam_x += left_stick_x(0) * right_x * speed;
    cam_z += left_stick_x(0) * right_z * speed;
}

EWZX_EXPORT void render(void) {
    float look_x = cam_x + sinf(cam_yaw) * cosf(cam_pitch);
    float look_y = cam_y + sinf(cam_pitch);
    float look_z = cam_z + cosf(cam_yaw) * cosf(cam_pitch);
    camera_set(cam_x, cam_y, cam_z, look_x, look_y, look_z);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var cam_x: f32 = 0.0;
var cam_y: f32 = 1.7; // Eye height
var cam_z: f32 = 0.0;
var cam_yaw: f32 = 0.0;
var cam_pitch: f32 = 0.0;

export fn update() void {
    // Look with right stick
    cam_yaw += right_stick_x(0) * 3.0 * delta_time();
    cam_pitch -= right_stick_y(0) * 2.0 * delta_time();
    cam_pitch = zx.clampf(cam_pitch, -1.4, 1.4);

    // Move with left stick
    const forward_x = @sin(cam_yaw);
    const forward_z = @cos(cam_yaw);
    const right_x = forward_z;
    const right_z = -forward_x;

    const speed = 5.0 * delta_time();
    cam_x += left_stick_y(0) * forward_x * speed;
    cam_z += left_stick_y(0) * forward_z * speed;
    cam_x += left_stick_x(0) * right_x * speed;
    cam_z += left_stick_x(0) * right_z * speed;
}

export fn render() void {
    const look_x = cam_x + @sin(cam_yaw) * @cos(cam_pitch);
    const look_y = cam_y + @sin(cam_pitch);
    const look_z = cam_z + @cos(cam_yaw) * @cos(cam_pitch);
    camera_set(cam_x, cam_y, cam_z, look_x, look_y, look_z);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="split-screen-cameras"><a class="header" href="#split-screen-cameras">Split-Screen Cameras</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    let count = player_count();

    for p in 0..count {
        // Set viewport (would need custom projection)
        setup_viewport_for_player(p, count);

        // Each player's camera follows them
        camera_set(
            players[p].x,
            players[p].y + 5.0,
            players[p].z + 10.0,
            players[p].x,
            players[p].y,
            players[p].z
        );

        draw_scene();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    uint32_t count = player_count();

    for (uint32_t p = 0; p &lt; count; p++) {
        /* Set viewport (would need custom projection) */
        setup_viewport_for_player(p, count);

        /* Each player's camera follows them */
        camera_set(
            players[p].x,
            players[p].y + 5.0f,
            players[p].z + 10.0f,
            players[p].x,
            players[p].y,
            players[p].z
        );

        draw_scene();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    const count = player_count();

    var p: u32 = 0;
    while (p &lt; count) : (p += 1) {
        // Set viewport (would need custom projection)
        setup_viewport_for_player(p, count);

        // Each player's camera follows them
        camera_set(
            players[p].x,
            players[p].y + 5.0,
            players[p].z + 10.0,
            players[p].x,
            players[p].y,
            players[p].z
        );

        draw_scene();
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="transform-functions"><a class="header" href="#transform-functions">Transform Functions</a></h1>
<p>Matrix stack operations for positioning, rotating, and scaling objects.</p>
<h2 id="conventions"><a class="header" href="#conventions">Conventions</a></h2>
<ul>
<li><strong>Y-up</strong> right-handed coordinate system</li>
<li><strong>Column-major</strong> matrix storage (wgpu/WGSL compatible)</li>
<li><strong>Column vectors</strong>: <code>v' = M * v</code></li>
<li><strong>Angles in degrees</strong> for FFI (converted to radians internally)</li>
</ul>
<h2 id="transform-stack"><a class="header" href="#transform-stack">Transform Stack</a></h2>
<h3 id="push_identity"><a class="header" href="#push_identity">push_identity</a></h3>
<p>Resets the current transform to identity (no transformation).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_identity()
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_identity(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_identity() void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Reset before drawing each object
    push_identity();
    draw_mesh(object_a);

    push_identity();
    push_translate(10.0, 0.0, 0.0);
    draw_mesh(object_b);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Reset before drawing each object */
    push_identity();
    draw_mesh(object_a);

    push_identity();
    push_translate(10.0f, 0.0f, 0.0f);
    draw_mesh(object_b);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Reset before drawing each object
    push_identity();
    draw_mesh(object_a);

    push_identity();
    push_translate(10.0, 0.0, 0.0);
    draw_mesh(object_b);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="transform_set"><a class="header" href="#transform_set">transform_set</a></h3>
<p>Sets the current transform from a 4x4 matrix.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn transform_set(matrix_ptr: *const f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void transform_set(const float* matrix_ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn transform_set(matrix_ptr: [*]const f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>matrix_ptr</td><td><code>*const f32</code></td><td>Pointer to 16 floats (4x4 column-major)</td></tr>
</tbody>
</table>
</div>
<p><strong>Matrix Layout (column-major, 16 floats):</strong></p>
<pre><code>[col0.x, col0.y, col0.z, col0.w,
 col1.x, col1.y, col1.z, col1.w,
 col2.x, col2.y, col2.z, col2.w,
 col3.x, col3.y, col3.z, col3.w]
</code></pre>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Using glam
    let transform = Mat4::from_scale_rotation_translation(
        Vec3::ONE,
        Quat::from_rotation_y(angle),
        Vec3::new(x, y, z)
    );

    let cols = transform.to_cols_array();
    transform_set(cols.as_ptr());
    draw_mesh(model);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Using a math library */
    float transform[16];
    mat4_from_translation_rotation_scale(transform, pos, rot, scale);

    transform_set(transform);
    draw_mesh(model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Using a math library
    const transform = from_scale_rotation_translation(scale, rotation, translation);

    transform_set(&amp;transform);
    draw_mesh(model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="translation"><a class="header" href="#translation">Translation</a></h2>
<h3 id="push_translate"><a class="header" href="#push_translate">push_translate</a></h3>
<p>Applies a translation to the current transform.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_translate(x: f32, y: f32, z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_translate(float x, float y, float z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_translate(x: f32, y: f32, z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x</td><td><code>f32</code></td><td>X offset (right is positive)</td></tr>
<tr><td>y</td><td><code>f32</code></td><td>Y offset (up is positive)</td></tr>
<tr><td>z</td><td><code>f32</code></td><td>Z offset (toward camera is positive)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Position object at (10, 5, 0)
    push_identity();
    push_translate(10.0, 5.0, 0.0);
    draw_mesh(object);

    // Stack translations (additive)
    push_identity();
    push_translate(5.0, 0.0, 0.0);  // Move right 5
    push_translate(0.0, 3.0, 0.0);  // Then move up 3
    draw_mesh(object);  // At (5, 3, 0)
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Position object at (10, 5, 0) */
    push_identity();
    push_translate(10.0f, 5.0f, 0.0f);
    draw_mesh(object);

    /* Stack translations (additive) */
    push_identity();
    push_translate(5.0f, 0.0f, 0.0f);  /* Move right 5 */
    push_translate(0.0f, 3.0f, 0.0f);  /* Then move up 3 */
    draw_mesh(object);  /* At (5, 3, 0) */
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Position object at (10, 5, 0)
    push_identity();
    push_translate(10.0, 5.0, 0.0);
    draw_mesh(object);

    // Stack translations (additive)
    push_identity();
    push_translate(5.0, 0.0, 0.0);  // Move right 5
    push_translate(0.0, 3.0, 0.0);  // Then move up 3
    draw_mesh(object);  // At (5, 3, 0)
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="rotation"><a class="header" href="#rotation">Rotation</a></h2>
<h3 id="push_rotate_x"><a class="header" href="#push_rotate_x">push_rotate_x</a></h3>
<p>Rotates around the X axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_rotate_x(angle_deg: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_rotate_x(float angle_deg);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_rotate_x(angle_deg: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>angle_deg</td><td><code>f32</code></td><td>Rotation angle in degrees</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_rotate_x(45.0); // Tilt forward 45 degrees
    draw_mesh(object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_rotate_x(45.0f); /* Tilt forward 45 degrees */
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_rotate_x(45.0); // Tilt forward 45 degrees
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="push_rotate_y"><a class="header" href="#push_rotate_y">push_rotate_y</a></h3>
<p>Rotates around the Y axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_rotate_y(angle_deg: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_rotate_y(float angle_deg);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_rotate_y(angle_deg: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_rotate_y(elapsed_time() * 90.0); // Spin 90 deg/sec
    draw_mesh(spinning_object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_rotate_y(elapsed_time() * 90.0f); /* Spin 90 deg/sec */
    draw_mesh(spinning_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_rotate_y(elapsed_time() * 90.0); // Spin 90 deg/sec
    draw_mesh(spinning_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="push_rotate_z"><a class="header" href="#push_rotate_z">push_rotate_z</a></h3>
<p>Rotates around the Z axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_rotate_z(angle_deg: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_rotate_z(float angle_deg);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_rotate_z(angle_deg: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_rotate_z(45.0); // Roll 45 degrees
    draw_mesh(object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_rotate_z(45.0f); /* Roll 45 degrees */
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_rotate_z(45.0); // Roll 45 degrees
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="push_rotate"><a class="header" href="#push_rotate">push_rotate</a></h3>
<p>Rotates around an arbitrary axis.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_rotate(angle_deg: f32, axis_x: f32, axis_y: f32, axis_z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_rotate(float angle_deg, float axis_x, float axis_y, float axis_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_rotate(angle_deg: f32, axis_x: f32, axis_y: f32, axis_z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>angle_deg</td><td><code>f32</code></td><td>Rotation angle in degrees</td></tr>
<tr><td>axis_x, axis_y, axis_z</td><td><code>f32</code></td><td>Rotation axis (will be normalized)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    // Rotate around diagonal axis
    push_rotate(45.0, 1.0, 1.0, 0.0);
    draw_mesh(object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    /* Rotate around diagonal axis */
    push_rotate(45.0f, 1.0f, 1.0f, 0.0f);
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    // Rotate around diagonal axis
    push_rotate(45.0, 1.0, 1.0, 0.0);
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="scale"><a class="header" href="#scale">Scale</a></h2>
<h3 id="push_scale"><a class="header" href="#push_scale">push_scale</a></h3>
<p>Applies non-uniform scaling.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_scale(x: f32, y: f32, z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_scale(float x, float y, float z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_scale(x: f32, y: f32, z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x</td><td><code>f32</code></td><td>Scale factor on X axis</td></tr>
<tr><td>y</td><td><code>f32</code></td><td>Scale factor on Y axis</td></tr>
<tr><td>z</td><td><code>f32</code></td><td>Scale factor on Z axis</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_scale(2.0, 1.0, 1.0); // Stretch horizontally
    draw_mesh(object);

    push_identity();
    push_scale(1.0, 0.5, 1.0); // Squash vertically
    draw_mesh(squashed);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_scale(2.0f, 1.0f, 1.0f); /* Stretch horizontally */
    draw_mesh(object);

    push_identity();
    push_scale(1.0f, 0.5f, 1.0f); /* Squash vertically */
    draw_mesh(squashed);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_scale(2.0, 1.0, 1.0); // Stretch horizontally
    draw_mesh(object);

    push_identity();
    push_scale(1.0, 0.5, 1.0); // Squash vertically
    draw_mesh(squashed);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="push_scale_uniform"><a class="header" href="#push_scale_uniform">push_scale_uniform</a></h3>
<p>Applies uniform scaling (same factor on all axes).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn push_scale_uniform(s: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void push_scale_uniform(float s);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn push_scale_uniform(s: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>s</td><td><code>f32</code></td><td>Uniform scale factor</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_scale_uniform(2.0); // Double size
    draw_mesh(big_object);

    push_identity();
    push_scale_uniform(0.5); // Half size
    draw_mesh(small_object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_scale_uniform(2.0f); /* Double size */
    draw_mesh(big_object);

    push_identity();
    push_scale_uniform(0.5f); /* Half size */
    draw_mesh(small_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_scale_uniform(2.0); // Double size
    draw_mesh(big_object);

    push_identity();
    push_scale_uniform(0.5); // Half size
    draw_mesh(small_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="transform-order"><a class="header" href="#transform-order">Transform Order</a></h2>
<p>Transforms are applied in <strong>reverse order</strong> of function calls (right-to-left matrix multiplication).</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_translate(5.0, 0.0, 0.0);  // Applied LAST
    push_rotate_y(45.0);             // Applied SECOND
    push_scale_uniform(2.0);         // Applied FIRST
    draw_mesh(object);

    // Equivalent to: Translate * Rotate * Scale * vertex
    // Object is: 1) scaled, 2) rotated, 3) translated
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_translate(5.0f, 0.0f, 0.0f);  /* Applied LAST */
    push_rotate_y(45.0f);               /* Applied SECOND */
    push_scale_uniform(2.0f);           /* Applied FIRST */
    draw_mesh(object);

    /* Equivalent to: Translate * Rotate * Scale * vertex */
    /* Object is: 1) scaled, 2) rotated, 3) translated */
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_translate(5.0, 0.0, 0.0);  // Applied LAST
    push_rotate_y(45.0);             // Applied SECOND
    push_scale_uniform(2.0);         // Applied FIRST
    draw_mesh(object);

    // Equivalent to: Translate * Rotate * Scale * vertex
    // Object is: 1) scaled, 2) rotated, 3) translated
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h3>
<p><strong>Object at position with rotation:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>push_identity();
push_translate(obj.x, obj.y, obj.z);  // Position
push_rotate_y(obj.rotation);           // Then rotate
draw_mesh(obj.mesh);
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">push_identity();
push_translate(obj_x, obj_y, obj_z);  /* Position */
push_rotate_y(obj_rotation);           /* Then rotate */
draw_mesh(obj_mesh);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">push_identity();
push_translate(obj.x, obj.y, obj.z);  // Position
push_rotate_y(obj.rotation);           // Then rotate
draw_mesh(obj.mesh);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Hierarchical transforms (parent-child):</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Tank body
    push_identity();
    push_translate(tank.x, tank.y, tank.z);
    push_rotate_y(tank.body_angle);
    draw_mesh(tank_body);

    // Turret (inherits body transform, then adds its own)
    push_translate(0.0, 1.0, 0.0);     // Offset from body
    push_rotate_y(tank.turret_angle);  // Independent rotation
    draw_mesh(tank_turret);

    // Barrel (inherits turret transform)
    push_translate(0.0, 0.5, 2.0);
    push_rotate_x(tank.barrel_pitch);
    draw_mesh(tank_barrel);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    /* Tank body */
    push_identity();
    push_translate(tank_x, tank_y, tank_z);
    push_rotate_y(tank_body_angle);
    draw_mesh(tank_body);

    /* Turret (inherits body transform, then adds its own) */
    push_translate(0.0f, 1.0f, 0.0f);     /* Offset from body */
    push_rotate_y(tank_turret_angle);     /* Independent rotation */
    draw_mesh(tank_turret);

    /* Barrel (inherits turret transform) */
    push_translate(0.0f, 0.5f, 2.0f);
    push_rotate_x(tank_barrel_pitch);
    draw_mesh(tank_barrel);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Tank body
    push_identity();
    push_translate(tank.x, tank.y, tank.z);
    push_rotate_y(tank.body_angle);
    draw_mesh(tank_body);

    // Turret (inherits body transform, then adds its own)
    push_translate(0.0, 1.0, 0.0);     // Offset from body
    push_rotate_y(tank.turret_angle);  // Independent rotation
    draw_mesh(tank_turret);

    // Barrel (inherits turret transform)
    push_translate(0.0, 0.5, 2.0);
    push_rotate_x(tank.barrel_pitch);
    draw_mesh(tank_barrel);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Rotating around a pivot point:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    push_identity();
    push_translate(pivot_x, pivot_y, pivot_z);  // Move to pivot
    push_rotate_y(angle);                        // Rotate
    push_translate(-pivot_x, -pivot_y, -pivot_z); // Move back
    draw_mesh(object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    push_identity();
    push_translate(pivot_x, pivot_y, pivot_z);  /* Move to pivot */
    push_rotate_y(angle);                        /* Rotate */
    push_translate(-pivot_x, -pivot_y, -pivot_z); /* Move back */
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    push_identity();
    push_translate(pivot_x, pivot_y, pivot_z);  // Move to pivot
    push_rotate_y(angle);                        // Rotate
    push_translate(-pivot_x, -pivot_y, -pivot_z); // Move back
    draw_mesh(object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut ANGLE: f32 = 0.0;

fn update() {
    unsafe {
        ANGLE += 90.0 * delta_time(); // 90 degrees per second
    }
}

fn render() {
    unsafe {
        camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

        // Spinning cube at origin
        push_identity();
        push_rotate_y(ANGLE);
        draw_mesh(cube);

        // Orbiting cube
        push_identity();
        push_rotate_y(ANGLE * 0.5);    // Orbital rotation
        push_translate(5.0, 0.0, 0.0);  // Distance from center
        push_rotate_y(ANGLE * 2.0);     // Spin on own axis
        push_scale_uniform(0.5);
        draw_mesh(cube);

        // Static cube for reference
        push_identity();
        push_translate(-5.0, 0.0, 0.0);
        draw_mesh(cube);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float angle = 0.0f;

EWZX_EXPORT void update(void) {
    angle += 90.0f * delta_time(); /* 90 degrees per second */
}

EWZX_EXPORT void render(void) {
    camera_set(0.0f, 5.0f, 10.0f, 0.0f, 0.0f, 0.0f);

    /* Spinning cube at origin */
    push_identity();
    push_rotate_y(angle);
    draw_mesh(cube);

    /* Orbiting cube */
    push_identity();
    push_rotate_y(angle * 0.5f);    /* Orbital rotation */
    push_translate(5.0f, 0.0f, 0.0f);  /* Distance from center */
    push_rotate_y(angle * 2.0f);     /* Spin on own axis */
    push_scale_uniform(0.5f);
    draw_mesh(cube);

    /* Static cube for reference */
    push_identity();
    push_translate(-5.0f, 0.0f, 0.0f);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var angle: f32 = 0.0;

export fn update() void {
    angle += 90.0 * delta_time(); // 90 degrees per second
}

export fn render() void {
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // Spinning cube at origin
    push_identity();
    push_rotate_y(angle);
    draw_mesh(cube);

    // Orbiting cube
    push_identity();
    push_rotate_y(angle * 0.5);    // Orbital rotation
    push_translate(5.0, 0.0, 0.0);  // Distance from center
    push_rotate_y(angle * 2.0);     // Spin on own axis
    push_scale_uniform(0.5);
    draw_mesh(cube);

    // Static cube for reference
    push_identity();
    push_translate(-5.0, 0.0, 0.0);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="texture-functions"><a class="header" href="#texture-functions">Texture Functions</a></h1>
<p>Loading, binding, and configuring textures.</p>
<h2 id="loading-textures"><a class="header" href="#loading-textures">Loading Textures</a></h2>
<h3 id="load_texture"><a class="header" href="#load_texture">load_texture</a></h3>
<p>Loads an RGBA8 texture from WASM memory.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_texture(width: u32, height: u32, pixels: *const u8) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_texture(uint32_t width, uint32_t height, const uint8_t* pixels);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_texture(width: u32, height: u32, pixels: [*]const u8) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>width</td><td><code>u32</code></td><td>Texture width in pixels</td></tr>
<tr><td>height</td><td><code>u32</code></td><td>Texture height in pixels</td></tr>
<tr><td>pixels</td><td><code>*const u8</code></td><td>Pointer to RGBA8 pixel data (4 bytes per pixel)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Texture handle (non-zero on success)</p>
<p><strong>Constraints:</strong> Init-only. Must be called in <code>init()</code>.</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PLAYER_TEX: u32 = 0;

// Embedded pixel data (8x8 checkerboard)
const CHECKER: [u8; 8 * 8 * 4] = {
    let mut pixels = [0u8; 256];
    let mut i = 0;
    while i &lt; 64 {
        let x = i % 8;
        let y = i / 8;
        let white = ((x + y) % 2) == 0;
        let idx = i * 4;
        pixels[idx] = if white { 255 } else { 0 };     // R
        pixels[idx + 1] = if white { 255 } else { 0 }; // G
        pixels[idx + 2] = if white { 255 } else { 0 }; // B
        pixels[idx + 3] = 255;                          // A
        i += 1;
    }
    pixels
};

fn init() {
    unsafe {
        PLAYER_TEX = load_texture(8, 8, CHECKER.as_ptr());
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t player_tex = 0;

// Embedded pixel data (8x8 checkerboard)
static const uint8_t CHECKER[8 * 8 * 4] = {
    // Row 0
    255,255,255,255, 0,0,0,255, 255,255,255,255, 0,0,0,255,
    255,255,255,255, 0,0,0,255, 255,255,255,255, 0,0,0,255,
    // Row 1
    0,0,0,255, 255,255,255,255, 0,0,0,255, 255,255,255,255,
    0,0,0,255, 255,255,255,255, 0,0,0,255, 255,255,255,255,
    // ... (repeat pattern for remaining rows)
};

EWZX_EXPORT void init(void) {
    player_tex = load_texture(8, 8, CHECKER);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var player_tex: u32 = 0;

// Embedded pixel data (8x8 checkerboard)
const CHECKER: [8 * 8 * 4]u8 = blk: {
    var pixels: [256]u8 = undefined;
    var i: usize = 0;
    while (i &lt; 64) : (i += 1) {
        const x = i % 8;
        const y = i / 8;
        const white = ((x + y) % 2) == 0;
        const idx = i * 4;
        const c: u8 = if (white) 255 else 0;
        pixels[idx] = c;
        pixels[idx + 1] = c;
        pixels[idx + 2] = c;
        pixels[idx + 3] = 255;
    }
    break :blk pixels;
};

export fn init() void {
    player_tex = load_texture(8, 8, &amp;CHECKER);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Note:</strong> Prefer <code>rom_texture()</code> for assets bundled in the ROM data pack.</p>
<p><strong>See Also:</strong> <a href="#rom_texture">rom_texture</a></p>
<hr>
<h2 id="binding-textures"><a class="header" href="#binding-textures">Binding Textures</a></h2>
<h3 id="texture_bind"><a class="header" href="#texture_bind">texture_bind</a></h3>
<p>Binds a texture to slot 0 (albedo/diffuse).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn texture_bind(handle: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void texture_bind(uint32_t handle);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn texture_bind(handle: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>handle</td><td><code>u32</code></td><td>Texture handle from <code>load_texture()</code> or <code>rom_texture()</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(player_tex);
    draw_mesh(player_model);

    texture_bind(enemy_tex);
    draw_mesh(enemy_model);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    texture_bind(player_tex);
    draw_mesh(player_model);

    texture_bind(enemy_tex);
    draw_mesh(enemy_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(player_tex);
    draw_mesh(player_model);

    texture_bind(enemy_tex);
    draw_mesh(enemy_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="texture_bind_slot"><a class="header" href="#texture_bind_slot">texture_bind_slot</a></h3>
<p>Binds a texture to a specific slot.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn texture_bind_slot(handle: u32, slot: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void texture_bind_slot(uint32_t handle, uint32_t slot);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn texture_bind_slot(handle: u32, slot: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>handle</td><td><code>u32</code></td><td>Texture handle</td></tr>
<tr><td>slot</td><td><code>u32</code></td><td>Texture slot (0-3)</td></tr>
</tbody>
</table>
</div>
<p><strong>Texture Slots:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Slot</th><th>Purpose</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Albedo/diffuse texture</td></tr>
<tr><td>1</td><td>MRE texture (Mode 2) or Specular (Mode 3)</td></tr>
<tr><td>2</td><td>Reserved</td></tr>
<tr><td>3</td><td>Reserved</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Bind albedo to slot 0
    texture_bind_slot(albedo_tex, 0);

    // Bind MRE (Metallic/Roughness/Emissive) to slot 1
    texture_bind_slot(mre_tex, 1);

    draw_mesh(pbr_model);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Bind albedo to slot 0
    texture_bind_slot(albedo_tex, 0);

    // Bind MRE (Metallic/Roughness/Emissive) to slot 1
    texture_bind_slot(mre_tex, 1);

    draw_mesh(pbr_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Bind albedo to slot 0
    texture_bind_slot(albedo_tex, 0);

    // Bind MRE (Metallic/Roughness/Emissive) to slot 1
    texture_bind_slot(mre_tex, 1);

    draw_mesh(pbr_model);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="matcap-textures"><a class="header" href="#matcap-textures">Matcap Textures</a></h2>
<h3 id="matcap_blend_mode"><a class="header" href="#matcap_blend_mode">matcap_blend_mode</a></h3>
<p>Sets the blend mode for a matcap texture slot.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn matcap_blend_mode(slot: u32, mode: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void matcap_blend_mode(uint32_t slot, uint32_t mode);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn matcap_blend_mode(slot: u32, mode: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>slot</td><td><code>u32</code></td><td>Matcap slot (1-3)</td></tr>
<tr><td>mode</td><td><code>u32</code></td><td>Blend mode</td></tr>
</tbody>
</table>
</div>
<p><strong>Blend Modes:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Mode</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Multiply</td><td>Darkens (shadows, ambient occlusion)</td></tr>
<tr><td>1</td><td>Add</td><td>Brightens (highlights, rim light)</td></tr>
<tr><td>2</td><td>HSV Modulate</td><td>Hue/saturation shift</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(1); // Matcap mode
}

fn render() {
    // Dark matcap for shadows (multiply)
    matcap_set(1, shadow_matcap);
    matcap_blend_mode(1, 0);

    // Bright matcap for highlights (add)
    matcap_set(2, highlight_matcap);
    matcap_blend_mode(2, 1);

    texture_bind(albedo_tex);
    draw_mesh(character);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(1); // Matcap mode
}

EWZX_EXPORT void render(void) {
    // Dark matcap for shadows (multiply)
    matcap_set(1, shadow_matcap);
    matcap_blend_mode(1, 0);

    // Bright matcap for highlights (add)
    matcap_set(2, highlight_matcap);
    matcap_blend_mode(2, 1);

    texture_bind(albedo_tex);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(1); // Matcap mode
}

export fn render() void {
    // Dark matcap for shadows (multiply)
    matcap_set(1, shadow_matcap);
    matcap_blend_mode(1, 0);

    // Bright matcap for highlights (add)
    matcap_set(2, highlight_matcap);
    matcap_blend_mode(2, 1);

    texture_bind(albedo_tex);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#matcap_set">matcap_set</a>, <a href="#render-modes-guide">Render Modes Guide</a></p>
<hr>
<h2 id="texture-formats"><a class="header" href="#texture-formats">Texture Formats</a></h2>
<h3 id="rgba8"><a class="header" href="#rgba8">RGBA8</a></h3>
<p>Standard 8-bit RGBA format. 4 bytes per pixel.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Pixel layout: [R, G, B, A, R, G, B, A, ...]
let pixels: [u8; 4 * 4 * 4] = [
    255, 0, 0, 255,    // Red pixel
    0, 255, 0, 255,    // Green pixel
    0, 0, 255, 255,    // Blue pixel
    255, 255, 255, 128, // Semi-transparent white
    // ... more pixels
];
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Pixel layout: [R, G, B, A, R, G, B, A, ...]
uint8_t pixels[4 * 4 * 4] = {
    255, 0, 0, 255,    // Red pixel
    0, 255, 0, 255,    // Green pixel
    0, 0, 255, 255,    // Blue pixel
    255, 255, 255, 128, // Semi-transparent white
    // ... more pixels
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Pixel layout: [R, G, B, A, R, G, B, A, ...]
const pixels = [_]u8{
    255, 0, 0, 255,    // Red pixel
    0, 255, 0, 255,    // Green pixel
    0, 0, 255, 255,    // Blue pixel
    255, 255, 255, 128, // Semi-transparent white
    // ... more pixels
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="texture-tips"><a class="header" href="#texture-tips">Texture Tips</a></h3>
<ul>
<li><strong>Power-of-two</strong> dimensions recommended (8, 16, 32, 64, 128, 256, 512)</li>
<li><strong>Texture atlases</strong> reduce bind calls and improve batching</li>
<li>Use <code>rom_texture()</code> for large textures (bypasses WASM memory)</li>
<li>Use <code>load_texture()</code> only for small procedural/runtime textures</li>
</ul>
<hr>
<h2 id="complete-example-2"><a class="header" href="#complete-example-2">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut CHECKER_TEX: u32 = 0;
static mut GRADIENT_TEX: u32 = 0;

// Generate checkerboard at compile time
const CHECKER_PIXELS: [u8; 16 * 16 * 4] = {
    let mut pixels = [0u8; 16 * 16 * 4];
    let mut i = 0;
    while i &lt; 256 {
        let x = i % 16;
        let y = i / 16;
        let white = ((x / 2 + y / 2) % 2) == 0;
        let idx = i * 4;
        let c = if white { 200 } else { 50 };
        pixels[idx] = c;
        pixels[idx + 1] = c;
        pixels[idx + 2] = c;
        pixels[idx + 3] = 255;
        i += 1;
    }
    pixels
};

// Generate gradient at compile time
const GRADIENT_PIXELS: [u8; 8 * 8 * 4] = {
    let mut pixels = [0u8; 8 * 8 * 4];
    let mut i = 0;
    while i &lt; 64 {
        let x = i % 8;
        let y = i / 8;
        let idx = i * 4;
        pixels[idx] = (x * 32) as u8;     // R increases right
        pixels[idx + 1] = (y * 32) as u8; // G increases down
        pixels[idx + 2] = 128;             // B constant
        pixels[idx + 3] = 255;
        i += 1;
    }
    pixels
};

fn init() {
    unsafe {
        CHECKER_TEX = load_texture(16, 16, CHECKER_PIXELS.as_ptr());
        GRADIENT_TEX = load_texture(8, 8, GRADIENT_PIXELS.as_ptr());
    }
}

fn render() {
    unsafe {
        // Draw floor with checker texture
        texture_bind(CHECKER_TEX);
        texture_filter(0); // Nearest for crisp pixels
        push_identity();
        push_scale(10.0, 1.0, 10.0);
        draw_mesh(plane);

        // Draw object with gradient
        texture_bind(GRADIENT_TEX);
        texture_filter(1); // Linear for smooth
        push_identity();
        push_translate(0.0, 1.0, 0.0);
        draw_mesh(cube);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t checker_tex = 0;
static uint32_t gradient_tex = 0;

// Pre-generated checker pattern (16x16)
static const uint8_t CHECKER_PIXELS[16 * 16 * 4] = { /* ... */ };

// Pre-generated gradient (8x8)
static const uint8_t GRADIENT_PIXELS[8 * 8 * 4] = { /* ... */ };

EWZX_EXPORT void init(void) {
    checker_tex = load_texture(16, 16, CHECKER_PIXELS);
    gradient_tex = load_texture(8, 8, GRADIENT_PIXELS);
}

EWZX_EXPORT void render(void) {
    // Draw floor with checker texture
    texture_bind(checker_tex);
    texture_filter(0); // Nearest for crisp pixels
    push_identity();
    push_scale(10.0f, 1.0f, 10.0f);
    draw_mesh(plane);

    // Draw object with gradient
    texture_bind(gradient_tex);
    texture_filter(1); // Linear for smooth
    push_identity();
    push_translate(0.0f, 1.0f, 0.0f);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var checker_tex: u32 = 0;
var gradient_tex: u32 = 0;

// Generate checkerboard at compile time
const CHECKER_PIXELS: [16 * 16 * 4]u8 = blk: {
    var pixels: [16 * 16 * 4]u8 = undefined;
    var i: usize = 0;
    while (i &lt; 256) : (i += 1) {
        const x = i % 16;
        const y = i / 16;
        const white = ((x / 2 + y / 2) % 2) == 0;
        const idx = i * 4;
        const c: u8 = if (white) 200 else 50;
        pixels[idx] = c;
        pixels[idx + 1] = c;
        pixels[idx + 2] = c;
        pixels[idx + 3] = 255;
    }
    break :blk pixels;
};

// Generate gradient at compile time
const GRADIENT_PIXELS: [8 * 8 * 4]u8 = blk: {
    var pixels: [8 * 8 * 4]u8 = undefined;
    var i: usize = 0;
    while (i &lt; 64) : (i += 1) {
        const x = i % 8;
        const y = i / 8;
        const idx = i * 4;
        pixels[idx] = @intCast(x * 32);
        pixels[idx + 1] = @intCast(y * 32);
        pixels[idx + 2] = 128;
        pixels[idx + 3] = 255;
    }
    break :blk pixels;
};

export fn init() void {
    checker_tex = load_texture(16, 16, &amp;CHECKER_PIXELS);
    gradient_tex = load_texture(8, 8, &amp;GRADIENT_PIXELS);
}

export fn render() void {
    // Draw floor with checker texture
    texture_bind(checker_tex);
    texture_filter(0); // Nearest for crisp pixels
    push_identity();
    push_scale(10.0, 1.0, 10.0);
    draw_mesh(plane);

    // Draw object with gradient
    texture_bind(gradient_tex);
    texture_filter(1); // Linear for smooth
    push_identity();
    push_translate(0.0, 1.0, 0.0);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="mesh-functions"><a class="header" href="#mesh-functions">Mesh Functions</a></h1>
<p>Loading and drawing 3D meshes.</p>
<h2 id="retained-meshes"><a class="header" href="#retained-meshes">Retained Meshes</a></h2>
<p>Retained meshes are loaded once in <code>init()</code> and drawn multiple times in <code>render()</code>.</p>
<h3 id="load_mesh"><a class="header" href="#load_mesh">load_mesh</a></h3>
<p>Loads a non-indexed mesh from vertex data.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_mesh(data_ptr: *const u8, vertex_count: u32, format: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh(const uint8_t* data_ptr, uint32_t vertex_count, uint32_t format);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh(data_ptr: [*]const u8, vertex_count: u32, format: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to vertex data</td></tr>
<tr><td>vertex_count</td><td><code>u32</code></td><td>Number of vertices</td></tr>
<tr><td>format</td><td><code>u32</code></td><td>Vertex format flags</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle (non-zero on success)</p>
<p><strong>Constraints:</strong> Init-only.</p>
<hr>
<h3 id="load_mesh_indexed"><a class="header" href="#load_mesh_indexed">load_mesh_indexed</a></h3>
<p>Loads an indexed mesh (more efficient for shared vertices).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_mesh_indexed(
    data_ptr: *const u8,
    vertex_count: u32,
    index_ptr: *const u16,
    index_count: u32,
    format: u32
) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh_indexed(
    const uint8_t* data_ptr,
    uint32_t vertex_count,
    const uint16_t* index_ptr,
    uint32_t index_count,
    uint32_t format
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh_indexed(
    data_ptr: [*]const u8,
    vertex_count: u32,
    index_ptr: [*]const u16,
    index_count: u32,
    format: u32,
) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to vertex data</td></tr>
<tr><td>vertex_count</td><td><code>u32</code></td><td>Number of vertices</td></tr>
<tr><td>index_ptr</td><td><code>*const u16</code></td><td>Pointer to u16 index data</td></tr>
<tr><td>index_count</td><td><code>u32</code></td><td>Number of indices</td></tr>
<tr><td>format</td><td><code>u32</code></td><td>Vertex format flags</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut CUBE_MESH: u32 = 0;

// Cube with 8 vertices, 36 indices (12 triangles)
const CUBE_VERTS: [f32; 8 * 6] = [
    // Position (xyz) + Normal (xyz)
    -1.0, -1.0, -1.0,  0.0, 0.0, -1.0,
     1.0, -1.0, -1.0,  0.0, 0.0, -1.0,
    // ... more vertices
];

const CUBE_INDICES: [u16; 36] = [
    0, 1, 2, 2, 3, 0, // Front face
    // ... more indices
];

fn init() {
    unsafe {
        CUBE_MESH = load_mesh_indexed(
            CUBE_VERTS.as_ptr() as *const u8,
            8,
            CUBE_INDICES.as_ptr(),
            36,
            4 // FORMAT_POS_NORMAL
        );
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t cube_mesh = 0;

// Cube with 8 vertices, 36 indices (12 triangles)
static const float CUBE_VERTS[8 * 6] = {
    // Position (xyz) + Normal (xyz)
    -1.0f, -1.0f, -1.0f,  0.0f, 0.0f, -1.0f,
     1.0f, -1.0f, -1.0f,  0.0f, 0.0f, -1.0f,
    // ... more vertices
};

static const uint16_t CUBE_INDICES[36] = {
    0, 1, 2, 2, 3, 0, // Front face
    // ... more indices
};

EWZX_EXPORT void init(void) {
    cube_mesh = load_mesh_indexed(
        (const uint8_t*)CUBE_VERTS,
        8,
        CUBE_INDICES,
        36,
        4 // FORMAT_POS_NORMAL
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var cube_mesh: u32 = 0;

// Cube with 8 vertices, 36 indices (12 triangles)
const CUBE_VERTS = [_]f32{
    // Position (xyz) + Normal (xyz)
    -1.0, -1.0, -1.0, 0.0, 0.0, -1.0,
    1.0,  -1.0, -1.0, 0.0, 0.0, -1.0,
    // ... more vertices
};

const CUBE_INDICES = [_]u16{
    0, 1, 2, 2, 3, 0, // Front face
    // ... more indices
};

export fn init() void {
    cube_mesh = load_mesh_indexed(
        @ptrCast(&amp;CUBE_VERTS),
        8,
        &amp;CUBE_INDICES,
        36,
        4, // FORMAT_POS_NORMAL
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="load_mesh_packed"><a class="header" href="#load_mesh_packed">load_mesh_packed</a></h3>
<p>Loads a packed mesh with half-precision floats (smaller memory footprint).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_mesh_packed(data_ptr: *const u8, vertex_count: u32, format: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh_packed(const uint8_t* data_ptr, uint32_t vertex_count, uint32_t format);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh_packed(data_ptr: [*]const u8, vertex_count: u32, format: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Constraints:</strong> Init-only. Uses f16 for positions and snorm16 for normals.</p>
<hr>
<h3 id="load_mesh_indexed_packed"><a class="header" href="#load_mesh_indexed_packed">load_mesh_indexed_packed</a></h3>
<p>Loads an indexed packed mesh.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_mesh_indexed_packed(
    data_ptr: *const u8,
    vertex_count: u32,
    index_ptr: *const u16,
    index_count: u32,
    format: u32
) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_mesh_indexed_packed(
    const uint8_t* data_ptr,
    uint32_t vertex_count,
    const uint16_t* index_ptr,
    uint32_t index_count,
    uint32_t format
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_mesh_indexed_packed(
    data_ptr: [*]const u8,
    vertex_count: u32,
    index_ptr: [*]const u16,
    index_count: u32,
    format: u32,
) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Constraints:</strong> Init-only.</p>
<hr>
<h3 id="draw_mesh"><a class="header" href="#draw_mesh">draw_mesh</a></h3>
<p>Draws a retained mesh with the current transform and render state.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_mesh(handle: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_mesh(uint32_t handle);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_mesh(handle: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>handle</td><td><code>u32</code></td><td>Mesh handle from <code>load_mesh*()</code> or procedural generators</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Draw at origin
    push_identity();
    draw_mesh(cube);

    // Draw at different position
    push_identity();
    push_translate(5.0, 0.0, 0.0);
    draw_mesh(cube);

    // Draw with different color
    set_color(0xFF0000FF);
    push_identity();
    push_translate(-5.0, 0.0, 0.0);
    draw_mesh(cube);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Draw at origin
    push_identity();
    draw_mesh(cube);

    // Draw at different position
    push_identity();
    push_translate(5.0f, 0.0f, 0.0f);
    draw_mesh(cube);

    // Draw with different color
    set_color(0xFF0000FF);
    push_identity();
    push_translate(-5.0f, 0.0f, 0.0f);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Draw at origin
    push_identity();
    draw_mesh(cube);

    // Draw at different position
    push_identity();
    push_translate(5.0, 0.0, 0.0);
    draw_mesh(cube);

    // Draw with different color
    set_color(0xFF0000FF);
    push_identity();
    push_translate(-5.0, 0.0, 0.0);
    draw_mesh(cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="immediate-mode-drawing"><a class="header" href="#immediate-mode-drawing">Immediate Mode Drawing</a></h2>
<p>For dynamic geometry that changes every frame.</p>
<h3 id="draw_triangles"><a class="header" href="#draw_triangles">draw_triangles</a></h3>
<p>Draws non-indexed triangles immediately (not retained).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_triangles(data_ptr: *const u8, vertex_count: u32, format: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_triangles(const uint8_t* data_ptr, uint32_t vertex_count, uint32_t format);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_triangles(data_ptr: [*]const u8, vertex_count: u32, format: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to vertex data</td></tr>
<tr><td>vertex_count</td><td><code>u32</code></td><td>Number of vertices (must be multiple of 3)</td></tr>
<tr><td>format</td><td><code>u32</code></td><td>Vertex format flags</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Dynamic triangle
    let verts: [f32; 18] = [
        // Position (xyz) + Color (rgb)
        0.0, 1.0, 0.0,  1.0, 0.0, 0.0, // Top (red)
        -1.0, -1.0, 0.0,  0.0, 1.0, 0.0, // Left (green)
        1.0, -1.0, 0.0,  0.0, 0.0, 1.0, // Right (blue)
    ];

    push_identity();
    draw_triangles(verts.as_ptr() as *const u8, 3, 2); // FORMAT_POS_COLOR
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Dynamic triangle
    float verts[18] = {
        // Position (xyz) + Color (rgb)
        0.0f, 1.0f, 0.0f,  1.0f, 0.0f, 0.0f, // Top (red)
        -1.0f, -1.0f, 0.0f,  0.0f, 1.0f, 0.0f, // Left (green)
        1.0f, -1.0f, 0.0f,  0.0f, 0.0f, 1.0f, // Right (blue)
    };

    push_identity();
    draw_triangles((const uint8_t*)verts, 3, 2); // FORMAT_POS_COLOR
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Dynamic triangle
    const verts = [_]f32{
        // Position (xyz) + Color (rgb)
        0.0, 1.0, 0.0, 1.0, 0.0, 0.0, // Top (red)
        -1.0, -1.0, 0.0, 0.0, 1.0, 0.0, // Left (green)
        1.0, -1.0, 0.0, 0.0, 0.0, 1.0, // Right (blue)
    };

    push_identity();
    draw_triangles(@ptrCast(&amp;verts), 3, 2); // FORMAT_POS_COLOR
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="draw_triangles_indexed"><a class="header" href="#draw_triangles_indexed">draw_triangles_indexed</a></h3>
<p>Draws indexed triangles immediately.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_triangles_indexed(
    data_ptr: *const u8,
    vertex_count: u32,
    index_ptr: *const u16,
    index_count: u32,
    format: u32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_triangles_indexed(
    const uint8_t* data_ptr,
    uint32_t vertex_count,
    const uint16_t* index_ptr,
    uint32_t index_count,
    uint32_t format
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_triangles_indexed(
    data_ptr: [*]const u8,
    vertex_count: u32,
    index_ptr: [*]const u16,
    index_count: u32,
    format: u32,
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="vertex-formats-1"><a class="header" href="#vertex-formats-1">Vertex Formats</a></h2>
<p>Vertex format is specified as a bitmask of flags:</p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Flag</th><th>Value</th><th>Components</th><th>Bytes</th></tr>
</thead>
<tbody>
<tr><td>Position</td><td>0</td><td>xyz (3 floats)</td><td>12</td></tr>
<tr><td>UV</td><td>1</td><td>uv (2 floats)</td><td>8</td></tr>
<tr><td>Color</td><td>2</td><td>rgb (3 floats)</td><td>12</td></tr>
<tr><td>Normal</td><td>4</td><td>xyz (3 floats)</td><td>12</td></tr>
<tr><td>Skinned</td><td>8</td><td>bone indices + weights</td><td>16</td></tr>
</tbody>
</table>
</div>
<p><strong>Common Combinations:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Value</th><th>Components</th><th>Stride</th></tr>
</thead>
<tbody>
<tr><td>POS</td><td>0</td><td>Position only</td><td>12 bytes</td></tr>
<tr><td>POS_UV</td><td>1</td><td>Position + UV</td><td>20 bytes</td></tr>
<tr><td>POS_COLOR</td><td>2</td><td>Position + Color</td><td>24 bytes</td></tr>
<tr><td>POS_UV_COLOR</td><td>3</td><td>Position + UV + Color</td><td>32 bytes</td></tr>
<tr><td>POS_NORMAL</td><td>4</td><td>Position + Normal</td><td>24 bytes</td></tr>
<tr><td>POS_UV_NORMAL</td><td>5</td><td>Position + UV + Normal</td><td>32 bytes</td></tr>
<tr><td>POS_COLOR_NORMAL</td><td>6</td><td>Position + Color + Normal</td><td>36 bytes</td></tr>
<tr><td>POS_UV_COLOR_NORMAL</td><td>7</td><td>Position + UV + Color + Normal</td><td>44 bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>With Skinning (add 8):</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Format</th><th>Value</th><th>Stride</th></tr>
</thead>
<tbody>
<tr><td>POS_NORMAL_SKINNED</td><td>12</td><td>40 bytes</td></tr>
<tr><td>POS_UV_NORMAL_SKINNED</td><td>13</td><td>48 bytes</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="vertex-data-layout"><a class="header" href="#vertex-data-layout">Vertex Data Layout</a></h2>
<p>Data is laid out per-vertex in this order:</p>
<ol>
<li>Position (xyz) - 3 floats</li>
<li>UV (uv) - 2 floats (if enabled)</li>
<li>Color (rgb) - 3 floats (if enabled)</li>
<li>Normal (xyz) - 3 floats (if enabled)</li>
<li>Skinning (indices + weights) - 4 bytes + 4 bytes (if enabled)</li>
</ol>
<p><strong>Example: POS_UV_NORMAL (format 5)</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Each vertex: 8 floats (32 bytes)
let vertex: [f32; 8] = [
    0.0, 1.0, 0.0,  // Position
    0.5, 1.0,       // UV
    0.0, 1.0, 0.0,  // Normal
];
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Each vertex: 8 floats (32 bytes)
float vertex[8] = {
    0.0f, 1.0f, 0.0f,  // Position
    0.5f, 1.0f,        // UV
    0.0f, 1.0f, 0.0f,  // Normal
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Each vertex: 8 floats (32 bytes)
const vertex = [_]f32{
    0.0, 1.0, 0.0, // Position
    0.5, 1.0,      // UV
    0.0, 1.0, 0.0, // Normal
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-3"><a class="header" href="#complete-example-3">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TRIANGLE: u32 = 0;
static mut QUAD: u32 = 0;

// Triangle with position + color
const TRI_VERTS: [f32; 3 * 6] = [
    // pos xyz, color rgb
    0.0, 1.0, 0.0,  1.0, 0.0, 0.0,
    -1.0, -1.0, 0.0,  0.0, 1.0, 0.0,
    1.0, -1.0, 0.0,  0.0, 0.0, 1.0,
];

// Quad with position + UV + normal (indexed)
const QUAD_VERTS: [f32; 4 * 8] = [
    // pos xyz, uv, normal xyz
    -1.0, -1.0, 0.0,  0.0, 0.0,  0.0, 0.0, 1.0,
     1.0, -1.0, 0.0,  1.0, 0.0,  0.0, 0.0, 1.0,
     1.0,  1.0, 0.0,  1.0, 1.0,  0.0, 0.0, 1.0,
    -1.0,  1.0, 0.0,  0.0, 1.0,  0.0, 0.0, 1.0,
];

const QUAD_INDICES: [u16; 6] = [0, 1, 2, 2, 3, 0];

fn init() {
    unsafe {
        // Non-indexed triangle
        TRIANGLE = load_mesh(
            TRI_VERTS.as_ptr() as *const u8,
            3,
            2 // POS_COLOR
        );

        // Indexed quad
        QUAD = load_mesh_indexed(
            QUAD_VERTS.as_ptr() as *const u8,
            4,
            QUAD_INDICES.as_ptr(),
            6,
            5 // POS_UV_NORMAL
        );
    }
}

fn render() {
    unsafe {
        camera_set(0.0, 0.0, 5.0, 0.0, 0.0, 0.0);

        // Draw triangle
        push_identity();
        push_translate(-2.0, 0.0, 0.0);
        draw_mesh(TRIANGLE);

        // Draw textured quad
        texture_bind(my_texture);
        push_identity();
        push_translate(2.0, 0.0, 0.0);
        draw_mesh(QUAD);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t triangle = 0;
static uint32_t quad = 0;

// Triangle with position + color
static const float TRI_VERTS[3 * 6] = {
    // pos xyz, color rgb
    0.0f, 1.0f, 0.0f,  1.0f, 0.0f, 0.0f,
    -1.0f, -1.0f, 0.0f,  0.0f, 1.0f, 0.0f,
    1.0f, -1.0f, 0.0f,  0.0f, 0.0f, 1.0f,
};

// Quad with position + UV + normal (indexed)
static const float QUAD_VERTS[4 * 8] = {
    // pos xyz, uv, normal xyz
    -1.0f, -1.0f, 0.0f,  0.0f, 0.0f,  0.0f, 0.0f, 1.0f,
     1.0f, -1.0f, 0.0f,  1.0f, 0.0f,  0.0f, 0.0f, 1.0f,
     1.0f,  1.0f, 0.0f,  1.0f, 1.0f,  0.0f, 0.0f, 1.0f,
    -1.0f,  1.0f, 0.0f,  0.0f, 1.0f,  0.0f, 0.0f, 1.0f,
};

static const uint16_t QUAD_INDICES[6] = {0, 1, 2, 2, 3, 0};

EWZX_EXPORT void init(void) {
    // Non-indexed triangle
    triangle = load_mesh(
        (const uint8_t*)TRI_VERTS,
        3,
        2 // POS_COLOR
    );

    // Indexed quad
    quad = load_mesh_indexed(
        (const uint8_t*)QUAD_VERTS,
        4,
        QUAD_INDICES,
        6,
        5 // POS_UV_NORMAL
    );
}

EWZX_EXPORT void render(void) {
    camera_set(0.0f, 0.0f, 5.0f, 0.0f, 0.0f, 0.0f);

    // Draw triangle
    push_identity();
    push_translate(-2.0f, 0.0f, 0.0f);
    draw_mesh(triangle);

    // Draw textured quad
    texture_bind(my_texture);
    push_identity();
    push_translate(2.0f, 0.0f, 0.0f);
    draw_mesh(quad);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var triangle: u32 = 0;
var quad: u32 = 0;

// Triangle with position + color
const TRI_VERTS = [_]f32{
    // pos xyz, color rgb
    0.0, 1.0, 0.0, 1.0, 0.0, 0.0,
    -1.0, -1.0, 0.0, 0.0, 1.0, 0.0,
    1.0, -1.0, 0.0, 0.0, 0.0, 1.0,
};

// Quad with position + UV + normal (indexed)
const QUAD_VERTS = [_]f32{
    // pos xyz, uv, normal xyz
    -1.0, -1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0,
    1.0, -1.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0,
    1.0, 1.0, 0.0, 1.0, 1.0, 0.0, 0.0, 1.0,
    -1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,
};

const QUAD_INDICES = [_]u16{ 0, 1, 2, 2, 3, 0 };

export fn init() void {
    // Non-indexed triangle
    triangle = load_mesh(
        @ptrCast(&amp;TRI_VERTS),
        3,
        2, // POS_COLOR
    );

    // Indexed quad
    quad = load_mesh_indexed(
        @ptrCast(&amp;QUAD_VERTS),
        4,
        &amp;QUAD_INDICES,
        6,
        5, // POS_UV_NORMAL
    );
}

export fn render() void {
    camera_set(0.0, 0.0, 5.0, 0.0, 0.0, 0.0);

    // Draw triangle
    push_identity();
    push_translate(-2.0, 0.0, 0.0);
    draw_mesh(triangle);

    // Draw textured quad
    texture_bind(my_texture);
    push_identity();
    push_translate(2.0, 0.0, 0.0);
    draw_mesh(quad);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#procedural-mesh-functions">Procedural Meshes</a>, <a href="#rom_mesh">rom_mesh</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="material-functions"><a class="header" href="#material-functions">Material Functions</a></h1>
<p>Material properties for PBR (Mode 2) and Blinn-Phong (Mode 3) rendering.</p>
<h2 id="mode-2-metallic-roughness-pbr"><a class="header" href="#mode-2-metallic-roughness-pbr">Mode 2: Metallic-Roughness (PBR)</a></h2>
<h3 id="material_metallic"><a class="header" href="#material_metallic">material_metallic</a></h3>
<p>Sets the metallic value for PBR rendering.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_metallic(value: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_metallic(float value);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_metallic(value: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>value</td><td><code>f32</code></td><td>Metallic value (0.0 = dielectric, 1.0 = metal)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Non-metallic plastic
    material_metallic(0.0);
    draw_mesh(plastic_toy);

    // Full metal
    material_metallic(1.0);
    draw_mesh(sword);

    // Partially metallic (worn paint on metal)
    material_metallic(0.3);
    draw_mesh(rusty_barrel);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Non-metallic plastic
    material_metallic(0.0f);
    draw_mesh(plastic_toy);

    // Full metal
    material_metallic(1.0f);
    draw_mesh(sword);

    // Partially metallic (worn paint on metal)
    material_metallic(0.3f);
    draw_mesh(rusty_barrel);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Non-metallic plastic
    material_metallic(0.0);
    draw_mesh(plastic_toy);

    // Full metal
    material_metallic(1.0);
    draw_mesh(sword);

    // Partially metallic (worn paint on metal)
    material_metallic(0.3);
    draw_mesh(rusty_barrel);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_roughness"><a class="header" href="#material_roughness">material_roughness</a></h3>
<p>Sets the roughness value for PBR rendering.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_roughness(value: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_roughness(float value);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_roughness(value: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>value</td><td><code>f32</code></td><td>Roughness value (0.0 = smooth/mirror, 1.0 = rough/matte)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Mirror-like chrome
    material_roughness(0.1);
    draw_mesh(chrome_bumper);

    // Rough stone
    material_roughness(0.9);
    draw_mesh(stone_wall);

    // Smooth plastic
    material_roughness(0.4);
    draw_mesh(toy);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Mirror-like chrome
    material_roughness(0.1f);
    draw_mesh(chrome_bumper);

    // Rough stone
    material_roughness(0.9f);
    draw_mesh(stone_wall);

    // Smooth plastic
    material_roughness(0.4f);
    draw_mesh(toy);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Mirror-like chrome
    material_roughness(0.1);
    draw_mesh(chrome_bumper);

    // Rough stone
    material_roughness(0.9);
    draw_mesh(stone_wall);

    // Smooth plastic
    material_roughness(0.4);
    draw_mesh(toy);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_emissive"><a class="header" href="#material_emissive">material_emissive</a></h3>
<p>Sets the emissive (self-illumination) intensity.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_emissive(value: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_emissive(float value);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_emissive(value: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>value</td><td><code>f32</code></td><td>Emissive intensity (0.0 = none, 1.0+ = glowing)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Glowing lava
    set_color(0xFF4400FF);
    material_emissive(2.0);
    draw_mesh(lava);

    // Neon sign
    set_color(0x00FFFFFF);
    material_emissive(1.5);
    draw_mesh(neon_tube);

    // Normal object (no glow)
    material_emissive(0.0);
    draw_mesh(normal_object);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Glowing lava
    set_color(0xFF4400FF);
    material_emissive(2.0f);
    draw_mesh(lava);

    // Neon sign
    set_color(0x00FFFFFF);
    material_emissive(1.5f);
    draw_mesh(neon_tube);

    // Normal object (no glow)
    material_emissive(0.0f);
    draw_mesh(normal_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Glowing lava
    set_color(0xFF4400FF);
    material_emissive(2.0);
    draw_mesh(lava);

    // Neon sign
    set_color(0x00FFFFFF);
    material_emissive(1.5);
    draw_mesh(neon_tube);

    // Normal object (no glow)
    material_emissive(0.0);
    draw_mesh(normal_object);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_rim"><a class="header" href="#material_rim">material_rim</a></h3>
<p>Sets rim lighting parameters.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_rim(intensity: f32, power: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_rim(float intensity, float power);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_rim(intensity: f32, power: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>intensity</td><td><code>f32</code></td><td>Rim light intensity (0.0-1.0)</td></tr>
<tr><td>power</td><td><code>f32</code></td><td>Rim light falloff power (0.0-1.0, maps to 0-32 internally)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Subtle rim for characters
    material_rim(0.2, 0.15);
    draw_mesh(character);

    // Strong backlighting effect
    material_rim(0.5, 0.3);
    draw_mesh(silhouette_enemy);

    // No rim lighting
    material_rim(0.0, 0.0);
    draw_mesh(ground);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Subtle rim for characters
    material_rim(0.2f, 0.15f);
    draw_mesh(character);

    // Strong backlighting effect
    material_rim(0.5f, 0.3f);
    draw_mesh(silhouette_enemy);

    // No rim lighting
    material_rim(0.0f, 0.0f);
    draw_mesh(ground);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Subtle rim for characters
    material_rim(0.2, 0.15);
    draw_mesh(character);

    // Strong backlighting effect
    material_rim(0.5, 0.3);
    draw_mesh(silhouette_enemy);

    // No rim lighting
    material_rim(0.0, 0.0);
    draw_mesh(ground);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="mode-3-specular-shininess-blinn-phong"><a class="header" href="#mode-3-specular-shininess-blinn-phong">Mode 3: Specular-Shininess (Blinn-Phong)</a></h2>
<h3 id="material_shininess"><a class="header" href="#material_shininess">material_shininess</a></h3>
<p>Sets the shininess for specular highlights (Mode 3).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_shininess(value: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_shininess(float value);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_shininess(value: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>value</td><td><code>f32</code></td><td>Shininess (0.0-1.0, maps to 1-256 internally)</td></tr>
</tbody>
</table>
</div>
<p><strong>Shininess Guide:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Internal</th><th>Visual</th><th>Use For</th></tr>
</thead>
<tbody>
<tr><td>0.0-0.2</td><td>1-52</td><td>Very soft, broad</td><td>Cloth, skin, rough stone</td></tr>
<tr><td>0.2-0.4</td><td>52-103</td><td>Broad</td><td>Leather, wood, rubber</td></tr>
<tr><td>0.4-0.6</td><td>103-154</td><td>Medium</td><td>Plastic, painted metal</td></tr>
<tr><td>0.6-0.8</td><td>154-205</td><td>Tight</td><td>Polished metal, wet surfaces</td></tr>
<tr><td>0.8-1.0</td><td>205-256</td><td>Very tight</td><td>Chrome, mirrors, glass</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Matte cloth
    material_shininess(0.1);
    draw_mesh(cloth);

    // Polished armor
    material_shininess(0.8);
    draw_mesh(armor);

    // Chrome
    material_shininess(0.95);
    draw_mesh(chrome_sphere);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Matte cloth
    material_shininess(0.1f);
    draw_mesh(cloth);

    // Polished armor
    material_shininess(0.8f);
    draw_mesh(armor);

    // Chrome
    material_shininess(0.95f);
    draw_mesh(chrome_sphere);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Matte cloth
    material_shininess(0.1);
    draw_mesh(cloth);

    // Polished armor
    material_shininess(0.8);
    draw_mesh(armor);

    // Chrome
    material_shininess(0.95);
    draw_mesh(chrome_sphere);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_specular"><a class="header" href="#material_specular">material_specular</a></h3>
<p>Sets the specular highlight color (Mode 3).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_specular(color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_specular(uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_specular(color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>color</td><td><code>u32</code></td><td>Specular color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // White specular (default, most materials)
    material_specular(0xFFFFFFFF);
    draw_mesh(plastic);

    // Gold specular
    material_specular(0xFFD700FF);
    draw_mesh(gold_ring);

    // Copper specular
    material_specular(0xB87333FF);
    draw_mesh(copper_pot);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // White specular (default, most materials)
    material_specular(0xFFFFFFFF);
    draw_mesh(plastic);

    // Gold specular
    material_specular(0xFFD700FF);
    draw_mesh(gold_ring);

    // Copper specular
    material_specular(0xB87333FF);
    draw_mesh(copper_pot);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // White specular (default, most materials)
    material_specular(0xFFFFFFFF);
    draw_mesh(plastic);

    // Gold specular
    material_specular(0xFFD700FF);
    draw_mesh(gold_ring);

    // Copper specular
    material_specular(0xB87333FF);
    draw_mesh(copper_pot);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_specular_color"><a class="header" href="#material_specular_color">material_specular_color</a></h3>
<p>Sets the specular highlight color as RGB floats (Mode 3).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_specular_color(r: f32, g: f32, b: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_specular_color(float r, float g, float b);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_specular_color(r: f32, g: f32, b: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>r, g, b</td><td><code>f32</code></td><td>Specular color components (0.0-1.0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Gold specular
    material_specular_color(1.0, 0.84, 0.0);
    draw_mesh(gold);

    // Tinted specular
    material_specular_color(0.8, 0.9, 1.0);
    draw_mesh(ice);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Gold specular
    material_specular_color(1.0f, 0.84f, 0.0f);
    draw_mesh(gold);

    // Tinted specular
    material_specular_color(0.8f, 0.9f, 1.0f);
    draw_mesh(ice);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Gold specular
    material_specular_color(1.0, 0.84, 0.0);
    draw_mesh(gold);

    // Tinted specular
    material_specular_color(0.8, 0.9, 1.0);
    draw_mesh(ice);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="material_specular_damping"><a class="header" href="#material_specular_damping">material_specular_damping</a></h3>
<p>Sets specular damping (Mode 3, alias for metallic behavior).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_specular_damping(value: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_specular_damping(float value);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_specular_damping(value: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>value</td><td><code>f32</code></td><td>Damping value (0.0-1.0)</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="texture-slots"><a class="header" href="#texture-slots">Texture Slots</a></h2>
<h3 id="material_albedo"><a class="header" href="#material_albedo">material_albedo</a></h3>
<p>Binds an albedo (diffuse) texture to slot 0.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_albedo(texture: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_albedo(uint32_t texture);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_albedo(texture: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>texture</td><td><code>u32</code></td><td>Texture handle</td></tr>
</tbody>
</table>
</div>
<p><strong>Note:</strong> Equivalent to <code>texture_bind_slot(texture, 0)</code>.</p>
<hr>
<h3 id="material_mre"><a class="header" href="#material_mre">material_mre</a></h3>
<p>Binds an MRE (Metallic/Roughness/Emissive) texture to slot 1 (Mode 2).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn material_mre(texture: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void material_mre(uint32_t texture);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn material_mre(texture: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>texture</td><td><code>u32</code></td><td>Texture handle for MRE map</td></tr>
</tbody>
</table>
</div>
<p><strong>MRE Texture Channels:</strong></p>
<ul>
<li><strong>R:</strong> Metallic (0-255 maps to 0.0-1.0)</li>
<li><strong>G:</strong> Roughness (0-255 maps to 0.0-1.0)</li>
<li><strong>B:</strong> Emissive (0-255 maps to emissive intensity)</li>
</ul>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    material_albedo(character_albedo);
    material_mre(character_mre);
    draw_mesh(character);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    material_albedo(character_albedo);
    material_mre(character_mre);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    material_albedo(character_albedo);
    material_mre(character_mre);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="override-flags"><a class="header" href="#override-flags">Override Flags</a></h2>
<p>These functions enable uniform values instead of texture sampling.</p>
<h3 id="use_uniform_color"><a class="header" href="#use_uniform_color">use_uniform_color</a></h3>
<p>Use uniform color instead of albedo texture.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_uniform_color(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_uniform_color(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_uniform_color(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Use texture
    use_uniform_color(0);
    texture_bind(wood_tex);
    draw_mesh(table);

    // Use uniform color
    use_uniform_color(1);
    set_color(0xFF0000FF);
    draw_mesh(red_cube);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Use texture
    use_uniform_color(0);
    texture_bind(wood_tex);
    draw_mesh(table);

    // Use uniform color
    use_uniform_color(1);
    set_color(0xFF0000FF);
    draw_mesh(red_cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Use texture
    use_uniform_color(0);
    texture_bind(wood_tex);
    draw_mesh(table);

    // Use uniform color
    use_uniform_color(1);
    set_color(0xFF0000FF);
    draw_mesh(red_cube);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="use_uniform_metallic"><a class="header" href="#use_uniform_metallic">use_uniform_metallic</a></h3>
<p>Use uniform metallic value instead of MRE texture.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_uniform_metallic(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_uniform_metallic(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_uniform_metallic(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="use_uniform_roughness"><a class="header" href="#use_uniform_roughness">use_uniform_roughness</a></h3>
<p>Use uniform roughness value instead of MRE texture.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_uniform_roughness(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_uniform_roughness(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_uniform_roughness(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="use_uniform_emissive"><a class="header" href="#use_uniform_emissive">use_uniform_emissive</a></h3>
<p>Use uniform emissive value instead of MRE texture.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_uniform_emissive(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_uniform_emissive(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_uniform_emissive(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="use_uniform_specular"><a class="header" href="#use_uniform_specular">use_uniform_specular</a></h3>
<p>Use uniform specular color instead of specular texture (Mode 3).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_uniform_specular(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_uniform_specular(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_uniform_specular(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="use_matcap_reflection"><a class="header" href="#use_matcap_reflection">use_matcap_reflection</a></h3>
<p>Use matcap for environmental reflection (Mode 1).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn use_matcap_reflection(enabled: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void use_matcap_reflection(uint32_t enabled);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn use_matcap_reflection(enabled: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="pbr-material-mode-2"><a class="header" href="#pbr-material-mode-2">PBR Material (Mode 2)</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(2); // Metallic-Roughness
}

fn render() {
    // Shiny metal sword
    material_albedo(sword_albedo);
    material_mre(sword_mre);
    material_rim(0.15, 0.2);
    push_identity();
    push_translate(player.x, player.y, player.z);
    draw_mesh(sword);

    // Simple colored object (no textures)
    use_uniform_color(1);
    use_uniform_metallic(1);
    use_uniform_roughness(1);

    set_color(0x4080FFFF);
    material_metallic(0.0);
    material_roughness(0.3);
    push_identity();
    draw_mesh(magic_orb);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(2); // Metallic-Roughness
}

EWZX_EXPORT void render(void) {
    // Shiny metal sword
    material_albedo(sword_albedo);
    material_mre(sword_mre);
    material_rim(0.15f, 0.2f);
    push_identity();
    push_translate(player.x, player.y, player.z);
    draw_mesh(sword);

    // Simple colored object (no textures)
    use_uniform_color(1);
    use_uniform_metallic(1);
    use_uniform_roughness(1);

    set_color(0x4080FFFF);
    material_metallic(0.0f);
    material_roughness(0.3f);
    push_identity();
    draw_mesh(magic_orb);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(2); // Metallic-Roughness
}

export fn render() void {
    // Shiny metal sword
    material_albedo(sword_albedo);
    material_mre(sword_mre);
    material_rim(0.15, 0.2);
    push_identity();
    push_translate(player.x, player.y, player.z);
    draw_mesh(sword);

    // Simple colored object (no textures)
    use_uniform_color(1);
    use_uniform_metallic(1);
    use_uniform_roughness(1);

    set_color(0x4080FFFF);
    material_metallic(0.0);
    material_roughness(0.3);
    push_identity();
    draw_mesh(magic_orb);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="blinn-phong-material-mode-3"><a class="header" href="#blinn-phong-material-mode-3">Blinn-Phong Material (Mode 3)</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(3); // Specular-Shininess
}

fn render() {
    // Gold armor
    set_color(0xE6B84DFF);  // Gold base color
    material_shininess(0.8);
    material_specular(0xFFD700FF);  // Gold specular
    material_rim(0.2, 0.15);
    material_emissive(0.0);
    draw_mesh(armor);

    // Glowing crystal
    set_color(0x4D99E6FF);  // Blue crystal
    material_shininess(0.75);
    material_specular(0xFFFFFFFF);
    material_rim(0.4, 0.18);
    material_emissive(0.3);  // Self-illumination
    draw_mesh(crystal);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7);
    material_specular(0xFFFFFFFF);
    material_rim(0.3, 0.25);
    material_emissive(0.0);
    draw_mesh(character_skin);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    render_mode(3); // Specular-Shininess
}

EWZX_EXPORT void render(void) {
    // Gold armor
    set_color(0xE6B84DFF);  // Gold base color
    material_shininess(0.8f);
    material_specular(0xFFD700FF);  // Gold specular
    material_rim(0.2f, 0.15f);
    material_emissive(0.0f);
    draw_mesh(armor);

    // Glowing crystal
    set_color(0x4D99E6FF);  // Blue crystal
    material_shininess(0.75f);
    material_specular(0xFFFFFFFF);
    material_rim(0.4f, 0.18f);
    material_emissive(0.3f);  // Self-illumination
    draw_mesh(crystal);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7f);
    material_specular(0xFFFFFFFF);
    material_rim(0.3f, 0.25f);
    material_emissive(0.0f);
    draw_mesh(character_skin);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    render_mode(3); // Specular-Shininess
}

export fn render() void {
    // Gold armor
    set_color(0xE6B84DFF); // Gold base color
    material_shininess(0.8);
    material_specular(0xFFD700FF); // Gold specular
    material_rim(0.2, 0.15);
    material_emissive(0.0);
    draw_mesh(armor);

    // Glowing crystal
    set_color(0x4D99E6FF); // Blue crystal
    material_shininess(0.75);
    material_specular(0xFFFFFFFF);
    material_rim(0.4, 0.18);
    material_emissive(0.3); // Self-illumination
    draw_mesh(crystal);

    // Wet skin
    set_color(0xD9B399FF);
    material_shininess(0.7);
    material_specular(0xFFFFFFFF);
    material_rim(0.3, 0.25);
    material_emissive(0.0);
    draw_mesh(character_skin);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#render-modes-guide">Render Modes Guide</a>, <a href="#texture-functions">Textures</a>, <a href="#lighting-functions">Lighting</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="lighting-functions"><a class="header" href="#lighting-functions">Lighting Functions</a></h1>
<p>Dynamic lighting for Modes 2 and 3 (up to 4 lights).</p>
<h2 id="directional-lights"><a class="header" href="#directional-lights">Directional Lights</a></h2>
<h3 id="light_set"><a class="header" href="#light_set">light_set</a></h3>
<p>Sets a directional light direction.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_set(index: u32, x: f32, y: f32, z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_set(uint32_t index, float x, float y, float z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_set(index: u32, x: f32, y: f32, z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>index</td><td><code>u32</code></td><td>Light index (0-3)</td></tr>
<tr><td>x, y, z</td><td><code>f32</code></td><td>Light direction (from light, will be normalized)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Sun from upper right
    light_set(0, 0.5, -0.7, 0.5);
    light_enable(0);

    // Fill light from left
    light_set(1, -0.8, -0.2, 0.0);
    light_enable(1);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Sun from upper right
    light_set(0, 0.5f, -0.7f, 0.5f);
    light_enable(0);

    // Fill light from left
    light_set(1, -0.8f, -0.2f, 0.0f);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Sun from upper right
    light_set(0, 0.5, -0.7, 0.5);
    light_enable(0);

    // Fill light from left
    light_set(1, -0.8, -0.2, 0.0);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="light_color"><a class="header" href="#light_color">light_color</a></h3>
<p>Sets a light’s color.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_color(index: u32, color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_color(uint32_t index, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_color(index: u32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>index</td><td><code>u32</code></td><td>Light index (0-3)</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Light color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Warm sunlight
    light_color(0, 0xFFF2E6FF);

    // Cool fill light
    light_color(1, 0xB3D9FFFF);

    // Red emergency light
    light_color(2, 0xFF3333FF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Warm sunlight
    light_color(0, 0xFFF2E6FF);

    // Cool fill light
    light_color(1, 0xB3D9FFFF);

    // Red emergency light
    light_color(2, 0xFF3333FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Warm sunlight
    light_color(0, 0xFFF2E6FF);

    // Cool fill light
    light_color(1, 0xB3D9FFFF);

    // Red emergency light
    light_color(2, 0xFF3333FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="light_intensity"><a class="header" href="#light_intensity">light_intensity</a></h3>
<p>Sets a light’s intensity.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_intensity(index: u32, intensity: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_intensity(uint32_t index, float intensity);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_intensity(index: u32, intensity: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>index</td><td><code>u32</code></td><td>Light index (0-3)</td></tr>
<tr><td>intensity</td><td><code>f32</code></td><td>Light intensity (0.0-8.0, default 1.0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Bright main light
    light_intensity(0, 1.2);

    // Dim fill light
    light_intensity(1, 0.3);

    // Flickering torch
    let flicker = 0.8 + (elapsed_time() * 10.0).sin() * 0.2;
    light_intensity(2, flicker);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;math.h&gt;

EWZX_EXPORT void render(void) {
    // Bright main light
    light_intensity(0, 1.2f);

    // Dim fill light
    light_intensity(1, 0.3f);

    // Flickering torch
    float flicker = 0.8f + sinf(elapsed_time() * 10.0f) * 0.2f;
    light_intensity(2, flicker);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const std = @import("std");

export fn render() void {
    // Bright main light
    light_intensity(0, 1.2);

    // Dim fill light
    light_intensity(1, 0.3);

    // Flickering torch
    const flicker = 0.8 + @sin(elapsed_time() * 10.0) * 0.2;
    light_intensity(2, flicker);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="light_enable"><a class="header" href="#light_enable">light_enable</a></h3>
<p>Enables a light.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_enable(index: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_enable(uint32_t index);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_enable(index: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Enable lights 0 and 1
    light_enable(0);
    light_enable(1);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Enable lights 0 and 1
    light_enable(0);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Enable lights 0 and 1
    light_enable(0);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="light_disable"><a class="header" href="#light_disable">light_disable</a></h3>
<p>Disables a light.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_disable(index: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_disable(uint32_t index);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_disable(index: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Disable light 2 when entering dark area
    if in_dark_zone {
        light_disable(2);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Disable light 2 when entering dark area
    if (in_dark_zone) {
        light_disable(2);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Disable light 2 when entering dark area
    if (in_dark_zone) {
        light_disable(2);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="point-lights"><a class="header" href="#point-lights">Point Lights</a></h2>
<h3 id="light_set_point"><a class="header" href="#light_set_point">light_set_point</a></h3>
<p>Sets a point light position.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_set_point(index: u32, x: f32, y: f32, z: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_set_point(uint32_t index, float x, float y, float z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_set_point(index: u32, x: f32, y: f32, z: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>index</td><td><code>u32</code></td><td>Light index (0-3)</td></tr>
<tr><td>x, y, z</td><td><code>f32</code></td><td>World position of the light</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Torch at fixed position
    light_set_point(0, 5.0, 2.0, 3.0);
    light_color(0, 0xFFAA66FF);
    light_range(0, 10.0);
    light_enable(0);

    // Light following player
    light_set_point(1, player.x, player.y + 1.0, player.z);
    light_enable(1);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Torch at fixed position
    light_set_point(0, 5.0f, 2.0f, 3.0f);
    light_color(0, 0xFFAA66FF);
    light_range(0, 10.0f);
    light_enable(0);

    // Light following player
    light_set_point(1, player.x, player.y + 1.0f, player.z);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Torch at fixed position
    light_set_point(0, 5.0, 2.0, 3.0);
    light_color(0, 0xFFAA66FF);
    light_range(0, 10.0);
    light_enable(0);

    // Light following player
    light_set_point(1, player.x, player.y + 1.0, player.z);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="light_range"><a class="header" href="#light_range">light_range</a></h3>
<p>Sets a point light’s falloff range.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn light_range(index: u32, range: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void light_range(uint32_t index, float range);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn light_range(index: u32, range: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>index</td><td><code>u32</code></td><td>Light index (0-3)</td></tr>
<tr><td>range</td><td><code>f32</code></td><td>Maximum range/falloff distance</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Small candle
    light_set_point(0, candle_x, candle_y, candle_z);
    light_range(0, 3.0);
    light_intensity(0, 0.5);

    // Large bonfire
    light_set_point(1, fire_x, fire_y, fire_z);
    light_range(1, 15.0);
    light_intensity(1, 2.0);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Small candle
    light_set_point(0, candle_x, candle_y, candle_z);
    light_range(0, 3.0f);
    light_intensity(0, 0.5f);

    // Large bonfire
    light_set_point(1, fire_x, fire_y, fire_z);
    light_range(1, 15.0f);
    light_intensity(1, 2.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Small candle
    light_set_point(0, candle_x, candle_y, candle_z);
    light_range(0, 3.0);
    light_intensity(0, 0.5);

    // Large bonfire
    light_set_point(1, fire_x, fire_y, fire_z);
    light_range(1, 15.0);
    light_intensity(1, 2.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="standard-lighting-setups"><a class="header" href="#standard-lighting-setups">Standard Lighting Setups</a></h2>
<h3 id="three-point-lighting"><a class="header" href="#three-point-lighting">Three-Point Lighting</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_lighting() {
    // Key light (main light source)
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF);  // Warm white
    light_intensity(0, 1.0);
    light_enable(0);

    // Fill light (soften shadows)
    light_set(1, -0.8, -0.3, 0.2);
    light_color(1, 0xB3D9FFFF);  // Cool blue
    light_intensity(1, 0.3);
    light_enable(1);

    // Rim/back light (separation from background)
    light_set(2, 0.0, -0.2, -1.0);
    light_color(2, 0xFFFFFFFF);
    light_intensity(2, 0.5);
    light_enable(2);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_lighting(void) {
    // Key light (main light source)
    light_set(0, 0.5f, -0.7f, 0.5f);
    light_color(0, 0xFFF2E6FF);  // Warm white
    light_intensity(0, 1.0f);
    light_enable(0);

    // Fill light (soften shadows)
    light_set(1, -0.8f, -0.3f, 0.2f);
    light_color(1, 0xB3D9FFFF);  // Cool blue
    light_intensity(1, 0.3f);
    light_enable(1);

    // Rim/back light (separation from background)
    light_set(2, 0.0f, -0.2f, -1.0f);
    light_color(2, 0xFFFFFFFF);
    light_intensity(2, 0.5f);
    light_enable(2);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_lighting() void {
    // Key light (main light source)
    light_set(0, 0.5, -0.7, 0.5);
    light_color(0, 0xFFF2E6FF); // Warm white
    light_intensity(0, 1.0);
    light_enable(0);

    // Fill light (soften shadows)
    light_set(1, -0.8, -0.3, 0.2);
    light_color(1, 0xB3D9FFFF); // Cool blue
    light_intensity(1, 0.3);
    light_enable(1);

    // Rim/back light (separation from background)
    light_set(2, 0.0, -0.2, -1.0);
    light_color(2, 0xFFFFFFFF);
    light_intensity(2, 0.5);
    light_enable(2);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="outdoor-sunlight"><a class="header" href="#outdoor-sunlight">Outdoor Sunlight</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Configure sun (matches sky_set_sun direction)
    light_set(0, 0.3, -0.8, 0.5);
    light_color(0, 0xFFF8E6FF);  // Warm sunlight
    light_intensity(0, 1.2);
    light_enable(0);

    // Ambient comes from sky automatically
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Configure sun (matches sky_set_sun direction)
    light_set(0, 0.3f, -0.8f, 0.5f);
    light_color(0, 0xFFF8E6FF);  // Warm sunlight
    light_intensity(0, 1.2f);
    light_enable(0);

    // Ambient comes from sky automatically
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Configure sun (matches sky_set_sun direction)
    light_set(0, 0.3, -0.8, 0.5);
    light_color(0, 0xFFF8E6FF); // Warm sunlight
    light_intensity(0, 1.2);
    light_enable(0);

    // Ambient comes from sky automatically
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="indoor-point-lights"><a class="header" href="#indoor-point-lights">Indoor Point Lights</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Overhead lamp
    light_set_point(0, room_center_x, ceiling_y - 0.5, room_center_z);
    light_color(0, 0xFFE6B3FF);
    light_range(0, 8.0);
    light_intensity(0, 1.0);
    light_enable(0);

    // Desk lamp
    light_set_point(1, desk_x, desk_y + 0.5, desk_z);
    light_color(1, 0xFFFFE6FF);
    light_range(1, 3.0);
    light_intensity(1, 0.8);
    light_enable(1);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Overhead lamp
    light_set_point(0, room_center_x, ceiling_y - 0.5f, room_center_z);
    light_color(0, 0xFFE6B3FF);
    light_range(0, 8.0f);
    light_intensity(0, 1.0f);
    light_enable(0);

    // Desk lamp
    light_set_point(1, desk_x, desk_y + 0.5f, desk_z);
    light_color(1, 0xFFFFE6FF);
    light_range(1, 3.0f);
    light_intensity(1, 0.8f);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Overhead lamp
    light_set_point(0, room_center_x, ceiling_y - 0.5, room_center_z);
    light_color(0, 0xFFE6B3FF);
    light_range(0, 8.0);
    light_intensity(0, 1.0);
    light_enable(0);

    // Desk lamp
    light_set_point(1, desk_x, desk_y + 0.5, desk_z);
    light_color(1, 0xFFFFE6FF);
    light_range(1, 3.0);
    light_intensity(1, 0.8);
    light_enable(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="dynamic-torch-effect"><a class="header" href="#dynamic-torch-effect">Dynamic Torch Effect</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TORCH_FLICKER: f32 = 0.0;

fn update() {
    unsafe {
        // Randomized flicker
        let r = (random() % 1000) as f32 / 1000.0;
        TORCH_FLICKER = 0.7 + r * 0.3;
    }
}

fn render() {
    unsafe {
        light_set_point(0, torch_x, torch_y, torch_z);
        light_color(0, 0xFF8833FF);
        light_range(0, 6.0 + TORCH_FLICKER);
        light_intensity(0, TORCH_FLICKER);
        light_enable(0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float torch_flicker = 0.0f;

EWZX_EXPORT void update(void) {
    // Randomized flicker
    float r = (float)(random_u32() % 1000) / 1000.0f;
    torch_flicker = 0.7f + r * 0.3f;
}

EWZX_EXPORT void render(void) {
    light_set_point(0, torch_x, torch_y, torch_z);
    light_color(0, 0xFF8833FF);
    light_range(0, 6.0f + torch_flicker);
    light_intensity(0, torch_flicker);
    light_enable(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var torch_flicker: f32 = 0.0;

export fn update() void {
    // Randomized flicker
    const r = @as(f32, @floatFromInt(random_u32() % 1000)) / 1000.0;
    torch_flicker = 0.7 + r * 0.3;
}

export fn render() void {
    light_set_point(0, torch_x, torch_y, torch_z);
    light_color(0, 0xFF8833FF);
    light_range(0, 6.0 + torch_flicker);
    light_intensity(0, torch_flicker);
    light_enable(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="lighting-notes"><a class="header" href="#lighting-notes">Lighting Notes</a></h2>
<ul>
<li><strong>Maximum 4 lights</strong> (indices 0-3)</li>
<li><strong>Directional lights</strong> have no position, only direction</li>
<li><strong>Point lights</strong> have position and range falloff</li>
<li><strong>Sun lighting</strong> comes from <code>sky_set_sun()</code> in addition to explicit lights</li>
<li><strong>Ambient</strong> comes from the procedural sky automatically</li>
<li>Works only in <strong>Mode 2</strong> (Metallic-Roughness) and <strong>Mode 3</strong> (Specular-Shininess)</li>
</ul>
<p><strong>See Also:</strong> <a href="#sky-functions">Sky Functions</a>, <a href="#material-functions">Materials</a>, <a href="#render-modes-guide">Render Modes Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="skeletal-animation-functions"><a class="header" href="#skeletal-animation-functions">Skeletal Animation Functions</a></h1>
<p>GPU-based skeletal animation with bone transforms.</p>
<h2 id="skeleton-loading"><a class="header" href="#skeleton-loading">Skeleton Loading</a></h2>
<h3 id="load_skeleton"><a class="header" href="#load_skeleton">load_skeleton</a></h3>
<p>Loads inverse bind matrices for a skeleton.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_skeleton(inverse_bind_ptr: *const f32, bone_count: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_skeleton(const float* inverse_bind_ptr, uint32_t bone_count);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_skeleton(inverse_bind_ptr: [*]const f32, bone_count: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>inverse_bind_ptr</td><td><code>*const f32</code></td><td>Pointer to 3x4 matrices (12 floats each, column-major)</td></tr>
<tr><td>bone_count</td><td><code>u32</code></td><td>Number of bones (max 256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Skeleton handle (non-zero on success)</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SKELETON: u32 = 0;
static INVERSE_BIND: &amp;[u8] = include_bytes!("skeleton.ewzskel");

fn init() {
    unsafe {
        // Parse bone count from header
        let bone_count = u32::from_le_bytes([
            INVERSE_BIND[0], INVERSE_BIND[1],
            INVERSE_BIND[2], INVERSE_BIND[3]
        ]);

        // Matrix data starts after 8-byte header
        let matrices_ptr = INVERSE_BIND[8..].as_ptr() as *const f32;
        SKELETON = load_skeleton(matrices_ptr, bone_count);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t SKELETON = 0;

EWZX_EXPORT void init(void) {
    // Load skeleton binary data
    const uint8_t* inverse_bind = /* load skeleton.ewzskel */;

    // Parse bone count from header
    uint32_t bone_count = inverse_bind[0] | (inverse_bind[1] &lt;&lt; 8) |
                         (inverse_bind[2] &lt;&lt; 16) | (inverse_bind[3] &lt;&lt; 24);

    // Matrix data starts after 8-byte header
    const float* matrices_ptr = (const float*)(inverse_bind + 8);
    SKELETON = load_skeleton(matrices_ptr, bone_count);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var SKELETON: u32 = 0;

export fn init() void {
    // Load skeleton binary data
    const inverse_bind = @embedFile("skeleton.ewzskel");

    // Parse bone count from header
    const bone_count = std.mem.readIntLittle(u32, inverse_bind[0..4]);

    // Matrix data starts after 8-byte header
    const matrices_ptr = @ptrCast([*]const f32, @alignCast(@alignOf(f32), inverse_bind[8..]));
    SKELETON = load_skeleton(matrices_ptr, bone_count);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="skeleton_bind"><a class="header" href="#skeleton_bind">skeleton_bind</a></h3>
<p>Binds a skeleton for inverse bind mode rendering.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn skeleton_bind(skeleton: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void skeleton_bind(uint32_t skeleton);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn skeleton_bind(skeleton: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>skeleton</td><td><code>u32</code></td><td>Skeleton handle, or 0 to disable inverse bind mode</td></tr>
</tbody>
</table>
</div>
<p><strong>Skinning Modes:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th><code>skeleton_bind()</code></th><th><code>set_bones()</code> receives</th><th>GPU applies</th></tr>
</thead>
<tbody>
<tr><td><code>0</code> or not called</td><td>Final skinning matrices</td><td>Nothing extra</td></tr>
<tr><td>Valid handle</td><td>Model-space bone transforms</td><td><code>bone × inverse_bind</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    unsafe {
        // Enable inverse bind mode
        skeleton_bind(SKELETON);

        // Upload model-space transforms (GPU applies inverse bind)
        set_bones(animation_bones.as_ptr(), bone_count);
        draw_mesh(character_mesh);

        // Disable for other meshes
        skeleton_bind(0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Enable inverse bind mode
    skeleton_bind(SKELETON);

    // Upload model-space transforms (GPU applies inverse bind)
    set_bones(animation_bones, bone_count);
    draw_mesh(character_mesh);

    // Disable for other meshes
    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Enable inverse bind mode
    skeleton_bind(SKELETON);

    // Upload model-space transforms (GPU applies inverse bind)
    set_bones(animation_bones.ptr, bone_count);
    draw_mesh(character_mesh);

    // Disable for other meshes
    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="bone-transforms"><a class="header" href="#bone-transforms">Bone Transforms</a></h2>
<h3 id="set_bones"><a class="header" href="#set_bones">set_bones</a></h3>
<p>Uploads bone transforms as 3x4 matrices.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_bones(matrices_ptr: *const f32, count: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_bones(const float* matrices_ptr, uint32_t count);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_bones(matrices_ptr: [*]const f32, count: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>matrices_ptr</td><td><code>*const f32</code></td><td>Pointer to array of 3x4 matrices (12 floats each)</td></tr>
<tr><td>count</td><td><code>u32</code></td><td>Number of bones (max 256)</td></tr>
</tbody>
</table>
</div>
<p><strong>3x4 Matrix Layout (column-major, 12 floats):</strong></p>
<pre><code>[col0.x, col0.y, col0.z,   // X axis
 col1.x, col1.y, col1.z,   // Y axis
 col2.x, col2.y, col2.z,   // Z axis
 tx,     ty,     tz]       // Translation
// Implicit 4th row: [0, 0, 0, 1]
</code></pre>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut BONE_MATRICES: [f32; 64 * 12] = [0.0; 64 * 12]; // 64 bones max

fn update() {
    unsafe {
        // Update bone transforms from animation
        for i in 0..BONE_COUNT {
            let offset = i * 12;
            // Set identity with translation
            BONE_MATRICES[offset + 0] = 1.0;  // col0.x
            BONE_MATRICES[offset + 4] = 1.0;  // col1.y
            BONE_MATRICES[offset + 8] = 1.0;  // col2.z
            BONE_MATRICES[offset + 9] = bone_positions[i].x;
            BONE_MATRICES[offset + 10] = bone_positions[i].y;
            BONE_MATRICES[offset + 11] = bone_positions[i].z;
        }
    }
}

fn render() {
    unsafe {
        set_bones(BONE_MATRICES.as_ptr(), BONE_COUNT as u32);
        draw_mesh(SKINNED_MESH);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float BONE_MATRICES[64 * 12]; // 64 bones max

EWZX_EXPORT void update(void) {
    // Update bone transforms from animation
    for (int i = 0; i &lt; BONE_COUNT; i++) {
        int offset = i * 12;
        // Set identity with translation
        BONE_MATRICES[offset + 0] = 1.0f;  // col0.x
        BONE_MATRICES[offset + 4] = 1.0f;  // col1.y
        BONE_MATRICES[offset + 8] = 1.0f;  // col2.z
        BONE_MATRICES[offset + 9] = bone_positions[i].x;
        BONE_MATRICES[offset + 10] = bone_positions[i].y;
        BONE_MATRICES[offset + 11] = bone_positions[i].z;
    }
}

EWZX_EXPORT void render(void) {
    set_bones(BONE_MATRICES, BONE_COUNT);
    draw_mesh(SKINNED_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var BONE_MATRICES: [64 * 12]f32 = undefined; // 64 bones max

export fn update() void {
    // Update bone transforms from animation
    for (0..BONE_COUNT) |i| {
        const offset = i * 12;
        // Set identity with translation
        BONE_MATRICES[offset + 0] = 1.0;  // col0.x
        BONE_MATRICES[offset + 4] = 1.0;  // col1.y
        BONE_MATRICES[offset + 8] = 1.0;  // col2.z
        BONE_MATRICES[offset + 9] = bone_positions[i].x;
        BONE_MATRICES[offset + 10] = bone_positions[i].y;
        BONE_MATRICES[offset + 11] = bone_positions[i].z;
    }
}

export fn render() void {
    set_bones(&amp;BONE_MATRICES, BONE_COUNT);
    draw_mesh(SKINNED_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="set_bones_4x4"><a class="header" href="#set_bones_4x4">set_bones_4x4</a></h3>
<p>Uploads bone transforms as 4x4 matrices (converted to 3x4 internally).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn set_bones_4x4(matrices_ptr: *const f32, count: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void set_bones_4x4(const float* matrices_ptr, uint32_t count);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn set_bones_4x4(matrices_ptr: [*]const f32, count: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>matrices_ptr</td><td><code>*const f32</code></td><td>Pointer to array of 4x4 matrices (16 floats each)</td></tr>
<tr><td>count</td><td><code>u32</code></td><td>Number of bones (max 256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Using glam Mat4 arrays
    let mut bone_mats: [Mat4; 64] = [Mat4::IDENTITY; 64];

    // Animate bones
    for i in 0..bone_count {
        bone_mats[i] = compute_bone_transform(i);
    }

    // Upload (host converts 4x4 → 3x4)
    set_bones_4x4(bone_mats.as_ptr() as *const f32, bone_count);
    draw_mesh(skinned_mesh);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    // Using 4x4 matrix arrays (16 floats each)
    float bone_mats[64 * 16];

    // Initialize to identity
    for (int i = 0; i &lt; bone_count; i++) {
        identity_matrix_4x4(&amp;bone_mats[i * 16]);
    }

    // Animate bones
    for (int i = 0; i &lt; bone_count; i++) {
        compute_bone_transform(i, &amp;bone_mats[i * 16]);
    }

    // Upload (host converts 4x4 → 3x4)
    set_bones_4x4(bone_mats, bone_count);
    draw_mesh(skinned_mesh);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Using 4x4 matrix arrays (16 floats each)
    var bone_mats: [64 * 16]f32 = undefined;

    // Initialize to identity
    for (0..bone_count) |i| {
        identity_matrix_4x4(bone_mats[i * 16 .. (i + 1) * 16]);
    }

    // Animate bones
    for (0..bone_count) |i| {
        compute_bone_transform(i, bone_mats[i * 16 .. (i + 1) * 16]);
    }

    // Upload (host converts 4x4 → 3x4)
    set_bones_4x4(&amp;bone_mats, bone_count);
    draw_mesh(skinned_mesh);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="skinned-vertex-format"><a class="header" href="#skinned-vertex-format">Skinned Vertex Format</a></h2>
<p>Add <code>FORMAT_SKINNED</code> (8) to your vertex format for skinned meshes:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const FORMAT_SKINNED: u32 = 8;

// Common skinned formats
const FORMAT_SKINNED_UV_NORMAL: u32 = FORMAT_SKINNED | FORMAT_UV | FORMAT_NORMAL; // 13
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define FORMAT_SKINNED 8

// Common skinned formats
#define FORMAT_SKINNED_UV_NORMAL (FORMAT_SKINNED | FORMAT_UV | FORMAT_NORMAL) // 13
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const FORMAT_SKINNED: u32 = 8;

// Common skinned formats
const FORMAT_SKINNED_UV_NORMAL: u32 = FORMAT_SKINNED | FORMAT_UV | FORMAT_NORMAL; // 13
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Skinned vertex data layout:</strong></p>
<pre><code>position (3 floats)
uv (2 floats, if FORMAT_UV)
color (3 floats, if FORMAT_COLOR)
normal (3 floats, if FORMAT_NORMAL)
bone_indices (4 u8, packed as 4 bytes)
bone_weights (4 floats)
</code></pre>
<p><strong>Example vertex (FORMAT_SKINNED_UV_NORMAL):</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// 52 bytes per vertex: 3 + 2 + 3 + 4bytes + 4 floats
let vertex = [
    0.0, 1.0, 0.0,     // position
    0.5, 0.5,          // uv
    0.0, 1.0, 0.0,     // normal
    // bone_indices: [0, 1, 255, 255] as 4 bytes
    // bone_weights: [0.7, 0.3, 0.0, 0.0] as 4 floats
];
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// 52 bytes per vertex: 3 + 2 + 3 + 4bytes + 4 floats
float vertex[] = {
    0.0f, 1.0f, 0.0f,     // position
    0.5f, 0.5f,           // uv
    0.0f, 1.0f, 0.0f,     // normal
    // bone_indices: [0, 1, 255, 255] as 4 bytes
    // bone_weights: [0.7f, 0.3f, 0.0f, 0.0f] as 4 floats
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// 52 bytes per vertex: 3 + 2 + 3 + 4bytes + 4 floats
const vertex = [_]f32{
    0.0, 1.0, 0.0,     // position
    0.5, 0.5,          // uv
    0.0, 1.0, 0.0,     // normal
    // bone_indices: [0, 1, 255, 255] as 4 bytes
    // bone_weights: [0.7, 0.3, 0.0, 0.0] as 4 floats
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-4"><a class="header" href="#complete-example-4">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SKELETON: u32 = 0;
static mut CHARACTER_MESH: u32 = 0;
static mut BONE_MATRICES: [f32; 32 * 12] = [0.0; 32 * 12];
const BONE_COUNT: usize = 32;

fn init() {
    unsafe {
        // Load skeleton
        SKELETON = rom_skeleton(b"player_rig".as_ptr(), 10);

        // Load skinned mesh
        CHARACTER_MESH = rom_mesh(b"player".as_ptr(), 6);

        // Initialize bones to identity
        for i in 0..BONE_COUNT {
            let o = i * 12;
            BONE_MATRICES[o + 0] = 1.0;
            BONE_MATRICES[o + 4] = 1.0;
            BONE_MATRICES[o + 8] = 1.0;
        }
    }
}

fn update() {
    unsafe {
        // Animate bones (your animation logic here)
        animate_walk_cycle(&amp;mut BONE_MATRICES, elapsed_time());
    }
}

fn render() {
    unsafe {
        // Bind skeleton for inverse bind mode
        skeleton_bind(SKELETON);

        // Upload bone transforms
        set_bones(BONE_MATRICES.as_ptr(), BONE_COUNT as u32);

        // Draw character
        texture_bind(character_texture);
        push_identity();
        push_translate(player_x, player_y, player_z);
        draw_mesh(CHARACTER_MESH);

        // Unbind skeleton
        skeleton_bind(0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t SKELETON = 0;
static uint32_t CHARACTER_MESH = 0;
static float BONE_MATRICES[32 * 12];
#define BONE_COUNT 32

EWZX_EXPORT void init(void) {
    // Load skeleton
    SKELETON = rom_skeleton("player_rig", 10);

    // Load skinned mesh
    CHARACTER_MESH = rom_mesh("player", 6);

    // Initialize bones to identity
    for (int i = 0; i &lt; BONE_COUNT; i++) {
        int o = i * 12;
        BONE_MATRICES[o + 0] = 1.0f;
        BONE_MATRICES[o + 4] = 1.0f;
        BONE_MATRICES[o + 8] = 1.0f;
    }
}

EWZX_EXPORT void update(void) {
    // Animate bones (your animation logic here)
    animate_walk_cycle(BONE_MATRICES, elapsed_time());
}

EWZX_EXPORT void render(void) {
    // Bind skeleton for inverse bind mode
    skeleton_bind(SKELETON);

    // Upload bone transforms
    set_bones(BONE_MATRICES, BONE_COUNT);

    // Draw character
    texture_bind(character_texture);
    push_identity();
    push_translate(player_x, player_y, player_z);
    draw_mesh(CHARACTER_MESH);

    // Unbind skeleton
    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var SKELETON: u32 = 0;
var CHARACTER_MESH: u32 = 0;
var BONE_MATRICES: [32 * 12]f32 = undefined;
const BONE_COUNT: usize = 32;

export fn init() void {
    // Load skeleton
    SKELETON = rom_skeleton("player_rig", 10);

    // Load skinned mesh
    CHARACTER_MESH = rom_mesh("player", 6);

    // Initialize bones to identity
    for (0..BONE_COUNT) |i| {
        const o = i * 12;
        BONE_MATRICES[o + 0] = 1.0;
        BONE_MATRICES[o + 4] = 1.0;
        BONE_MATRICES[o + 8] = 1.0;
    }
}

export fn update() void {
    // Animate bones (your animation logic here)
    animate_walk_cycle(&amp;BONE_MATRICES, elapsed_time());
}

export fn render() void {
    // Bind skeleton for inverse bind mode
    skeleton_bind(SKELETON);

    // Upload bone transforms
    set_bones(&amp;BONE_MATRICES, BONE_COUNT);

    // Draw character
    texture_bind(character_texture);
    push_identity();
    push_translate(player_x, player_y, player_z);
    draw_mesh(CHARACTER_MESH);

    // Unbind skeleton
    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#keyframe-animation-functions">Animation Functions</a>, <a href="#rom_skeleton">rom_skeleton</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="keyframe-animation-functions"><a class="header" href="#keyframe-animation-functions">Keyframe Animation Functions</a></h1>
<p>GPU-optimized keyframe animation system for skeletal animation.</p>
<h2 id="loading-keyframes"><a class="header" href="#loading-keyframes">Loading Keyframes</a></h2>
<h3 id="keyframes_load"><a class="header" href="#keyframes_load">keyframes_load</a></h3>
<p>Loads keyframes from WASM memory.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyframes_load(data_ptr: *const u8, byte_size: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t keyframes_load(const uint8_t* data_ptr, uint32_t byte_size);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn keyframes_load(data_ptr: [*]const u8, byte_size: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to keyframe data</td></tr>
<tr><td>byte_size</td><td><code>u32</code></td><td>Size of data in bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Keyframe collection handle (non-zero on success)</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static WALK_DATA: &amp;[u8] = include_bytes!("walk.ewzanim");
static mut WALK_ANIM: u32 = 0;

fn init() {
    unsafe {
        WALK_ANIM = keyframes_load(WALK_DATA.as_ptr(), WALK_DATA.len() as u32);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static const uint8_t WALK_DATA[] = { /* embedded data */ };
static uint32_t WALK_ANIM = 0;

EWZX_EXPORT void init(void) {
    WALK_ANIM = keyframes_load(WALK_DATA, sizeof(WALK_DATA));
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const WALK_DATA = @embedFile("walk.ewzanim");
var WALK_ANIM: u32 = 0;

export fn init() void {
    WALK_ANIM = keyframes_load(WALK_DATA.ptr, WALK_DATA.len);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_keyframes"><a class="header" href="#rom_keyframes">rom_keyframes</a></h3>
<p>Loads keyframes from ROM data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_keyframes(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_keyframes(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_keyframes(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>id_ptr</td><td><code>*const u8</code></td><td>Pointer to asset ID string</td></tr>
<tr><td>id_len</td><td><code>u32</code></td><td>Length of asset ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Keyframe collection handle (non-zero on success)</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut WALK_ANIM: u32 = 0;
static mut IDLE_ANIM: u32 = 0;
static mut ATTACK_ANIM: u32 = 0;

fn init() {
    unsafe {
        WALK_ANIM = rom_keyframes(b"walk".as_ptr(), 4);
        IDLE_ANIM = rom_keyframes(b"idle".as_ptr(), 4);
        ATTACK_ANIM = rom_keyframes(b"attack".as_ptr(), 6);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t WALK_ANIM = 0;
static uint32_t IDLE_ANIM = 0;
static uint32_t ATTACK_ANIM = 0;

EWZX_EXPORT void init(void) {
    WALK_ANIM = rom_keyframes((const uint8_t*)"walk", 4);
    IDLE_ANIM = rom_keyframes((const uint8_t*)"idle", 4);
    ATTACK_ANIM = rom_keyframes((const uint8_t*)"attack", 6);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var WALK_ANIM: u32 = 0;
var IDLE_ANIM: u32 = 0;
var ATTACK_ANIM: u32 = 0;

export fn init() void {
    WALK_ANIM = rom_keyframes("walk", 4);
    IDLE_ANIM = rom_keyframes("idle", 4);
    ATTACK_ANIM = rom_keyframes("attack", 6);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="querying-keyframes"><a class="header" href="#querying-keyframes">Querying Keyframes</a></h2>
<h3 id="keyframes_bone_count"><a class="header" href="#keyframes_bone_count">keyframes_bone_count</a></h3>
<p>Gets the bone count for a keyframe collection.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyframes_bone_count(handle: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t keyframes_bone_count(uint32_t handle);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn keyframes_bone_count(handle: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Number of bones in the animation</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        WALK_ANIM = rom_keyframes(b"walk".as_ptr(), 4);
        let bones = keyframes_bone_count(WALK_ANIM);
        log_fmt(b"Walk animation has {} bones", bones);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    WALK_ANIM = rom_keyframes((const uint8_t*)"walk", 4);
    uint32_t bones = keyframes_bone_count(WALK_ANIM);
    log_fmt((const uint8_t*)"Walk animation has {} bones", bones);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    WALK_ANIM = rom_keyframes("walk", 4);
    const bones = keyframes_bone_count(WALK_ANIM);
    log_fmt("Walk animation has {} bones", bones);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="keyframes_frame_count"><a class="header" href="#keyframes_frame_count">keyframes_frame_count</a></h3>
<p>Gets the frame count for a keyframe collection.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyframes_frame_count(handle: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t keyframes_frame_count(uint32_t handle);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn keyframes_frame_count(handle: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Number of frames in the animation</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    unsafe {
        let frame_count = keyframes_frame_count(WALK_ANIM);
        let current_frame = (ANIM_TIME as u32) % frame_count;
        keyframe_bind(WALK_ANIM, current_frame);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    uint32_t frame_count = keyframes_frame_count(WALK_ANIM);
    uint32_t current_frame = ((uint32_t)ANIM_TIME) % frame_count;
    keyframe_bind(WALK_ANIM, current_frame);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    const frame_count = keyframes_frame_count(WALK_ANIM);
    const current_frame = @as(u32, @intFromFloat(ANIM_TIME)) % frame_count;
    keyframe_bind(WALK_ANIM, current_frame);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="using-keyframes"><a class="header" href="#using-keyframes">Using Keyframes</a></h2>
<h3 id="keyframe_bind"><a class="header" href="#keyframe_bind">keyframe_bind</a></h3>
<p>Binds a keyframe directly from GPU buffer (zero CPU overhead).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyframe_bind(handle: u32, index: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void keyframe_bind(uint32_t handle, uint32_t index);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn keyframe_bind(handle: u32, index: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>handle</td><td><code>u32</code></td><td>Keyframe collection handle</td></tr>
<tr><td>index</td><td><code>u32</code></td><td>Frame index (0 to frame_count-1)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut ANIM_FRAME: f32 = 0.0;

fn update() {
    unsafe {
        ANIM_FRAME += delta_time() * 30.0; // 30 FPS animation
    }
}

fn render() {
    unsafe {
        let frame_count = keyframes_frame_count(WALK_ANIM);
        let frame = (ANIM_FRAME as u32) % frame_count;

        // Bind frame - GPU reads directly, no CPU decode!
        keyframe_bind(WALK_ANIM, frame);
        draw_mesh(CHARACTER_MESH);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float ANIM_FRAME = 0.0f;

EWZX_EXPORT void update(void) {
    ANIM_FRAME += delta_time() * 30.0f; // 30 FPS animation
}

EWZX_EXPORT void render(void) {
    uint32_t frame_count = keyframes_frame_count(WALK_ANIM);
    uint32_t frame = ((uint32_t)ANIM_FRAME) % frame_count;

    // Bind frame - GPU reads directly, no CPU decode!
    keyframe_bind(WALK_ANIM, frame);
    draw_mesh(CHARACTER_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var ANIM_FRAME: f32 = 0.0;

export fn update() void {
    ANIM_FRAME += delta_time() * 30.0; // 30 FPS animation
}

export fn render() void {
    const frame_count = keyframes_frame_count(WALK_ANIM);
    const frame = @as(u32, @intFromFloat(ANIM_FRAME)) % frame_count;

    // Bind frame - GPU reads directly, no CPU decode!
    keyframe_bind(WALK_ANIM, frame);
    draw_mesh(CHARACTER_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="keyframe_read"><a class="header" href="#keyframe_read">keyframe_read</a></h3>
<p>Reads a keyframe to WASM memory for CPU-side blending.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn keyframe_read(handle: u32, index: u32, out_ptr: *mut u8)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void keyframe_read(uint32_t handle, uint32_t index, uint8_t* out_ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn keyframe_read(handle: u32, index: u32, out_ptr: [*]u8) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>handle</td><td><code>u32</code></td><td>Keyframe collection handle</td></tr>
<tr><td>index</td><td><code>u32</code></td><td>Frame index</td></tr>
<tr><td>out_ptr</td><td><code>*mut u8</code></td><td>Destination buffer (must be large enough for all bone matrices)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    unsafe {
        let frame_count = keyframes_frame_count(WALK_ANIM);
        let frame_a = (ANIM_TIME as u32) % frame_count;
        let frame_b = (frame_a + 1) % frame_count;
        let blend = ANIM_TIME.fract();

        // Read frames for interpolation
        let mut buf_a = [0u8; 64 * 12 * 4]; // 64 bones × 12 floats × 4 bytes
        let mut buf_b = [0u8; 64 * 12 * 4];

        keyframe_read(WALK_ANIM, frame_a, buf_a.as_mut_ptr());
        keyframe_read(WALK_ANIM, frame_b, buf_b.as_mut_ptr());

        // Interpolate on CPU
        let blended = interpolate_bones(&amp;buf_a, &amp;buf_b, blend);

        // Upload blended result
        set_bones(blended.as_ptr(), bone_count);
        draw_mesh(CHARACTER_MESH);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render(void) {
    uint32_t frame_count = keyframes_frame_count(WALK_ANIM);
    uint32_t frame_a = ((uint32_t)ANIM_TIME) % frame_count;
    uint32_t frame_b = (frame_a + 1) % frame_count;
    float blend = ANIM_TIME - (float)((uint32_t)ANIM_TIME);

    // Read frames for interpolation
    uint8_t buf_a[64 * 12 * 4]; // 64 bones × 12 floats × 4 bytes
    uint8_t buf_b[64 * 12 * 4];

    keyframe_read(WALK_ANIM, frame_a, buf_a);
    keyframe_read(WALK_ANIM, frame_b, buf_b);

    // Interpolate on CPU
    uint8_t blended[64 * 12 * 4];
    interpolate_bones(buf_a, buf_b, blend, blended);

    // Upload blended result
    set_bones(blended, bone_count);
    draw_mesh(CHARACTER_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    const frame_count = keyframes_frame_count(WALK_ANIM);
    const frame_a = @as(u32, @intFromFloat(ANIM_TIME)) % frame_count;
    const frame_b = (frame_a + 1) % frame_count;
    const blend = ANIM_TIME - @floor(ANIM_TIME);

    // Read frames for interpolation
    var buf_a: [64 * 12 * 4]u8 = undefined; // 64 bones × 12 floats × 4 bytes
    var buf_b: [64 * 12 * 4]u8 = undefined;

    keyframe_read(WALK_ANIM, frame_a, &amp;buf_a);
    keyframe_read(WALK_ANIM, frame_b, &amp;buf_b);

    // Interpolate on CPU
    var blended: [64 * 12 * 4]u8 = undefined;
    interpolate_bones(&amp;buf_a, &amp;buf_b, blend, &amp;blended);

    // Upload blended result
    set_bones(&amp;blended, bone_count);
    draw_mesh(CHARACTER_MESH);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="animation-paths"><a class="header" href="#animation-paths">Animation Paths</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Path</th><th>Function</th><th>Use Case</th><th>Performance</th></tr>
</thead>
<tbody>
<tr><td><strong>Static</strong></td><td><code>keyframe_bind()</code></td><td>Pre-baked ROM animations</td><td>Zero CPU work</td></tr>
<tr><td><strong>Immediate</strong></td><td><code>set_bones()</code></td><td>Procedural, IK, blended</td><td>Minimal overhead</td></tr>
</tbody>
</table>
</div>
<p><strong>Static keyframes:</strong> Data uploaded to GPU once in <code>init()</code>. <code>keyframe_bind()</code> just sets buffer offset.</p>
<p><strong>Immediate bones:</strong> Matrices appended to per-frame buffer, uploaded before rendering.</p>
<hr>
<h2 id="complete-example-5"><a class="header" href="#complete-example-5">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut SKELETON: u32 = 0;
static mut CHARACTER: u32 = 0;
static mut WALK_ANIM: u32 = 0;
static mut IDLE_ANIM: u32 = 0;
static mut ANIM_TIME: f32 = 0.0;
static mut IS_WALKING: bool = false;

fn init() {
    unsafe {
        SKELETON = rom_skeleton(b"player_rig".as_ptr(), 10);
        CHARACTER = rom_mesh(b"player".as_ptr(), 6);
        WALK_ANIM = rom_keyframes(b"walk".as_ptr(), 4);
        IDLE_ANIM = rom_keyframes(b"idle".as_ptr(), 4);
    }
}

fn update() {
    unsafe {
        // Check movement input
        let stick_x = left_stick_x(0);
        let stick_y = left_stick_y(0);
        IS_WALKING = stick_x.abs() &gt; 0.1 || stick_y.abs() &gt; 0.1;

        // Advance animation
        let anim_speed = if IS_WALKING { 30.0 } else { 15.0 };
        ANIM_TIME += delta_time() * anim_speed;
    }
}

fn render() {
    unsafe {
        skeleton_bind(SKELETON);

        // Choose animation
        let anim = if IS_WALKING { WALK_ANIM } else { IDLE_ANIM };
        let frame_count = keyframes_frame_count(anim);
        let frame = (ANIM_TIME as u32) % frame_count;

        // Bind keyframe (GPU-side, no CPU decode)
        keyframe_bind(anim, frame);

        // Draw character
        texture_bind(player_texture);
        push_identity();
        push_translate(player_x, player_y, player_z);
        draw_mesh(CHARACTER);

        skeleton_bind(0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t SKELETON = 0;
static uint32_t CHARACTER = 0;
static uint32_t WALK_ANIM = 0;
static uint32_t IDLE_ANIM = 0;
static float ANIM_TIME = 0.0f;
static bool IS_WALKING = false;

EWZX_EXPORT void init(void) {
    SKELETON = rom_skeleton((const uint8_t*)"player_rig", 10);
    CHARACTER = rom_mesh((const uint8_t*)"player", 6);
    WALK_ANIM = rom_keyframes((const uint8_t*)"walk", 4);
    IDLE_ANIM = rom_keyframes((const uint8_t*)"idle", 4);
}

EWZX_EXPORT void update(void) {
    // Check movement input
    float stick_x = left_stick_x(0);
    float stick_y = left_stick_y(0);
    IS_WALKING = (stick_x &gt; 0.1f || stick_x &lt; -0.1f) || (stick_y &gt; 0.1f || stick_y &lt; -0.1f);

    // Advance animation
    float anim_speed = IS_WALKING ? 30.0f : 15.0f;
    ANIM_TIME += delta_time() * anim_speed;
}

EWZX_EXPORT void render(void) {
    skeleton_bind(SKELETON);

    // Choose animation
    uint32_t anim = IS_WALKING ? WALK_ANIM : IDLE_ANIM;
    uint32_t frame_count = keyframes_frame_count(anim);
    uint32_t frame = ((uint32_t)ANIM_TIME) % frame_count;

    // Bind keyframe (GPU-side, no CPU decode)
    keyframe_bind(anim, frame);

    // Draw character
    texture_bind(player_texture);
    push_identity();
    push_translate(player_x, player_y, player_z);
    draw_mesh(CHARACTER);

    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var SKELETON: u32 = 0;
var CHARACTER: u32 = 0;
var WALK_ANIM: u32 = 0;
var IDLE_ANIM: u32 = 0;
var ANIM_TIME: f32 = 0.0;
var IS_WALKING: bool = false;

export fn init() void {
    SKELETON = rom_skeleton("player_rig", 10);
    CHARACTER = rom_mesh("player", 6);
    WALK_ANIM = rom_keyframes("walk", 4);
    IDLE_ANIM = rom_keyframes("idle", 4);
}

export fn update() void {
    // Check movement input
    const stick_x = left_stick_x(0);
    const stick_y = left_stick_y(0);
    IS_WALKING = @abs(stick_x) &gt; 0.1 or @abs(stick_y) &gt; 0.1;

    // Advance animation
    const anim_speed = if (IS_WALKING) 30.0 else 15.0;
    ANIM_TIME += delta_time() * anim_speed;
}

export fn render() void {
    skeleton_bind(SKELETON);

    // Choose animation
    const anim = if (IS_WALKING) WALK_ANIM else IDLE_ANIM;
    const frame_count = keyframes_frame_count(anim);
    const frame = @as(u32, @intFromFloat(ANIM_TIME)) % frame_count;

    // Bind keyframe (GPU-side, no CPU decode)
    keyframe_bind(anim, frame);

    // Draw character
    texture_bind(player_texture);
    push_identity();
    push_translate(player_x, player_y, player_z);
    draw_mesh(CHARACTER);

    skeleton_bind(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#skeletal-animation-functions">Skinning Functions</a>, <a href="#rom_keyframes">rom_keyframes</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="procedural-mesh-functions"><a class="header" href="#procedural-mesh-functions">Procedural Mesh Functions</a></h1>
<p>Generate common 3D primitives at runtime.</p>
<p>All procedural meshes use <strong>vertex format 5</strong> (POS_UV_NORMAL): 8 floats per vertex. Works with all render modes (0-3).</p>
<p><strong>Constraints:</strong> All functions are init-only. Call in <code>init()</code>.</p>
<hr>
<h2 id="basic-primitives"><a class="header" href="#basic-primitives">Basic Primitives</a></h2>
<h3 id="cube"><a class="header" href="#cube">cube</a></h3>
<p>Generates a box mesh.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cube(size_x: f32, size_y: f32, size_z: f32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t cube(float size_x, float size_y, float size_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn cube(size_x: f32, size_y: f32, size_z: f32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>size_x</td><td><code>f32</code></td><td>Half-width (total width = 2 × size_x)</td></tr>
<tr><td>size_y</td><td><code>f32</code></td><td>Half-height (total height = 2 × size_y)</td></tr>
<tr><td>size_z</td><td><code>f32</code></td><td>Half-depth (total depth = 2 × size_z)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        UNIT_CUBE = cube(0.5, 0.5, 0.5);      // 1×1×1 cube
        TALL_BOX = cube(1.0, 3.0, 1.0);       // 2×6×2 tall box
        FLAT_TILE = cube(2.0, 0.1, 2.0);      // 4×0.2×4 tile
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t unit_cube = 0;
static uint32_t tall_box = 0;
static uint32_t flat_tile = 0;

EWZX_EXPORT void init(void) {
    unit_cube = cube(0.5f, 0.5f, 0.5f);      // 1×1×1 cube
    tall_box = cube(1.0f, 3.0f, 1.0f);       // 2×6×2 tall box
    flat_tile = cube(2.0f, 0.1f, 2.0f);      // 4×0.2×4 tile
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var unit_cube: u32 = 0;
var tall_box: u32 = 0;
var flat_tile: u32 = 0;

export fn init() void {
    unit_cube = cube(0.5, 0.5, 0.5);      // 1×1×1 cube
    tall_box = cube(1.0, 3.0, 1.0);       // 2×6×2 tall box
    flat_tile = cube(2.0, 0.1, 2.0);      // 4×0.2×4 tile
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="sphere"><a class="header" href="#sphere">sphere</a></h3>
<p>Generates a UV sphere mesh.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sphere(radius: f32, segments: u32, rings: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t sphere(float radius, uint32_t segments, uint32_t rings);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn sphere(radius: f32, segments: u32, rings: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>radius</td><td><code>f32</code></td><td>Sphere radius</td></tr>
<tr><td>segments</td><td><code>u32</code></td><td>Horizontal divisions (3-256)</td></tr>
<tr><td>rings</td><td><code>u32</code></td><td>Vertical divisions (2-256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        LOW_POLY_SPHERE = sphere(1.0, 8, 6);    // 48 triangles
        SMOOTH_SPHERE = sphere(1.0, 32, 16);    // 960 triangles
        PLANET = sphere(100.0, 64, 32);         // Large, detailed
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t low_poly_sphere = 0;
static uint32_t smooth_sphere = 0;
static uint32_t planet = 0;

EWZX_EXPORT void init(void) {
    low_poly_sphere = sphere(1.0f, 8, 6);    // 48 triangles
    smooth_sphere = sphere(1.0f, 32, 16);    // 960 triangles
    planet = sphere(100.0f, 64, 32);         // Large, detailed
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var low_poly_sphere: u32 = 0;
var smooth_sphere: u32 = 0;
var planet: u32 = 0;

export fn init() void {
    low_poly_sphere = sphere(1.0, 8, 6);    // 48 triangles
    smooth_sphere = sphere(1.0, 32, 16);    // 960 triangles
    planet = sphere(100.0, 64, 32);         // Large, detailed
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="cylinder"><a class="header" href="#cylinder">cylinder</a></h3>
<p>Generates a cylinder or cone mesh.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cylinder(radius_bottom: f32, radius_top: f32, height: f32, segments: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t cylinder(float radius_bottom, float radius_top, float height, uint32_t segments);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn cylinder(radius_bottom: f32, radius_top: f32, height: f32, segments: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>radius_bottom</td><td><code>f32</code></td><td>Bottom cap radius</td></tr>
<tr><td>radius_top</td><td><code>f32</code></td><td>Top cap radius (0 for cone)</td></tr>
<tr><td>height</td><td><code>f32</code></td><td>Cylinder height</td></tr>
<tr><td>segments</td><td><code>u32</code></td><td>Radial divisions (3-256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        PILLAR = cylinder(0.5, 0.5, 3.0, 12);      // Uniform cylinder
        CONE = cylinder(1.0, 0.0, 2.0, 16);        // Cone
        TAPERED = cylinder(1.0, 0.5, 2.0, 16);     // Tapered cylinder
        BARREL = cylinder(0.8, 0.6, 1.5, 24);      // Barrel shape
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t pillar = 0;
static uint32_t cone = 0;
static uint32_t tapered = 0;
static uint32_t barrel = 0;

EWZX_EXPORT void init(void) {
    pillar = cylinder(0.5f, 0.5f, 3.0f, 12);      // Uniform cylinder
    cone = cylinder(1.0f, 0.0f, 2.0f, 16);        // Cone
    tapered = cylinder(1.0f, 0.5f, 2.0f, 16);     // Tapered cylinder
    barrel = cylinder(0.8f, 0.6f, 1.5f, 24);      // Barrel shape
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var pillar: u32 = 0;
var cone: u32 = 0;
var tapered: u32 = 0;
var barrel: u32 = 0;

export fn init() void {
    pillar = cylinder(0.5, 0.5, 3.0, 12);      // Uniform cylinder
    cone = cylinder(1.0, 0.0, 2.0, 16);        // Cone
    tapered = cylinder(1.0, 0.5, 2.0, 16);     // Tapered cylinder
    barrel = cylinder(0.8, 0.6, 1.5, 24);      // Barrel shape
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="plane"><a class="header" href="#plane">plane</a></h3>
<p>Generates a subdivided plane mesh (XZ plane, Y=0, facing up).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plane(size_x: f32, size_z: f32, subdivisions_x: u32, subdivisions_z: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t plane(float size_x, float size_z, uint32_t subdivisions_x, uint32_t subdivisions_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn plane(size_x: f32, size_z: f32, subdivisions_x: u32, subdivisions_z: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>size_x</td><td><code>f32</code></td><td>Half-width</td></tr>
<tr><td>size_z</td><td><code>f32</code></td><td>Half-depth</td></tr>
<tr><td>subdivisions_x</td><td><code>u32</code></td><td>X divisions (1-256)</td></tr>
<tr><td>subdivisions_z</td><td><code>u32</code></td><td>Z divisions (1-256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        GROUND = plane(50.0, 50.0, 1, 1);          // 100×100 simple quad
        TERRAIN = plane(100.0, 100.0, 32, 32);     // Subdivided for LOD
        WATER = plane(20.0, 20.0, 16, 16);         // Animated water
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t ground = 0;
static uint32_t terrain = 0;
static uint32_t water = 0;

EWZX_EXPORT void init(void) {
    ground = plane(50.0f, 50.0f, 1, 1);          // 100×100 simple quad
    terrain = plane(100.0f, 100.0f, 32, 32);     // Subdivided for LOD
    water = plane(20.0f, 20.0f, 16, 16);         // Animated water
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var ground: u32 = 0;
var terrain: u32 = 0;
var water: u32 = 0;

export fn init() void {
    ground = plane(50.0, 50.0, 1, 1);          // 100×100 simple quad
    terrain = plane(100.0, 100.0, 32, 32);     // Subdivided for LOD
    water = plane(20.0, 20.0, 16, 16);         // Animated water
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="torus"><a class="header" href="#torus">torus</a></h3>
<p>Generates a torus (donut) mesh.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn torus(major_radius: f32, minor_radius: f32, major_segments: u32, minor_segments: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t torus(float major_radius, float minor_radius, uint32_t major_segments, uint32_t minor_segments);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn torus(major_radius: f32, minor_radius: f32, major_segments: u32, minor_segments: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>major_radius</td><td><code>f32</code></td><td>Distance from center to tube center</td></tr>
<tr><td>minor_radius</td><td><code>f32</code></td><td>Tube thickness</td></tr>
<tr><td>major_segments</td><td><code>u32</code></td><td>Segments around ring (3-256)</td></tr>
<tr><td>minor_segments</td><td><code>u32</code></td><td>Segments around tube (3-256)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        DONUT = torus(2.0, 0.5, 32, 16);           // Classic donut
        RING = torus(3.0, 0.1, 48, 8);             // Thin ring
        TIRE = torus(1.5, 0.6, 24, 12);            // Car tire
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t donut = 0;
static uint32_t ring = 0;
static uint32_t tire = 0;

EWZX_EXPORT void init(void) {
    donut = torus(2.0f, 0.5f, 32, 16);           // Classic donut
    ring = torus(3.0f, 0.1f, 48, 8);             // Thin ring
    tire = torus(1.5f, 0.6f, 24, 12);            // Car tire
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var donut: u32 = 0;
var ring: u32 = 0;
var tire: u32 = 0;

export fn init() void {
    donut = torus(2.0, 0.5, 32, 16);           // Classic donut
    ring = torus(3.0, 0.1, 48, 8);             // Thin ring
    tire = torus(1.5, 0.6, 24, 12);            // Car tire
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="capsule"><a class="header" href="#capsule">capsule</a></h3>
<p>Generates a capsule (cylinder with hemispherical caps).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capsule(radius: f32, height: f32, segments: u32, rings: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t capsule(float radius, float height, uint32_t segments, uint32_t rings);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn capsule(radius: f32, height: f32, segments: u32, rings: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>radius</td><td><code>f32</code></td><td>Capsule radius</td></tr>
<tr><td>height</td><td><code>f32</code></td><td>Cylinder section height (total = height + 2×radius)</td></tr>
<tr><td>segments</td><td><code>u32</code></td><td>Radial divisions (3-256)</td></tr>
<tr><td>rings</td><td><code>u32</code></td><td>Hemisphere divisions (1-128)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        PILL = capsule(0.5, 1.0, 16, 8);           // Pill shape
        CHARACTER_COLLIDER = capsule(0.4, 1.2, 8, 4); // Physics capsule
        BULLET = capsule(0.1, 0.3, 12, 6);         // Projectile
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t pill = 0;
static uint32_t character_collider = 0;
static uint32_t bullet = 0;

EWZX_EXPORT void init(void) {
    pill = capsule(0.5f, 1.0f, 16, 8);           // Pill shape
    character_collider = capsule(0.4f, 1.2f, 8, 4); // Physics capsule
    bullet = capsule(0.1f, 0.3f, 12, 6);         // Projectile
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var pill: u32 = 0;
var character_collider: u32 = 0;
var bullet: u32 = 0;

export fn init() void {
    pill = capsule(0.5, 1.0, 16, 8);           // Pill shape
    character_collider = capsule(0.4, 1.2, 8, 4); // Physics capsule
    bullet = capsule(0.1, 0.3, 12, 6);         // Projectile
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="uv-mapped-variants"><a class="header" href="#uv-mapped-variants">UV-Mapped Variants</a></h2>
<p>These variants are identical but explicitly named for clarity.</p>
<h3 id="cube_uv"><a class="header" href="#cube_uv">cube_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cube_uv(size_x: f32, size_y: f32, size_z: f32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t cube_uv(float size_x, float size_y, float size_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn cube_uv(size_x: f32, size_y: f32, size_z: f32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>cube()</code>. UV coordinates map 0-1 on each face.</p>
<hr>
<h3 id="sphere_uv"><a class="header" href="#sphere_uv">sphere_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sphere_uv(radius: f32, segments: u32, rings: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t sphere_uv(float radius, uint32_t segments, uint32_t rings);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn sphere_uv(radius: f32, segments: u32, rings: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>sphere()</code>. Equirectangular UV mapping.</p>
<hr>
<h3 id="cylinder_uv"><a class="header" href="#cylinder_uv">cylinder_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn cylinder_uv(radius_bottom: f32, radius_top: f32, height: f32, segments: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t cylinder_uv(float radius_bottom, float radius_top, float height, uint32_t segments);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn cylinder_uv(radius_bottom: f32, radius_top: f32, height: f32, segments: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>cylinder()</code>. Radial unwrap for body, polar for caps.</p>
<hr>
<h3 id="plane_uv"><a class="header" href="#plane_uv">plane_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn plane_uv(size_x: f32, size_z: f32, subdivisions_x: u32, subdivisions_z: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t plane_uv(float size_x, float size_z, uint32_t subdivisions_x, uint32_t subdivisions_z);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn plane_uv(size_x: f32, size_z: f32, subdivisions_x: u32, subdivisions_z: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>plane()</code>. Simple 0-1 grid UV mapping.</p>
<hr>
<h3 id="torus_uv"><a class="header" href="#torus_uv">torus_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn torus_uv(major_radius: f32, minor_radius: f32, major_segments: u32, minor_segments: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t torus_uv(float major_radius, float minor_radius, uint32_t major_segments, uint32_t minor_segments);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn torus_uv(major_radius: f32, minor_radius: f32, major_segments: u32, minor_segments: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>torus()</code>. Wrapped UVs on both axes.</p>
<hr>
<h3 id="capsule_uv"><a class="header" href="#capsule_uv">capsule_uv</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn capsule_uv(radius: f32, height: f32, segments: u32, rings: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t capsule_uv(float radius, float height, uint32_t segments, uint32_t rings);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn capsule_uv(radius: f32, height: f32, segments: u32, rings: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p>Same as <code>capsule()</code>. Radial for body, polar for hemispheres.</p>
<hr>
<h2 id="complete-example-6"><a class="header" href="#complete-example-6">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut GROUND: u32 = 0;
static mut SPHERE: u32 = 0;
static mut CUBE: u32 = 0;
static mut PILLAR: u32 = 0;

fn init() {
    unsafe {
        render_mode(2); // PBR lighting

        // Generate primitives
        GROUND = plane(20.0, 20.0, 1, 1);
        SPHERE = sphere(1.0, 24, 12);
        CUBE = cube(0.5, 0.5, 0.5);
        PILLAR = cylinder(0.3, 0.3, 2.0, 16);
    }
}

fn render() {
    unsafe {
        camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

        // Ground
        material_roughness(0.9);
        material_metallic(0.0);
        set_color(0x556644FF);
        push_identity();
        draw_mesh(GROUND);

        // Central sphere
        material_roughness(0.3);
        material_metallic(1.0);
        set_color(0xFFD700FF);
        push_identity();
        push_translate(0.0, 1.0, 0.0);
        draw_mesh(SPHERE);

        // Pillars
        set_color(0x888888FF);
        material_metallic(0.0);
        for i in 0..4 {
            let angle = (i as f32) * 1.57;
            push_identity();
            push_translate(angle.cos() * 5.0, 1.0, angle.sin() * 5.0);
            draw_mesh(PILLAR);
        }

        // Floating cubes
        set_color(0x4488FFFF);
        for i in 0..8 {
            let t = elapsed_time() + (i as f32) * 0.5;
            push_identity();
            push_translate(
                (t * 0.5).cos() * 3.0,
                2.0 + (t * 2.0).sin() * 0.5,
                (t * 0.5).sin() * 3.0
            );
            push_rotate_y(t * 90.0);
            draw_mesh(CUBE);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;math.h&gt;

static uint32_t ground = 0;
static uint32_t sphere = 0;
static uint32_t cube = 0;
static uint32_t pillar = 0;

EWZX_EXPORT void init(void) {
    render_mode(2); // PBR lighting

    // Generate primitives
    ground = plane(20.0f, 20.0f, 1, 1);
    sphere = sphere(1.0f, 24, 12);
    cube = cube(0.5f, 0.5f, 0.5f);
    pillar = cylinder(0.3f, 0.3f, 2.0f, 16);
}

EWZX_EXPORT void render(void) {
    camera_set(0.0f, 5.0f, 10.0f, 0.0f, 0.0f, 0.0f);

    // Ground
    material_roughness(0.9f);
    material_metallic(0.0f);
    set_color(0x556644FF);
    push_identity();
    draw_mesh(ground);

    // Central sphere
    material_roughness(0.3f);
    material_metallic(1.0f);
    set_color(0xFFD700FF);
    push_identity();
    push_translate(0.0f, 1.0f, 0.0f);
    draw_mesh(sphere);

    // Pillars
    set_color(0x888888FF);
    material_metallic(0.0f);
    for (int i = 0; i &lt; 4; i++) {
        float angle = (float)i * 1.57f;
        push_identity();
        push_translate(cosf(angle) * 5.0f, 1.0f, sinf(angle) * 5.0f);
        draw_mesh(pillar);
    }

    // Floating cubes
    set_color(0x4488FFFF);
    for (int i = 0; i &lt; 8; i++) {
        float t = elapsed_time() + (float)i * 0.5f;
        push_identity();
        push_translate(
            cosf(t * 0.5f) * 3.0f,
            2.0f + sinf(t * 2.0f) * 0.5f,
            sinf(t * 0.5f) * 3.0f
        );
        push_rotate_y(t * 90.0f);
        draw_mesh(cube);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const std = @import("std");

var ground: u32 = 0;
var sphere: u32 = 0;
var cube: u32 = 0;
var pillar: u32 = 0;

export fn init() void {
    render_mode(2); // PBR lighting

    // Generate primitives
    ground = plane(20.0, 20.0, 1, 1);
    sphere = sphere(1.0, 24, 12);
    cube = cube(0.5, 0.5, 0.5);
    pillar = cylinder(0.3, 0.3, 2.0, 16);
}

export fn render() void {
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // Ground
    material_roughness(0.9);
    material_metallic(0.0);
    set_color(0x556644FF);
    push_identity();
    draw_mesh(ground);

    // Central sphere
    material_roughness(0.3);
    material_metallic(1.0);
    set_color(0xFFD700FF);
    push_identity();
    push_translate(0.0, 1.0, 0.0);
    draw_mesh(sphere);

    // Pillars
    set_color(0x888888FF);
    material_metallic(0.0);
    var i: u32 = 0;
    while (i &lt; 4) : (i += 1) {
        const angle = @as(f32, @floatFromInt(i)) * 1.57;
        push_identity();
        push_translate(@cos(angle) * 5.0, 1.0, @sin(angle) * 5.0);
        draw_mesh(pillar);
    }

    // Floating cubes
    set_color(0x4488FFFF);
    i = 0;
    while (i &lt; 8) : (i += 1) {
        const t = elapsed_time() + @as(f32, @floatFromInt(i)) * 0.5;
        push_identity();
        push_translate(
            @cos(t * 0.5) * 3.0,
            2.0 + @sin(t * 2.0) * 0.5,
            @sin(t * 0.5) * 3.0
        );
        push_rotate_y(t * 90.0);
        draw_mesh(cube);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#mesh-functions">Meshes</a>, <a href="#rom_mesh">rom_mesh</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="2d-drawing-functions"><a class="header" href="#2d-drawing-functions">2D Drawing Functions</a></h1>
<p>Screen-space sprites, rectangles, and text rendering.</p>
<h2 id="sprites"><a class="header" href="#sprites">Sprites</a></h2>
<h3 id="draw_sprite"><a class="header" href="#draw_sprite">draw_sprite</a></h3>
<p>Draws a textured quad at screen coordinates.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sprite(x: f32, y: f32, w: f32, h: f32, color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_sprite(float x, float y, float w, float h, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_sprite(x: f32, y: f32, w: f32, h: f32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x, y</td><td><code>f32</code></td><td>Screen position (top-left corner)</td></tr>
<tr><td>w, h</td><td><code>f32</code></td><td>Size in pixels</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Tint color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Draw full texture
    texture_bind(player_sprite);
    draw_sprite(100.0, 100.0, 64.0, 64.0, 0xFFFFFFFF);

    // Tinted sprite
    draw_sprite(200.0, 100.0, 64.0, 64.0, 0xFF8080FF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Draw full texture
    texture_bind(player_sprite);
    draw_sprite(100.0f, 100.0f, 64.0f, 64.0f, 0xFFFFFFFF);

    // Tinted sprite
    draw_sprite(200.0f, 100.0f, 64.0f, 64.0f, 0xFF8080FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Draw full texture
    texture_bind(player_sprite);
    draw_sprite(100.0, 100.0, 64.0, 64.0, 0xFFFFFFFF);

    // Tinted sprite
    draw_sprite(200.0, 100.0, 64.0, 64.0, 0xFF8080FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="draw_sprite_region"><a class="header" href="#draw_sprite_region">draw_sprite_region</a></h3>
<p>Draws a region of a texture (sprite sheet).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sprite_region(
    x: f32, y: f32, w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    color: u32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_sprite_region(
    float x, float y, float w, float h,
    float src_x, float src_y, float src_w, float src_h,
    uint32_t color
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_sprite_region(
    x: f32, y: f32, w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    color: u32
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x, y</td><td><code>f32</code></td><td>Screen position</td></tr>
<tr><td>w, h</td><td><code>f32</code></td><td>Destination size in pixels</td></tr>
<tr><td>src_x, src_y</td><td><code>f32</code></td><td>Source position in texture (pixels)</td></tr>
<tr><td>src_w, src_h</td><td><code>f32</code></td><td>Source size in texture (pixels)</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Tint color</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Sprite sheet: 4x4 grid of 32x32 sprites
fn draw_frame(frame: u32) {
    let col = frame % 4;
    let row = frame / 4;
    draw_sprite_region(
        100.0, 100.0, 64.0, 64.0,           // Destination (scaled 2x)
        (col * 32) as f32, (row * 32) as f32, 32.0, 32.0, // Source
        0xFFFFFFFF
    );
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Sprite sheet: 4x4 grid of 32x32 sprites
EWZX_EXPORT void draw_frame(uint32_t frame) {
    uint32_t col = frame % 4;
    uint32_t row = frame / 4;
    draw_sprite_region(
        100.0f, 100.0f, 64.0f, 64.0f,           // Destination (scaled 2x)
        (float)(col * 32), (float)(row * 32), 32.0f, 32.0f, // Source
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Sprite sheet: 4x4 grid of 32x32 sprites
export fn draw_frame(frame: u32) void {
    const col = frame % 4;
    const row = frame / 4;
    draw_sprite_region(
        100.0, 100.0, 64.0, 64.0,           // Destination (scaled 2x)
        @floatFromInt(col * 32), @floatFromInt(row * 32), 32.0, 32.0, // Source
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="draw_sprite_ex"><a class="header" href="#draw_sprite_ex">draw_sprite_ex</a></h3>
<p>Draws a sprite with rotation and custom origin.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sprite_ex(
    x: f32, y: f32, w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    origin_x: f32, origin_y: f32,
    angle_deg: f32,
    color: u32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_sprite_ex(
    float x, float y, float w, float h,
    float src_x, float src_y, float src_w, float src_h,
    float origin_x, float origin_y,
    float angle_deg,
    uint32_t color
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_sprite_ex(
    x: f32, y: f32, w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    origin_x: f32, origin_y: f32,
    angle_deg: f32,
    color: u32
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x, y</td><td><code>f32</code></td><td>Screen position</td></tr>
<tr><td>w, h</td><td><code>f32</code></td><td>Destination size</td></tr>
<tr><td>src_x, src_y, src_w, src_h</td><td><code>f32</code></td><td>Source region</td></tr>
<tr><td>origin_x, origin_y</td><td><code>f32</code></td><td>Rotation origin (0-1 normalized)</td></tr>
<tr><td>angle_deg</td><td><code>f32</code></td><td>Rotation angle in degrees</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Tint color</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Rotating sprite around center
    draw_sprite_ex(
        200.0, 200.0, 64.0, 64.0,    // Position and size
        0.0, 0.0, 32.0, 32.0,        // Full texture
        0.5, 0.5,                     // Center origin
        elapsed_time() * 90.0,        // Rotation (90 deg/sec)
        0xFFFFFFFF
    );

    // Rotating around bottom-center (like a pendulum)
    draw_sprite_ex(
        300.0, 200.0, 64.0, 64.0,
        0.0, 0.0, 32.0, 32.0,
        0.5, 1.0,                     // Bottom-center origin
        (elapsed_time() * 2.0).sin() * 30.0,
        0xFFFFFFFF
    );
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Rotating sprite around center
    draw_sprite_ex(
        200.0f, 200.0f, 64.0f, 64.0f,    // Position and size
        0.0f, 0.0f, 32.0f, 32.0f,        // Full texture
        0.5f, 0.5f,                      // Center origin
        elapsed_time() * 90.0f,          // Rotation (90 deg/sec)
        0xFFFFFFFF
    );

    // Rotating around bottom-center (like a pendulum)
    draw_sprite_ex(
        300.0f, 200.0f, 64.0f, 64.0f,
        0.0f, 0.0f, 32.0f, 32.0f,
        0.5f, 1.0f,                      // Bottom-center origin
        sinf(elapsed_time() * 2.0f) * 30.0f,
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Rotating sprite around center
    draw_sprite_ex(
        200.0, 200.0, 64.0, 64.0,    // Position and size
        0.0, 0.0, 32.0, 32.0,        // Full texture
        0.5, 0.5,                     // Center origin
        elapsed_time() * 90.0,        // Rotation (90 deg/sec)
        0xFFFFFFFF
    );

    // Rotating around bottom-center (like a pendulum)
    draw_sprite_ex(
        300.0, 200.0, 64.0, 64.0,
        0.0, 0.0, 32.0, 32.0,
        0.5, 1.0,                     // Bottom-center origin
        @sin(elapsed_time() * 2.0) * 30.0,
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="rectangles"><a class="header" href="#rectangles">Rectangles</a></h2>
<h3 id="draw_rect"><a class="header" href="#draw_rect">draw_rect</a></h3>
<p>Draws a solid color rectangle.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_rect(float x, float y, float w, float h, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_rect(x: f32, y: f32, w: f32, h: f32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>x, y</td><td><code>f32</code></td><td>Screen position (top-left)</td></tr>
<tr><td>w, h</td><td><code>f32</code></td><td>Size in pixels</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Fill color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Health bar background
    draw_rect(10.0, 10.0, 100.0, 20.0, 0x333333FF);

    // Health bar fill
    let health_width = (health / max_health) * 96.0;
    draw_rect(12.0, 12.0, health_width, 16.0, 0x00FF00FF);

    // Semi-transparent overlay
    draw_rect(0.0, 0.0, 960.0, 540.0, 0x00000080);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Health bar background
    draw_rect(10.0f, 10.0f, 100.0f, 20.0f, 0x333333FF);

    // Health bar fill
    float health_width = (health / max_health) * 96.0f;
    draw_rect(12.0f, 12.0f, health_width, 16.0f, 0x00FF00FF);

    // Semi-transparent overlay
    draw_rect(0.0f, 0.0f, 960.0f, 540.0f, 0x00000080);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Health bar background
    draw_rect(10.0, 10.0, 100.0, 20.0, 0x333333FF);

    // Health bar fill
    const health_width = (health / max_health) * 96.0;
    draw_rect(12.0, 12.0, health_width, 16.0, 0x00FF00FF);

    // Semi-transparent overlay
    draw_rect(0.0, 0.0, 960.0, 540.0, 0x00000080);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="text"><a class="header" href="#text">Text</a></h2>
<h3 id="draw_text"><a class="header" href="#draw_text">draw_text</a></h3>
<p>Draws text using the bound font.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_text(ptr: *const u8, len: u32, x: f32, y: f32, size: f32, color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_text(const uint8_t* ptr, uint32_t len, float x, float y, float size, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_text(ptr: [*]const u8, len: u32, x: f32, y: f32, size: f32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>ptr</td><td><code>*const u8</code></td><td>Pointer to UTF-8 string</td></tr>
<tr><td>len</td><td><code>u32</code></td><td>String length in bytes</td></tr>
<tr><td>x, y</td><td><code>f32</code></td><td>Screen position</td></tr>
<tr><td>size</td><td><code>f32</code></td><td>Font size in pixels</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Text color</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    let text = b"SCORE: 12345";
    draw_text(text.as_ptr(), text.len() as u32, 10.0, 10.0, 16.0, 0xFFFFFFFF);

    let title = b"GAME OVER";
    draw_text(title.as_ptr(), title.len() as u32, 400.0, 270.0, 48.0, 0xFF0000FF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    const char* text = "SCORE: 12345";
    draw_text((const uint8_t*)text, strlen(text), 10.0f, 10.0f, 16.0f, 0xFFFFFFFF);

    const char* title = "GAME OVER";
    draw_text((const uint8_t*)title, strlen(title), 400.0f, 270.0f, 48.0f, 0xFF0000FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    const text = "SCORE: 12345";
    draw_text(text, text.len, 10.0, 10.0, 16.0, 0xFFFFFFFF);

    const title = "GAME OVER";
    draw_text(title, title.len, 400.0, 270.0, 48.0, 0xFF0000FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="custom-fonts"><a class="header" href="#custom-fonts">Custom Fonts</a></h2>
<h3 id="load_font"><a class="header" href="#load_font">load_font</a></h3>
<p>Loads a fixed-width bitmap font.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_font(
    texture: u32,
    char_width: u32,
    char_height: u32,
    first_codepoint: u32,
    char_count: u32
) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_font(
    uint32_t texture,
    uint32_t char_width,
    uint32_t char_height,
    uint32_t first_codepoint,
    uint32_t char_count
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_font(
    texture: u32,
    char_width: u32,
    char_height: u32,
    first_codepoint: u32,
    char_count: u32
) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>texture</td><td><code>u32</code></td><td>Font texture atlas handle</td></tr>
<tr><td>char_width</td><td><code>u32</code></td><td>Width of each character in pixels</td></tr>
<tr><td>char_height</td><td><code>u32</code></td><td>Height of each character in pixels</td></tr>
<tr><td>first_codepoint</td><td><code>u32</code></td><td>First character code (usually 32 for space)</td></tr>
<tr><td>char_count</td><td><code>u32</code></td><td>Number of characters in atlas</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Font handle</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        FONT_TEXTURE = load_texture(128, 64, FONT_PIXELS.as_ptr());
        // 8x8 font starting at space (32), 96 characters
        MY_FONT = load_font(FONT_TEXTURE, 8, 8, 32, 96);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init() {
    FONT_TEXTURE = load_texture(128, 64, FONT_PIXELS);
    // 8x8 font starting at space (32), 96 characters
    MY_FONT = load_font(FONT_TEXTURE, 8, 8, 32, 96);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    FONT_TEXTURE = load_texture(128, 64, FONT_PIXELS);
    // 8x8 font starting at space (32), 96 characters
    MY_FONT = load_font(FONT_TEXTURE, 8, 8, 32, 96);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="load_font_ex"><a class="header" href="#load_font_ex">load_font_ex</a></h3>
<p>Loads a variable-width bitmap font.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_font_ex(
    texture: u32,
    widths_ptr: *const u8,
    char_height: u32,
    first_codepoint: u32,
    char_count: u32
) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_font_ex(
    uint32_t texture,
    const uint8_t* widths_ptr,
    uint32_t char_height,
    uint32_t first_codepoint,
    uint32_t char_count
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_font_ex(
    texture: u32,
    widths_ptr: [*]const u8,
    char_height: u32,
    first_codepoint: u32,
    char_count: u32
) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>texture</td><td><code>u32</code></td><td>Font texture atlas handle</td></tr>
<tr><td>widths_ptr</td><td><code>*const u8</code></td><td>Pointer to array of character widths</td></tr>
<tr><td>char_height</td><td><code>u32</code></td><td>Height of each character</td></tr>
<tr><td>first_codepoint</td><td><code>u32</code></td><td>First character code</td></tr>
<tr><td>char_count</td><td><code>u32</code></td><td>Number of characters</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Font handle</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Width table for characters ' ' through '~'
static CHAR_WIDTHS: [u8; 96] = [
    4, 2, 4, 6, 6, 6, 6, 2, 3, 3, 4, 6, 2, 4, 2, 4, // space to /
    6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 4, 6, 4, 6, // 0 to ?
    // ... etc
];

fn init() {
    unsafe {
        PROP_FONT = load_font_ex(FONT_TEX, CHAR_WIDTHS.as_ptr(), 12, 32, 96);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Width table for characters ' ' through '~'
static uint8_t CHAR_WIDTHS[96] = {
    4, 2, 4, 6, 6, 6, 6, 2, 3, 3, 4, 6, 2, 4, 2, 4, // space to /
    6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 4, 6, 4, 6, // 0 to ?
    // ... etc
};

EWZX_EXPORT void init() {
    PROP_FONT = load_font_ex(FONT_TEX, CHAR_WIDTHS, 12, 32, 96);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Width table for characters ' ' through '~'
const CHAR_WIDTHS = [96]u8{
    4, 2, 4, 6, 6, 6, 6, 2, 3, 3, 4, 6, 2, 4, 2, 4, // space to /
    6, 4, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 4, 6, 4, 6, // 0 to ?
    // ... etc
};

export fn init() void {
    PROP_FONT = load_font_ex(FONT_TEX, &amp;CHAR_WIDTHS, 12, 32, 96);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="font_bind"><a class="header" href="#font_bind">font_bind</a></h3>
<p>Binds a font for subsequent <code>draw_text()</code> calls.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn font_bind(font_handle: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void font_bind(uint32_t font_handle);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn font_bind(font_handle: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Use custom font
    font_bind(MY_FONT);
    draw_text(b"Custom Text".as_ptr(), 11, 10.0, 10.0, 16.0, 0xFFFFFFFF);

    // Switch to different font
    font_bind(TITLE_FONT);
    draw_text(b"Title".as_ptr(), 5, 100.0, 50.0, 32.0, 0xFFD700FF);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Use custom font
    font_bind(MY_FONT);
    draw_text((const uint8_t*)"Custom Text", strlen("Custom Text"), 10.0f, 10.0f, 16.0f, 0xFFFFFFFF);

    // Switch to different font
    font_bind(TITLE_FONT);
    draw_text((const uint8_t*)"Title", strlen("Title"), 100.0f, 50.0f, 32.0f, 0xFFD700FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Use custom font
    font_bind(MY_FONT);
    draw_text("Custom Text", "Custom Text".len, 10.0, 10.0, 16.0, 0xFFFFFFFF);

    // Switch to different font
    font_bind(TITLE_FONT);
    draw_text("Title", "Title".len, 100.0, 50.0, 32.0, 0xFFD700FF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-7"><a class="header" href="#complete-example-7">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut UI_FONT: u32 = 0;
static mut ICON_SHEET: u32 = 0;

fn init() {
    unsafe {
        UI_FONT = rom_font(b"ui_font".as_ptr(), 7);
        ICON_SHEET = rom_texture(b"icons".as_ptr(), 5);
    }
}

fn render() {
    unsafe {
        // Disable depth for 2D overlay
        depth_test(0);
        blend_mode(1);

        // Background panel
        draw_rect(5.0, 5.0, 200.0, 80.0, 0x00000099);

        // Health bar
        draw_rect(10.0, 10.0, 102.0, 12.0, 0x333333FF);
        draw_rect(11.0, 11.0, health as f32, 10.0, 0x00FF00FF);

        // Health icon
        texture_bind(ICON_SHEET);
        draw_sprite_region(
            10.0, 25.0, 16.0, 16.0,   // Position
            0.0, 0.0, 16.0, 16.0,     // Heart icon
            0xFFFFFFFF
        );

        // Score text
        font_bind(UI_FONT);
        let score_text = b"SCORE: 12345";
        draw_text(score_text.as_ptr(), score_text.len() as u32,
                  30.0, 25.0, 12.0, 0xFFFFFFFF);

        // Animated coin icon
        let frame = ((elapsed_time() * 8.0) as u32) % 4;
        draw_sprite_region(
            10.0, 45.0, 16.0, 16.0,
            (frame * 16) as f32, 16.0, 16.0, 16.0,
            0xFFD700FF
        );

        // Re-enable depth for 3D
        depth_test(1);
        blend_mode(0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t UI_FONT = 0;
static uint32_t ICON_SHEET = 0;

EWZX_EXPORT void init() {
    UI_FONT = rom_font("ui_font", strlen("ui_font"));
    ICON_SHEET = rom_texture("icons", strlen("icons"));
}

EWZX_EXPORT void render() {
    // Disable depth for 2D overlay
    depth_test(0);
    blend_mode(1);

    // Background panel
    draw_rect(5.0f, 5.0f, 200.0f, 80.0f, 0x00000099);

    // Health bar
    draw_rect(10.0f, 10.0f, 102.0f, 12.0f, 0x333333FF);
    draw_rect(11.0f, 11.0f, (float)health, 10.0f, 0x00FF00FF);

    // Health icon
    texture_bind(ICON_SHEET);
    draw_sprite_region(
        10.0f, 25.0f, 16.0f, 16.0f,   // Position
        0.0f, 0.0f, 16.0f, 16.0f,     // Heart icon
        0xFFFFFFFF
    );

    // Score text
    font_bind(UI_FONT);
    const char* score_text = "SCORE: 12345";
    draw_text((const uint8_t*)score_text, strlen(score_text),
              30.0f, 25.0f, 12.0f, 0xFFFFFFFF);

    // Animated coin icon
    uint32_t frame = ((uint32_t)(elapsed_time() * 8.0f)) % 4;
    draw_sprite_region(
        10.0f, 45.0f, 16.0f, 16.0f,
        (float)(frame * 16), 16.0f, 16.0f, 16.0f,
        0xFFD700FF
    );

    // Re-enable depth for 3D
    depth_test(1);
    blend_mode(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var UI_FONT: u32 = 0;
var ICON_SHEET: u32 = 0;

export fn init() void {
    UI_FONT = rom_font("ui_font", "ui_font".len);
    ICON_SHEET = rom_texture("icons", "icons".len);
}

export fn render() void {
    // Disable depth for 2D overlay
    depth_test(0);
    blend_mode(1);

    // Background panel
    draw_rect(5.0, 5.0, 200.0, 80.0, 0x00000099);

    // Health bar
    draw_rect(10.0, 10.0, 102.0, 12.0, 0x333333FF);
    draw_rect(11.0, 11.0, @floatFromInt(health), 10.0, 0x00FF00FF);

    // Health icon
    texture_bind(ICON_SHEET);
    draw_sprite_region(
        10.0, 25.0, 16.0, 16.0,   // Position
        0.0, 0.0, 16.0, 16.0,     // Heart icon
        0xFFFFFFFF
    );

    // Score text
    font_bind(UI_FONT);
    const score_text = "SCORE: 12345";
    draw_text(score_text, score_text.len,
              30.0, 25.0, 12.0, 0xFFFFFFFF);

    // Animated coin icon
    const frame = @as(u32, @intFromFloat(elapsed_time() * 8.0)) % 4;
    draw_sprite_region(
        10.0, 45.0, 16.0, 16.0,
        @floatFromInt(frame * 16), 16.0, 16.0, 16.0,
        0xFFD700FF
    );

    // Re-enable depth for 3D
    depth_test(1);
    blend_mode(0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#rom_font">rom_font</a>, <a href="#texture-functions">Textures</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="billboard-functions"><a class="header" href="#billboard-functions">Billboard Functions</a></h1>
<p>Camera-facing quads for sprites in 3D space.</p>
<h2 id="billboard-modes"><a class="header" href="#billboard-modes">Billboard Modes</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Mode</th><th>Name</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>1</td><td>Spherical</td><td>Always faces camera (all axes)</td></tr>
<tr><td>2</td><td>Cylindrical Y</td><td>Rotates around Y axis only (trees, NPCs)</td></tr>
<tr><td>3</td><td>Cylindrical X</td><td>Rotates around X axis only</td></tr>
<tr><td>4</td><td>Cylindrical Z</td><td>Rotates around Z axis only</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="functions"><a class="header" href="#functions">Functions</a></h2>
<h3 id="draw_billboard"><a class="header" href="#draw_billboard">draw_billboard</a></h3>
<p>Draws a camera-facing quad using the bound texture.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_billboard(w: f32, h: f32, mode: u32, color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_billboard(float w, float h, uint32_t mode, uint32_t color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_billboard(w: f32, h: f32, mode: u32, color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>w</td><td><code>f32</code></td><td>Width in world units</td></tr>
<tr><td>h</td><td><code>f32</code></td><td>Height in world units</td></tr>
<tr><td>mode</td><td><code>u32</code></td><td>Billboard mode (1-4)</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Tint color as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(tree_sprite);

    // Trees with cylindrical Y billboards
    for tree in &amp;trees {
        push_identity();
        push_translate(tree.x, tree.y, tree.z);
        draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);
    }

    // Particles with spherical billboards
    texture_bind(particle_sprite);
    blend_mode(2); // Additive
    for particle in &amp;particles {
        push_identity();
        push_translate(particle.x, particle.y, particle.z);
        draw_billboard(0.5, 0.5, 1, particle.color);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    texture_bind(tree_sprite);

    // Trees with cylindrical Y billboards
    for (int i = 0; i &lt; tree_count; i++) {
        push_identity();
        push_translate(trees[i].x, trees[i].y, trees[i].z);
        draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);
    }

    // Particles with spherical billboards
    texture_bind(particle_sprite);
    blend_mode(2); // Additive
    for (int i = 0; i &lt; particle_count; i++) {
        push_identity();
        push_translate(particles[i].x, particles[i].y, particles[i].z);
        draw_billboard(0.5, 0.5, 1, particles[i].color);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(tree_sprite);

    // Trees with cylindrical Y billboards
    for (trees) |tree| {
        push_identity();
        push_translate(tree.x, tree.y, tree.z);
        draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);
    }

    // Particles with spherical billboards
    texture_bind(particle_sprite);
    blend_mode(2); // Additive
    for (particles) |particle| {
        push_identity();
        push_translate(particle.x, particle.y, particle.z);
        draw_billboard(0.5, 0.5, 1, particle.color);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="draw_billboard_region"><a class="header" href="#draw_billboard_region">draw_billboard_region</a></h3>
<p>Draws a billboard using a texture region (sprite sheet).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_billboard_region(
    w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    mode: u32,
    color: u32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_billboard_region(
    float w, float h,
    float src_x, float src_y, float src_w, float src_h,
    uint32_t mode,
    uint32_t color
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_billboard_region(
    w: f32, h: f32,
    src_x: f32, src_y: f32, src_w: f32, src_h: f32,
    mode: u32,
    color: u32
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>w, h</td><td><code>f32</code></td><td>Size in world units</td></tr>
<tr><td>src_x, src_y</td><td><code>f32</code></td><td>Source position in texture (pixels)</td></tr>
<tr><td>src_w, src_h</td><td><code>f32</code></td><td>Source size in texture (pixels)</td></tr>
<tr><td>mode</td><td><code>u32</code></td><td>Billboard mode (1-4)</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Tint color</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(enemy_sheet);

    // Animated enemy sprite
    let frame = ((elapsed_time() * 8.0) as u32) % 4;
    push_identity();
    push_translate(enemy.x, enemy.y + 1.0, enemy.z);
    draw_billboard_region(
        2.0, 2.0,                              // Size
        (frame * 32) as f32, 0.0, 32.0, 32.0,  // Animation frame
        2,                                      // Cylindrical Y
        0xFFFFFFFF
    );
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    texture_bind(enemy_sheet);

    // Animated enemy sprite
    uint32_t frame = ((uint32_t)(elapsed_time() * 8.0)) % 4;
    push_identity();
    push_translate(enemy.x, enemy.y + 1.0, enemy.z);
    draw_billboard_region(
        2.0, 2.0,                              // Size
        (float)(frame * 32), 0.0, 32.0, 32.0,  // Animation frame
        2,                                      // Cylindrical Y
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(enemy_sheet);

    // Animated enemy sprite
    const frame = (@as(u32, @intFromFloat(elapsed_time() * 8.0))) % 4;
    push_identity();
    push_translate(enemy.x, enemy.y + 1.0, enemy.z);
    draw_billboard_region(
        2.0, 2.0,                              // Size
        @as(f32, @floatFromInt(frame * 32)), 0.0, 32.0, 32.0,  // Animation frame
        2,                                      // Cylindrical Y
        0xFFFFFFFF
    );
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="trees-and-vegetation"><a class="header" href="#trees-and-vegetation">Trees and Vegetation</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(vegetation_atlas);
    blend_mode(1); // Alpha blend for transparency
    cull_mode(0);  // Double-sided

    for tree in &amp;trees {
        push_identity();
        push_translate(tree.x, tree.height * 0.5, tree.z);

        // Different tree types from atlas
        let src_x = (tree.type_id * 64) as f32;
        draw_billboard_region(
            tree.width, tree.height,
            src_x, 0.0, 64.0, 128.0,
            2, // Cylindrical Y - always upright
            0xFFFFFFFF
        );
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    texture_bind(vegetation_atlas);
    blend_mode(1); // Alpha blend for transparency
    cull_mode(0);  // Double-sided

    for (int i = 0; i &lt; tree_count; i++) {
        push_identity();
        push_translate(trees[i].x, trees[i].height * 0.5, trees[i].z);

        // Different tree types from atlas
        float src_x = (float)(trees[i].type_id * 64);
        draw_billboard_region(
            trees[i].width, trees[i].height,
            src_x, 0.0, 64.0, 128.0,
            2, // Cylindrical Y - always upright
            0xFFFFFFFF
        );
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(vegetation_atlas);
    blend_mode(1); // Alpha blend for transparency
    cull_mode(0);  // Double-sided

    for (trees) |tree| {
        push_identity();
        push_translate(tree.x, tree.height * 0.5, tree.z);

        // Different tree types from atlas
        const src_x = @as(f32, @floatFromInt(tree.type_id * 64));
        draw_billboard_region(
            tree.width, tree.height,
            src_x, 0.0, 64.0, 128.0,
            2, // Cylindrical Y - always upright
            0xFFFFFFFF
        );
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="particle-effects"><a class="header" href="#particle-effects">Particle Effects</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(particle_texture);
    blend_mode(2); // Additive for glow
    depth_test(1);

    for particle in &amp;particles {
        push_identity();
        push_translate(particle.x, particle.y, particle.z);

        // Spherical billboard - faces camera completely
        let alpha = (particle.life * 255.0) as u32;
        let color = (particle.color &amp; 0xFFFFFF00) | alpha;
        draw_billboard(particle.size, particle.size, 1, color);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    texture_bind(particle_texture);
    blend_mode(2); // Additive for glow
    depth_test(1);

    for (int i = 0; i &lt; particle_count; i++) {
        push_identity();
        push_translate(particles[i].x, particles[i].y, particles[i].z);

        // Spherical billboard - faces camera completely
        uint32_t alpha = (uint32_t)(particles[i].life * 255.0);
        uint32_t color = (particles[i].color &amp; 0xFFFFFF00) | alpha;
        draw_billboard(particles[i].size, particles[i].size, 1, color);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(particle_texture);
    blend_mode(2); // Additive for glow
    depth_test(1);

    for (particles) |particle| {
        push_identity();
        push_translate(particle.x, particle.y, particle.z);

        // Spherical billboard - faces camera completely
        const alpha = @as(u32, @intFromFloat(particle.life * 255.0));
        const color = (particle.color &amp; 0xFFFFFF00) | alpha;
        draw_billboard(particle.size, particle.size, 1, color);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="npcs-and-enemies"><a class="header" href="#npcs-and-enemies">NPCs and Enemies</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    texture_bind(npc_sheet);
    blend_mode(1);

    for npc in &amp;npcs {
        push_identity();
        push_translate(npc.x, npc.y + 1.0, npc.z);

        // Select animation frame based on direction and state
        let frame = get_npc_frame(npc);
        draw_billboard_region(
            2.0, 2.0,
            (frame % 4 * 32) as f32,
            (frame / 4 * 32) as f32,
            32.0, 32.0,
            2, // Cylindrical Y
            0xFFFFFFFF
        );
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    texture_bind(npc_sheet);
    blend_mode(1);

    for (int i = 0; i &lt; npc_count; i++) {
        push_identity();
        push_translate(npcs[i].x, npcs[i].y + 1.0, npcs[i].z);

        // Select animation frame based on direction and state
        uint32_t frame = get_npc_frame(&amp;npcs[i]);
        draw_billboard_region(
            2.0, 2.0,
            (float)(frame % 4 * 32),
            (float)(frame / 4 * 32),
            32.0, 32.0,
            2, // Cylindrical Y
            0xFFFFFFFF
        );
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    texture_bind(npc_sheet);
    blend_mode(1);

    for (npcs) |npc| {
        push_identity();
        push_translate(npc.x, npc.y + 1.0, npc.z);

        // Select animation frame based on direction and state
        const frame = get_npc_frame(npc);
        draw_billboard_region(
            2.0, 2.0,
            @as(f32, @floatFromInt(frame % 4 * 32)),
            @as(f32, @floatFromInt(frame / 4 * 32)),
            32.0, 32.0,
            2, // Cylindrical Y
            0xFFFFFFFF
        );
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="health-bars-above-enemies"><a class="header" href="#health-bars-above-enemies">Health Bars Above Enemies</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Draw enemies first
    for enemy in &amp;enemies {
        draw_enemy(enemy);
    }

    // Then draw health bars as billboards
    depth_test(0); // On top of everything
    texture_bind(0); // No texture (solid color)

    for enemy in &amp;enemies {
        if enemy.health &lt; enemy.max_health {
            push_identity();
            push_translate(enemy.x, enemy.y + 2.5, enemy.z);

            // Background
            draw_billboard(1.0, 0.1, 1, 0x333333FF);

            // Health fill
            let ratio = enemy.health / enemy.max_health;
            push_scale(ratio, 1.0, 1.0);
            draw_billboard(1.0, 0.1, 1, 0x00FF00FF);
        }
    }

    depth_test(1);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Draw enemies first
    for (int i = 0; i &lt; enemy_count; i++) {
        draw_enemy(&amp;enemies[i]);
    }

    // Then draw health bars as billboards
    depth_test(0); // On top of everything
    texture_bind(0); // No texture (solid color)

    for (int i = 0; i &lt; enemy_count; i++) {
        if (enemies[i].health &lt; enemies[i].max_health) {
            push_identity();
            push_translate(enemies[i].x, enemies[i].y + 2.5, enemies[i].z);

            // Background
            draw_billboard(1.0, 0.1, 1, 0x333333FF);

            // Health fill
            float ratio = enemies[i].health / enemies[i].max_health;
            push_scale(ratio, 1.0, 1.0);
            draw_billboard(1.0, 0.1, 1, 0x00FF00FF);
        }
    }

    depth_test(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Draw enemies first
    for (enemies) |enemy| {
        draw_enemy(enemy);
    }

    // Then draw health bars as billboards
    depth_test(0); // On top of everything
    texture_bind(0); // No texture (solid color)

    for (enemies) |enemy| {
        if (enemy.health &lt; enemy.max_health) {
            push_identity();
            push_translate(enemy.x, enemy.y + 2.5, enemy.z);

            // Background
            draw_billboard(1.0, 0.1, 1, 0x333333FF);

            // Health fill
            const ratio = enemy.health / enemy.max_health;
            push_scale(ratio, 1.0, 1.0);
            draw_billboard(1.0, 0.1, 1, 0x00FF00FF);
        }
    }

    depth_test(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-8"><a class="header" href="#complete-example-8">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TREE_TEX: u32 = 0;
static mut PARTICLE_TEX: u32 = 0;

struct Particle {
    x: f32, y: f32, z: f32,
    vx: f32, vy: f32, vz: f32,
    life: f32,
    size: f32,
}

static mut PARTICLES: [Particle; 100] = [Particle {
    x: 0.0, y: 0.0, z: 0.0,
    vx: 0.0, vy: 0.0, vz: 0.0,
    life: 0.0, size: 0.0,
}; 100];

fn init() {
    unsafe {
        TREE_TEX = rom_texture(b"tree".as_ptr(), 4);
        PARTICLE_TEX = rom_texture(b"spark".as_ptr(), 5);
    }
}

fn update() {
    unsafe {
        let dt = delta_time();
        for p in &amp;mut PARTICLES {
            if p.life &gt; 0.0 {
                p.x += p.vx * dt;
                p.y += p.vy * dt;
                p.z += p.vz * dt;
                p.vy -= 5.0 * dt; // Gravity
                p.life -= dt;
            }
        }
    }
}

fn render() {
    unsafe {
        // Trees - cylindrical billboards
        texture_bind(TREE_TEX);
        blend_mode(1);
        cull_mode(0);

        push_identity();
        push_translate(5.0, 2.0, -5.0);
        draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);

        push_identity();
        push_translate(-3.0, 1.5, -8.0);
        draw_billboard(1.5, 3.0, 2, 0xFFFFFFFF);

        // Particles - spherical billboards
        texture_bind(PARTICLE_TEX);
        blend_mode(2); // Additive

        for p in &amp;PARTICLES {
            if p.life &gt; 0.0 {
                push_identity();
                push_translate(p.x, p.y, p.z);
                let alpha = (p.life.min(1.0) * 255.0) as u32;
                draw_billboard(p.size, p.size, 1, 0xFFAA00FF &amp; (0xFFFFFF00 | alpha));
            }
        }

        blend_mode(0);
        cull_mode(1);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#include &lt;math.h&gt;

static uint32_t tree_tex = 0;
static uint32_t particle_tex = 0;

typedef struct {
    float x, y, z;
    float vx, vy, vz;
    float life;
    float size;
} Particle;

static Particle particles[100] = {0};

EWZX_EXPORT void init() {
    tree_tex = rom_texture("tree", 4);
    particle_tex = rom_texture("spark", 5);
}

EWZX_EXPORT void update() {
    float dt = delta_time();
    for (int i = 0; i &lt; 100; i++) {
        if (particles[i].life &gt; 0.0) {
            particles[i].x += particles[i].vx * dt;
            particles[i].y += particles[i].vy * dt;
            particles[i].z += particles[i].vz * dt;
            particles[i].vy -= 5.0 * dt; // Gravity
            particles[i].life -= dt;
        }
    }
}

EWZX_EXPORT void render() {
    // Trees - cylindrical billboards
    texture_bind(tree_tex);
    blend_mode(1);
    cull_mode(0);

    push_identity();
    push_translate(5.0, 2.0, -5.0);
    draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);

    push_identity();
    push_translate(-3.0, 1.5, -8.0);
    draw_billboard(1.5, 3.0, 2, 0xFFFFFFFF);

    // Particles - spherical billboards
    texture_bind(particle_tex);
    blend_mode(2); // Additive

    for (int i = 0; i &lt; 100; i++) {
        if (particles[i].life &gt; 0.0) {
            push_identity();
            push_translate(particles[i].x, particles[i].y, particles[i].z);
            uint32_t alpha = (uint32_t)(fminf(particles[i].life, 1.0) * 255.0);
            draw_billboard(particles[i].size, particles[i].size, 1, 0xFFAA00FF &amp; (0xFFFFFF00 | alpha));
        }
    }

    blend_mode(0);
    cull_mode(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var tree_tex: u32 = 0;
var particle_tex: u32 = 0;

const Particle = struct {
    x: f32 = 0.0, y: f32 = 0.0, z: f32 = 0.0,
    vx: f32 = 0.0, vy: f32 = 0.0, vz: f32 = 0.0,
    life: f32 = 0.0,
    size: f32 = 0.0,
};

var particles: [100]Particle = [_]Particle{.{}} ** 100;

export fn init() void {
    tree_tex = rom_texture("tree", 4);
    particle_tex = rom_texture("spark", 5);
}

export fn update() void {
    const dt = delta_time();
    for (&amp;particles) |*p| {
        if (p.life &gt; 0.0) {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.z += p.vz * dt;
            p.vy -= 5.0 * dt; // Gravity
            p.life -= dt;
        }
    }
}

export fn render() void {
    // Trees - cylindrical billboards
    texture_bind(tree_tex);
    blend_mode(1);
    cull_mode(0);

    push_identity();
    push_translate(5.0, 2.0, -5.0);
    draw_billboard(2.0, 4.0, 2, 0xFFFFFFFF);

    push_identity();
    push_translate(-3.0, 1.5, -8.0);
    draw_billboard(1.5, 3.0, 2, 0xFFFFFFFF);

    // Particles - spherical billboards
    texture_bind(particle_tex);
    blend_mode(2); // Additive

    for (particles) |p| {
        if (p.life &gt; 0.0) {
            push_identity();
            push_translate(p.x, p.y, p.z);
            const alpha = @as(u32, @intFromFloat(@min(p.life, 1.0) * 255.0));
            draw_billboard(p.size, p.size, 1, 0xFFAA00FF &amp; (0xFFFFFF00 | alpha));
        }
    }

    blend_mode(0);
    cull_mode(1);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#texture-functions">Textures</a>, <a href="#transform-functions">Transforms</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="sky-functions"><a class="header" href="#sky-functions">Sky Functions</a></h1>
<p>Procedural sky rendering and environment lighting.</p>
<h2 id="sky-configuration"><a class="header" href="#sky-configuration">Sky Configuration</a></h2>
<h3 id="sky_set_colors"><a class="header" href="#sky_set_colors">sky_set_colors</a></h3>
<p>Sets the sky gradient colors.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sky_set_colors(horizon_color: u32, zenith_color: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void sky_set_colors(uint32_t horizon_color, uint32_t zenith_color);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn sky_set_colors(horizon_color: u32, zenith_color: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>horizon_color</td><td><code>u32</code></td><td>Color at horizon as <code>0xRRGGBBAA</code></td></tr>
<tr><td>zenith_color</td><td><code>u32</code></td><td>Color at top of sky as <code>0xRRGGBBAA</code></td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    // Bright day sky
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
}

fn render() {
    // Dynamic time of day
    let t = (elapsed_time() * 0.1) % 1.0;
    if t &lt; 0.5 {
        // Day
        sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    } else {
        // Sunset
        sky_set_colors(0xFF804DFF, 0x4D1A80FF);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init() {
    // Bright day sky
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
}

EWZX_EXPORT void render() {
    // Dynamic time of day
    float t = fmodf(elapsed_time() * 0.1f, 1.0f);
    if (t &lt; 0.5f) {
        // Day
        sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    } else {
        // Sunset
        sky_set_colors(0xFF804DFF, 0x4D1A80FF);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    // Bright day sky
    sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
}

export fn render() void {
    // Dynamic time of day
    const t = @mod(elapsed_time() * 0.1, 1.0);
    if (t &lt; 0.5) {
        // Day
        sky_set_colors(0xB2D8F2FF, 0x3366B2FF);
    } else {
        // Sunset
        sky_set_colors(0xFF804DFF, 0x4D1A80FF);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="sky_set_sun"><a class="header" href="#sky_set_sun">sky_set_sun</a></h3>
<p>Configures the sun for sky rendering and lighting.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn sky_set_sun(dir_x: f32, dir_y: f32, dir_z: f32, color: u32, sharpness: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void sky_set_sun(float dir_x, float dir_y, float dir_z, uint32_t color, float sharpness);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn sky_set_sun(dir_x: f32, dir_y: f32, dir_z: f32, color: u32, sharpness: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>dir_x, dir_y, dir_z</td><td><code>f32</code></td><td>Sun direction (will be normalized)</td></tr>
<tr><td>color</td><td><code>u32</code></td><td>Sun color as <code>0xRRGGBBAA</code></td></tr>
<tr><td>sharpness</td><td><code>f32</code></td><td>Sun disc sharpness (0.0-1.0, higher = smaller sun)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    // Morning sun from the east
    sky_set_sun(0.8, 0.3, 0.0, 0xFFE6B3FF, 0.95);

    // Midday sun from above
    sky_set_sun(0.0, 1.0, 0.0, 0xFFF2E6FF, 0.98);

    // Evening sun from the west
    sky_set_sun(-0.8, 0.2, 0.0, 0xFF9933FF, 0.90);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init() {
    // Morning sun from the east
    sky_set_sun(0.8f, 0.3f, 0.0f, 0xFFE6B3FF, 0.95f);

    // Midday sun from above
    sky_set_sun(0.0f, 1.0f, 0.0f, 0xFFF2E6FF, 0.98f);

    // Evening sun from the west
    sky_set_sun(-0.8f, 0.2f, 0.0f, 0xFF9933FF, 0.90f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    // Morning sun from the east
    sky_set_sun(0.8, 0.3, 0.0, 0xFFE6B3FF, 0.95);

    // Midday sun from above
    sky_set_sun(0.0, 1.0, 0.0, 0xFFF2E6FF, 0.98);

    // Evening sun from the west
    sky_set_sun(-0.8, 0.2, 0.0, 0xFF9933FF, 0.90);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="draw_sky"><a class="header" href="#draw_sky">draw_sky</a></h3>
<p>Renders the procedural sky as a background.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn draw_sky()
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void draw_sky();
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn draw_sky() void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Important:</strong> Call <strong>first</strong> in your <code>render()</code> function, before any geometry.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // 1. Draw sky first (renders at far plane)
    draw_sky();

    // 2. Set up camera
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // 3. Draw scene (appears in front of sky)
    draw_mesh(terrain);
    draw_mesh(player);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // 1. Draw sky first (renders at far plane)
    draw_sky();

    // 2. Set up camera
    camera_set(0.0f, 5.0f, 10.0f, 0.0f, 0.0f, 0.0f);

    // 3. Draw scene (appears in front of sky)
    draw_mesh(terrain);
    draw_mesh(player);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // 1. Draw sky first (renders at far plane)
    draw_sky();

    // 2. Set up camera
    camera_set(0.0, 5.0, 10.0, 0.0, 0.0, 0.0);

    // 3. Draw scene (appears in front of sky)
    draw_mesh(terrain);
    draw_mesh(player);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="matcap-textures-1"><a class="header" href="#matcap-textures-1">Matcap Textures</a></h2>
<h3 id="matcap_set"><a class="header" href="#matcap_set">matcap_set</a></h3>
<p>Binds a matcap texture to a slot (Mode 1 only).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn matcap_set(slot: u32, texture: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void matcap_set(uint32_t slot, uint32_t texture);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn matcap_set(slot: u32, texture: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>slot</td><td><code>u32</code></td><td>Matcap slot (1-3)</td></tr>
<tr><td>texture</td><td><code>u32</code></td><td>Texture handle</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    render_mode(1); // Matcap mode

    // Load matcap textures
    SHADOW_MATCAP = rom_texture(b"matcap_shadow".as_ptr(), 13);
    HIGHLIGHT_MATCAP = rom_texture(b"matcap_highlight".as_ptr(), 16);
}

fn render() {
    // Bind matcaps
    matcap_set(1, SHADOW_MATCAP);
    matcap_set(2, HIGHLIGHT_MATCAP);

    // Configure blend modes
    matcap_blend_mode(1, 0); // Multiply for shadows
    matcap_blend_mode(2, 1); // Add for highlights

    // Draw
    texture_bind(character_albedo);
    draw_mesh(character);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t SHADOW_MATCAP;
static uint32_t HIGHLIGHT_MATCAP;

EWZX_EXPORT void init() {
    render_mode(1); // Matcap mode

    // Load matcap textures
    SHADOW_MATCAP = rom_texture("matcap_shadow", 13);
    HIGHLIGHT_MATCAP = rom_texture("matcap_highlight", 16);
}

EWZX_EXPORT void render() {
    // Bind matcaps
    matcap_set(1, SHADOW_MATCAP);
    matcap_set(2, HIGHLIGHT_MATCAP);

    // Configure blend modes
    matcap_blend_mode(1, 0); // Multiply for shadows
    matcap_blend_mode(2, 1); // Add for highlights

    // Draw
    texture_bind(character_albedo);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var SHADOW_MATCAP: u32 = 0;
var HIGHLIGHT_MATCAP: u32 = 0;

export fn init() void {
    render_mode(1); // Matcap mode

    // Load matcap textures
    SHADOW_MATCAP = rom_texture("matcap_shadow", 13);
    HIGHLIGHT_MATCAP = rom_texture("matcap_highlight", 16);
}

export fn render() void {
    // Bind matcaps
    matcap_set(1, SHADOW_MATCAP);
    matcap_set(2, HIGHLIGHT_MATCAP);

    // Configure blend modes
    matcap_blend_mode(1, 0); // Multiply for shadows
    matcap_blend_mode(2, 1); // Add for highlights

    // Draw
    texture_bind(character_albedo);
    draw_mesh(character);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="sky-presets"><a class="header" href="#sky-presets">Sky Presets</a></h2>
<h3 id="midday"><a class="header" href="#midday">Midday</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_midday() {
    sky_set_colors(0xB2CDE6FF, 0x4D80E6FF);  // Light blue → mid blue
    sky_set_sun(0.3, 0.8, 0.5, 0xFFF2E6FF, 0.98);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_midday() {
    sky_set_colors(0xB2CDE6FF, 0x4D80E6FF);  // Light blue → mid blue
    sky_set_sun(0.3f, 0.8f, 0.5f, 0xFFF2E6FF, 0.98f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_midday() void {
    sky_set_colors(0xB2CDE6FF, 0x4D80E6FF);  // Light blue → mid blue
    sky_set_sun(0.3, 0.8, 0.5, 0xFFF2E6FF, 0.98);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="sunset"><a class="header" href="#sunset">Sunset</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_sunset() {
    sky_set_colors(0xFF804DFF, 0x4D1A80FF);  // Orange → purple
    sky_set_sun(0.8, 0.2, 0.0, 0xFFE673FF, 0.95);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_sunset() {
    sky_set_colors(0xFF804DFF, 0x4D1A80FF);  // Orange → purple
    sky_set_sun(0.8f, 0.2f, 0.0f, 0xFFE673FF, 0.95f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_sunset() void {
    sky_set_colors(0xFF804DFF, 0x4D1A80FF);  // Orange → purple
    sky_set_sun(0.8, 0.2, 0.0, 0xFFE673FF, 0.95);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="overcast"><a class="header" href="#overcast">Overcast</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_overcast() {
    sky_set_colors(0x9999A6FF, 0x666673FF);  // Gray gradient
    sky_set_sun(0.0, 1.0, 0.0, 0x404040FF, 0.5);  // Dim, diffuse
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_overcast() {
    sky_set_colors(0x9999A6FF, 0x666673FF);  // Gray gradient
    sky_set_sun(0.0f, 1.0f, 0.0f, 0x404040FF, 0.5f);  // Dim, diffuse
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_overcast() void {
    sky_set_colors(0x9999A6FF, 0x666673FF);  // Gray gradient
    sky_set_sun(0.0, 1.0, 0.0, 0x404040FF, 0.5);  // Dim, diffuse
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="night"><a class="header" href="#night">Night</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_night() {
    sky_set_colors(0x0D0D1AFF, 0x03030DFF);  // Dark blue
    sky_set_sun(0.5, 0.3, 0.0, 0x8888AAFF, 0.85);  // Moon
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_night() {
    sky_set_colors(0x0D0D1AFF, 0x03030DFF);  // Dark blue
    sky_set_sun(0.5f, 0.3f, 0.0f, 0x8888AAFF, 0.85f);  // Moon
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_night() void {
    sky_set_colors(0x0D0D1AFF, 0x03030DFF);  // Dark blue
    sky_set_sun(0.5, 0.3, 0.0, 0x8888AAFF, 0.85);  // Moon
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="dawn"><a class="header" href="#dawn">Dawn</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn setup_dawn() {
    sky_set_colors(0xFFB380FF, 0x4D6680FF);  // Warm orange → cool blue
    sky_set_sun(0.9, 0.1, 0.3, 0xFFCC99FF, 0.92);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void setup_dawn() {
    sky_set_colors(0xFFB380FF, 0x4D6680FF);  // Warm orange → cool blue
    sky_set_sun(0.9f, 0.1f, 0.3f, 0xFFCC99FF, 0.92f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn setup_dawn() void {
    sky_set_colors(0xFFB380FF, 0x4D6680FF);  // Warm orange → cool blue
    sky_set_sun(0.9, 0.1, 0.3, 0xFFCC99FF, 0.92);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-9"><a class="header" href="#complete-example-9">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TIME_OF_DAY: f32 = 0.5; // 0.0 = midnight, 0.5 = noon, 1.0 = midnight

fn update() {
    unsafe {
        // Advance time
        TIME_OF_DAY += delta_time() * 0.01; // 100 seconds per day
        if TIME_OF_DAY &gt;= 1.0 {
            TIME_OF_DAY -= 1.0;
        }
    }
}

fn render() {
    unsafe {
        // Calculate sun position based on time
        let sun_angle = TIME_OF_DAY * 6.28318; // Full rotation
        let sun_y = sun_angle.sin();
        let sun_x = sun_angle.cos();

        // Interpolate sky colors based on time
        let (horizon, zenith, sun_color) = if TIME_OF_DAY &lt; 0.25 {
            // Night to dawn
            let t = TIME_OF_DAY / 0.25;
            (
                lerp_color(0x0D0D1AFF, 0xFFB380FF, t),
                lerp_color(0x03030DFF, 0x4D6680FF, t),
                lerp_color(0x333355FF, 0xFFCC99FF, t),
            )
        } else if TIME_OF_DAY &lt; 0.5 {
            // Dawn to noon
            let t = (TIME_OF_DAY - 0.25) / 0.25;
            (
                lerp_color(0xFFB380FF, 0xB2D8F2FF, t),
                lerp_color(0x4D6680FF, 0x3366B2FF, t),
                lerp_color(0xFFCC99FF, 0xFFF2E6FF, t),
            )
        } else if TIME_OF_DAY &lt; 0.75 {
            // Noon to dusk
            let t = (TIME_OF_DAY - 0.5) / 0.25;
            (
                lerp_color(0xB2D8F2FF, 0xFF804DFF, t),
                lerp_color(0x3366B2FF, 0x4D1A80FF, t),
                lerp_color(0xFFF2E6FF, 0xFFE673FF, t),
            )
        } else {
            // Dusk to night
            let t = (TIME_OF_DAY - 0.75) / 0.25;
            (
                lerp_color(0xFF804DFF, 0x0D0D1AFF, t),
                lerp_color(0x4D1A80FF, 0x03030DFF, t),
                lerp_color(0xFFE673FF, 0x333355FF, t),
            )
        };

        sky_set_colors(horizon, zenith);
        sky_set_sun(sun_x, sun_y.max(0.1), 0.3, sun_color, 0.95);

        // Draw sky first
        draw_sky();

        // Set up camera and draw scene
        camera_set(0.0, 5.0, 15.0, 0.0, 0.0, 0.0);
        draw_mesh(terrain);
        draw_mesh(buildings);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float TIME_OF_DAY = 0.5f; // 0.0 = midnight, 0.5 = noon, 1.0 = midnight

EWZX_EXPORT void update() {
    // Advance time
    TIME_OF_DAY += delta_time() * 0.01f; // 100 seconds per day
    if (TIME_OF_DAY &gt;= 1.0f) {
        TIME_OF_DAY -= 1.0f;
    }
}

EWZX_EXPORT void render() {
    // Calculate sun position based on time
    float sun_angle = TIME_OF_DAY * 6.28318f; // Full rotation
    float sun_y = sinf(sun_angle);
    float sun_x = cosf(sun_angle);

    // Interpolate sky colors based on time
    uint32_t horizon, zenith, sun_color;
    if (TIME_OF_DAY &lt; 0.25f) {
        // Night to dawn
        float t = TIME_OF_DAY / 0.25f;
        horizon = lerp_color(0x0D0D1AFF, 0xFFB380FF, t);
        zenith = lerp_color(0x03030DFF, 0x4D6680FF, t);
        sun_color = lerp_color(0x333355FF, 0xFFCC99FF, t);
    } else if (TIME_OF_DAY &lt; 0.5f) {
        // Dawn to noon
        float t = (TIME_OF_DAY - 0.25f) / 0.25f;
        horizon = lerp_color(0xFFB380FF, 0xB2D8F2FF, t);
        zenith = lerp_color(0x4D6680FF, 0x3366B2FF, t);
        sun_color = lerp_color(0xFFCC99FF, 0xFFF2E6FF, t);
    } else if (TIME_OF_DAY &lt; 0.75f) {
        // Noon to dusk
        float t = (TIME_OF_DAY - 0.5f) / 0.25f;
        horizon = lerp_color(0xB2D8F2FF, 0xFF804DFF, t);
        zenith = lerp_color(0x3366B2FF, 0x4D1A80FF, t);
        sun_color = lerp_color(0xFFF2E6FF, 0xFFE673FF, t);
    } else {
        // Dusk to night
        float t = (TIME_OF_DAY - 0.75f) / 0.25f;
        horizon = lerp_color(0xFF804DFF, 0x0D0D1AFF, t);
        zenith = lerp_color(0x4D1A80FF, 0x03030DFF, t);
        sun_color = lerp_color(0xFFE673FF, 0x333355FF, t);
    }

    sky_set_colors(horizon, zenith);
    sky_set_sun(sun_x, fmaxf(sun_y, 0.1f), 0.3f, sun_color, 0.95f);

    // Draw sky first
    draw_sky();

    // Set up camera and draw scene
    camera_set(0.0f, 5.0f, 15.0f, 0.0f, 0.0f, 0.0f);
    draw_mesh(terrain);
    draw_mesh(buildings);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var TIME_OF_DAY: f32 = 0.5; // 0.0 = midnight, 0.5 = noon, 1.0 = midnight

export fn update() void {
    // Advance time
    TIME_OF_DAY += delta_time() * 0.01; // 100 seconds per day
    if (TIME_OF_DAY &gt;= 1.0) {
        TIME_OF_DAY -= 1.0;
    }
}

export fn render() void {
    // Calculate sun position based on time
    const sun_angle = TIME_OF_DAY * 6.28318; // Full rotation
    const sun_y = @sin(sun_angle);
    const sun_x = @cos(sun_angle);

    // Interpolate sky colors based on time
    const horizon: u32 = blk: {
        const zenith: u32 = blk2: {
            const sun_color: u32 = blk3: {
                if (TIME_OF_DAY &lt; 0.25) {
                    // Night to dawn
                    const t = TIME_OF_DAY / 0.25;
                    break :blk lerp_color(0x0D0D1AFF, 0xFFB380FF, t);
                    break :blk2 lerp_color(0x03030DFF, 0x4D6680FF, t);
                    break :blk3 lerp_color(0x333355FF, 0xFFCC99FF, t);
                } else if (TIME_OF_DAY &lt; 0.5) {
                    // Dawn to noon
                    const t = (TIME_OF_DAY - 0.25) / 0.25;
                    break :blk lerp_color(0xFFB380FF, 0xB2D8F2FF, t);
                    break :blk2 lerp_color(0x4D6680FF, 0x3366B2FF, t);
                    break :blk3 lerp_color(0xFFCC99FF, 0xFFF2E6FF, t);
                } else if (TIME_OF_DAY &lt; 0.75) {
                    // Noon to dusk
                    const t = (TIME_OF_DAY - 0.5) / 0.25;
                    break :blk lerp_color(0xB2D8F2FF, 0xFF804DFF, t);
                    break :blk2 lerp_color(0x3366B2FF, 0x4D1A80FF, t);
                    break :blk3 lerp_color(0xFFF2E6FF, 0xFFE673FF, t);
                } else {
                    // Dusk to night
                    const t = (TIME_OF_DAY - 0.75) / 0.25;
                    break :blk lerp_color(0xFF804DFF, 0x0D0D1AFF, t);
                    break :blk2 lerp_color(0x4D1A80FF, 0x03030DFF, t);
                    break :blk3 lerp_color(0xFFE673FF, 0x333355FF, t);
                }
            };
            break :blk2 zenith;
        };
        break :blk horizon;
    };

    sky_set_colors(horizon, zenith);
    sky_set_sun(sun_x, @max(sun_y, 0.1), 0.3, sun_color, 0.95);

    // Draw sky first
    draw_sky();

    // Set up camera and draw scene
    camera_set(0.0, 5.0, 15.0, 0.0, 0.0, 0.0);
    draw_mesh(terrain);
    draw_mesh(buildings);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#lighting-functions">Lighting</a>, <a href="#material-functions">Materials</a>, <a href="#render-modes-guide">Render Modes Guide</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="audio-functions"><a class="header" href="#audio-functions">Audio Functions</a></h1>
<p>Sound effects and music playback with 16 channels.</p>
<h2 id="loading-sounds"><a class="header" href="#loading-sounds">Loading Sounds</a></h2>
<h3 id="load_sound"><a class="header" href="#load_sound">load_sound</a></h3>
<p>Loads a sound from WASM memory.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_sound(data_ptr: *const u8, byte_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load_sound(const uint8_t* data_ptr, uint32_t byte_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load_sound(data_ptr: [*]const u8, byte_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to PCM audio data</td></tr>
<tr><td>byte_len</td><td><code>u32</code></td><td>Size of data in bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Sound handle (non-zero on success)</p>
<p><strong>Audio Format:</strong> 22.05 kHz, 16-bit signed, mono PCM</p>
<p><strong>Constraints:</strong> Init-only.</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static JUMP_DATA: &amp;[u8] = include_bytes!("jump.raw");
static mut JUMP_SFX: u32 = 0;

fn init() {
    unsafe {
        JUMP_SFX = load_sound(JUMP_DATA.as_ptr(), JUMP_DATA.len() as u32);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static const uint8_t jump_data[] = {
    #include "jump.raw.h"
};
static uint32_t jump_sfx = 0;

EWZX_EXPORT void init() {
    jump_sfx = load_sound(jump_data, sizeof(jump_data));
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const jump_data = @embedFile("jump.raw");
var jump_sfx: u32 = 0;

export fn init() void {
    jump_sfx = load_sound(jump_data.ptr, jump_data.len);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Note:</strong> Prefer <code>rom_sound()</code> for sounds bundled in the ROM data pack.</p>
<hr>
<h2 id="sound-effects"><a class="header" href="#sound-effects">Sound Effects</a></h2>
<h3 id="play_sound"><a class="header" href="#play_sound">play_sound</a></h3>
<p>Plays a sound on the next available channel.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn play_sound(sound: u32, volume: f32, pan: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void play_sound(uint32_t sound, float volume, float pan);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn play_sound(sound: u32, volume: f32, pan: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>sound</td><td><code>u32</code></td><td>Sound handle</td></tr>
<tr><td>volume</td><td><code>f32</code></td><td>Volume (0.0-1.0)</td></tr>
<tr><td>pan</td><td><code>f32</code></td><td>Stereo pan (-1.0 = left, 0.0 = center, 1.0 = right)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    if button_pressed(0, BUTTON_A) != 0 {
        play_sound(JUMP_SFX, 1.0, 0.0);
    }

    // Positional audio
    let dx = enemy.x - player.x;
    let pan = (dx / 20.0).clamp(-1.0, 1.0);
    let dist = ((enemy.x - player.x).powi(2) + (enemy.z - player.z).powi(2)).sqrt();
    let vol = (1.0 - dist / 50.0).max(0.0);
    play_sound(ENEMY_GROWL, vol, pan);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update() {
    if (button_pressed(0, BUTTON_A) != 0) {
        play_sound(JUMP_SFX, 1.0f, 0.0f);
    }

    // Positional audio
    float dx = enemy.x - player.x;
    float pan = fmaxf(-1.0f, fminf(1.0f, dx / 20.0f));
    float ex = enemy.x - player.x;
    float ez = enemy.z - player.z;
    float dist = sqrtf(ex * ex + ez * ez);
    float vol = fmaxf(0.0f, 1.0f - dist / 50.0f);
    play_sound(ENEMY_GROWL, vol, pan);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    if (button_pressed(0, BUTTON_A) != 0) {
        play_sound(JUMP_SFX, 1.0, 0.0);
    }

    // Positional audio
    const dx = enemy.x - player.x;
    const pan = @max(-1.0, @min(1.0, dx / 20.0));
    const ex = enemy.x - player.x;
    const ez = enemy.z - player.z;
    const dist = @sqrt(ex * ex + ez * ez);
    const vol = @max(0.0, 1.0 - dist / 50.0);
    play_sound(ENEMY_GROWL, vol, pan);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="channel_play"><a class="header" href="#channel_play">channel_play</a></h3>
<p>Plays a sound on a specific channel with loop control.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn channel_play(channel: u32, sound: u32, volume: f32, pan: f32, looping: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void channel_play(uint32_t channel, uint32_t sound, float volume, float pan, uint32_t looping);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn channel_play(channel: u32, sound: u32, volume: f32, pan: f32, looping: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>channel</td><td><code>u32</code></td><td>Channel index (0-15)</td></tr>
<tr><td>sound</td><td><code>u32</code></td><td>Sound handle</td></tr>
<tr><td>volume</td><td><code>f32</code></td><td>Volume (0.0-1.0)</td></tr>
<tr><td>pan</td><td><code>f32</code></td><td>Stereo pan (-1.0 to 1.0)</td></tr>
<tr><td>looping</td><td><code>u32</code></td><td>1 to loop, 0 for one-shot</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Engine sound on dedicated channel (looping)
    if vehicle.engine_on &amp;&amp; !ENGINE_PLAYING {
        channel_play(0, ENGINE_SFX, 0.8, 0.0, 1);
        ENGINE_PLAYING = true;
    }

    // Adjust engine pitch based on speed
    if ENGINE_PLAYING {
        let vol = 0.5 + vehicle.speed * 0.005;
        channel_set(0, vol.min(1.0), 0.0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update() {
    // Engine sound on dedicated channel (looping)
    if (vehicle.engine_on &amp;&amp; !ENGINE_PLAYING) {
        channel_play(0, ENGINE_SFX, 0.8f, 0.0f, 1);
        ENGINE_PLAYING = true;
    }

    // Adjust engine pitch based on speed
    if (ENGINE_PLAYING) {
        float vol = 0.5f + vehicle.speed * 0.005f;
        channel_set(0, fminf(vol, 1.0f), 0.0f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Engine sound on dedicated channel (looping)
    if (vehicle.engine_on and !ENGINE_PLAYING) {
        channel_play(0, ENGINE_SFX, 0.8, 0.0, 1);
        ENGINE_PLAYING = true;
    }

    // Adjust engine pitch based on speed
    if (ENGINE_PLAYING) {
        const vol = 0.5 + vehicle.speed * 0.005;
        channel_set(0, @min(vol, 1.0), 0.0);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="channel_set"><a class="header" href="#channel_set">channel_set</a></h3>
<p>Updates volume and pan for a playing channel.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn channel_set(channel: u32, volume: f32, pan: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void channel_set(uint32_t channel, float volume, float pan);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn channel_set(channel: u32, volume: f32, pan: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>channel</td><td><code>u32</code></td><td>Channel index (0-15)</td></tr>
<tr><td>volume</td><td><code>f32</code></td><td>New volume (0.0-1.0)</td></tr>
<tr><td>pan</td><td><code>f32</code></td><td>New stereo pan</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    // Fade out channel 0
    if fading {
        fade_vol -= delta_time() * 0.5;
        if fade_vol &lt;= 0.0 {
            channel_stop(0);
            fading = false;
        } else {
            channel_set(0, fade_vol, 0.0);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update() {
    // Fade out channel 0
    if (fading) {
        fade_vol -= delta_time() * 0.5f;
        if (fade_vol &lt;= 0.0f) {
            channel_stop(0);
            fading = false;
        } else {
            channel_set(0, fade_vol, 0.0f);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    // Fade out channel 0
    if (fading) {
        fade_vol -= delta_time() * 0.5;
        if (fade_vol &lt;= 0.0) {
            channel_stop(0);
            fading = false;
        } else {
            channel_set(0, fade_vol, 0.0);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="channel_stop"><a class="header" href="#channel_stop">channel_stop</a></h3>
<p>Stops playback on a channel.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn channel_stop(channel: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void channel_stop(uint32_t channel);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn channel_stop(channel: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>channel</td><td><code>u32</code></td><td>Channel index (0-15)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    if vehicle.engine_off {
        channel_stop(0);
        ENGINE_PLAYING = false;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update() {
    if (vehicle.engine_off) {
        channel_stop(0);
        ENGINE_PLAYING = false;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    if (vehicle.engine_off) {
        channel_stop(0);
        ENGINE_PLAYING = false;
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="music"><a class="header" href="#music">Music</a></h2>
<p>Music uses a dedicated stereo channel, separate from the 16 SFX channels.</p>
<h3 id="music_play"><a class="header" href="#music_play">music_play</a></h3>
<p>Plays background music (looping).</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn music_play(sound: u32, volume: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void music_play(uint32_t sound, float volume);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn music_play(sound: u32, volume: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>sound</td><td><code>u32</code></td><td>Sound handle</td></tr>
<tr><td>volume</td><td><code>f32</code></td><td>Volume (0.0-1.0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        MENU_MUSIC = rom_sound(b"menu_bgm".as_ptr(), 8);
        GAME_MUSIC = rom_sound(b"game_bgm".as_ptr(), 8);
    }
}

fn start_game() {
    music_play(GAME_MUSIC, 0.7);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init() {
    MENU_MUSIC = rom_sound("menu_bgm", 8);
    GAME_MUSIC = rom_sound("game_bgm", 8);
}

void start_game() {
    music_play(GAME_MUSIC, 0.7f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    MENU_MUSIC = rom_sound("menu_bgm".ptr, 8);
    GAME_MUSIC = rom_sound("game_bgm".ptr, 8);
}

fn start_game() void {
    music_play(GAME_MUSIC, 0.7);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="music_stop"><a class="header" href="#music_stop">music_stop</a></h3>
<p>Stops the currently playing music.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn music_stop()
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void music_stop();
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn music_stop() void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn game_over() {
    music_stop();
    play_sound(GAME_OVER_SFX, 1.0, 0.0);
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void game_over() {
    music_stop();
    play_sound(GAME_OVER_SFX, 1.0f, 0.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn game_over() void {
    music_stop();
    play_sound(GAME_OVER_SFX, 1.0, 0.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="music_set_volume"><a class="header" href="#music_set_volume">music_set_volume</a></h3>
<p>Changes the music volume.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn music_set_volume(volume: f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void music_set_volume(float volume);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn music_set_volume(volume: f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>volume</td><td><code>f32</code></td><td>New volume (0.0-1.0)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render() {
    // Duck music during dialogue
    if dialogue_active {
        music_set_volume(0.3);
    } else {
        music_set_volume(0.7);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void render() {
    // Duck music during dialogue
    if (dialogue_active) {
        music_set_volume(0.3f);
    } else {
        music_set_volume(0.7f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn render() void {
    // Duck music during dialogue
    if (dialogue_active) {
        music_set_volume(0.3);
    } else {
        music_set_volume(0.7);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="audio-architecture"><a class="header" href="#audio-architecture">Audio Architecture</a></h2>
<ul>
<li><strong>16 SFX channels</strong> (0-15) for sound effects</li>
<li><strong>1 Music channel</strong> (separate) for background music</li>
<li><strong>22.05 kHz</strong> sample rate, 16-bit mono PCM</li>
<li><strong>Rollback-safe</strong>: Audio state is part of rollback snapshots</li>
<li>Per-frame audio generation with ring buffer</li>
</ul>
<hr>
<h2 id="complete-example-10"><a class="header" href="#complete-example-10">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut JUMP_SFX: u32 = 0;
static mut LAND_SFX: u32 = 0;
static mut COIN_SFX: u32 = 0;
static mut MUSIC: u32 = 0;
static mut AMBIENT: u32 = 0;

fn init() {
    unsafe {
        // Load sounds from ROM
        JUMP_SFX = rom_sound(b"jump".as_ptr(), 4);
        LAND_SFX = rom_sound(b"land".as_ptr(), 4);
        COIN_SFX = rom_sound(b"coin".as_ptr(), 4);
        MUSIC = rom_sound(b"level1".as_ptr(), 6);
        AMBIENT = rom_sound(b"wind".as_ptr(), 4);

        // Start music and ambient
        music_play(MUSIC, 0.6);
        channel_play(15, AMBIENT, 0.3, 0.0, 1); // Looping ambient
    }
}

fn update() {
    unsafe {
        // Jump sound
        if button_pressed(0, BUTTON_A) != 0 &amp;&amp; player.on_ground {
            play_sound(JUMP_SFX, 0.8, 0.0);
        }

        // Land sound
        if player.just_landed {
            play_sound(LAND_SFX, 0.6, 0.0);
        }

        // Coin pickup with positional audio
        for coin in &amp;coins {
            if coin.just_collected {
                let dx = coin.x - player.x;
                let pan = (dx / 10.0).clamp(-1.0, 1.0);
                play_sound(COIN_SFX, 1.0, pan);
            }
        }

        // Pause menu - duck audio
        if game_paused {
            music_set_volume(0.2);
            channel_set(15, 0.1, 0.0);
        } else {
            music_set_volume(0.6);
            channel_set(15, 0.3, 0.0);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t JUMP_SFX = 0;
static uint32_t LAND_SFX = 0;
static uint32_t COIN_SFX = 0;
static uint32_t MUSIC = 0;
static uint32_t AMBIENT = 0;

EWZX_EXPORT void init() {
    // Load sounds from ROM
    JUMP_SFX = rom_sound("jump", 4);
    LAND_SFX = rom_sound("land", 4);
    COIN_SFX = rom_sound("coin", 4);
    MUSIC = rom_sound("level1", 6);
    AMBIENT = rom_sound("wind", 4);

    // Start music and ambient
    music_play(MUSIC, 0.6f);
    channel_play(15, AMBIENT, 0.3f, 0.0f, 1); // Looping ambient
}

EWZX_EXPORT void update() {
    // Jump sound
    if (button_pressed(0, BUTTON_A) != 0 &amp;&amp; player.on_ground) {
        play_sound(JUMP_SFX, 0.8f, 0.0f);
    }

    // Land sound
    if (player.just_landed) {
        play_sound(LAND_SFX, 0.6f, 0.0f);
    }

    // Coin pickup with positional audio
    for (int i = 0; i &lt; coin_count; i++) {
        if (coins[i].just_collected) {
            float dx = coins[i].x - player.x;
            float pan = fmaxf(-1.0f, fminf(1.0f, dx / 10.0f));
            play_sound(COIN_SFX, 1.0f, pan);
        }
    }

    // Pause menu - duck audio
    if (game_paused) {
        music_set_volume(0.2f);
        channel_set(15, 0.1f, 0.0f);
    } else {
        music_set_volume(0.6f);
        channel_set(15, 0.3f, 0.0f);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var JUMP_SFX: u32 = 0;
var LAND_SFX: u32 = 0;
var COIN_SFX: u32 = 0;
var MUSIC: u32 = 0;
var AMBIENT: u32 = 0;

export fn init() void {
    // Load sounds from ROM
    JUMP_SFX = rom_sound("jump".ptr, 4);
    LAND_SFX = rom_sound("land".ptr, 4);
    COIN_SFX = rom_sound("coin".ptr, 4);
    MUSIC = rom_sound("level1".ptr, 6);
    AMBIENT = rom_sound("wind".ptr, 4);

    // Start music and ambient
    music_play(MUSIC, 0.6);
    channel_play(15, AMBIENT, 0.3, 0.0, 1); // Looping ambient
}

export fn update() void {
    // Jump sound
    if (button_pressed(0, BUTTON_A) != 0 and player.on_ground) {
        play_sound(JUMP_SFX, 0.8, 0.0);
    }

    // Land sound
    if (player.just_landed) {
        play_sound(LAND_SFX, 0.6, 0.0);
    }

    // Coin pickup with positional audio
    for (coins) |coin| {
        if (coin.just_collected) {
            const dx = coin.x - player.x;
            const pan = @max(-1.0, @min(1.0, dx / 10.0));
            play_sound(COIN_SFX, 1.0, pan);
        }
    }

    // Pause menu - duck audio
    if (game_paused) {
        music_set_volume(0.2);
        channel_set(15, 0.1, 0.0);
    } else {
        music_set_volume(0.6);
        channel_set(15, 0.3, 0.0);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#rom_sound">rom_sound</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="save-data-functions"><a class="header" href="#save-data-functions">Save Data Functions</a></h1>
<p>Persistent storage for game saves (8 slots, 64KB each).</p>
<h2 id="overview-2"><a class="header" href="#overview-2">Overview</a></h2>
<ul>
<li><strong>8 save slots</strong> (indices 0-7)</li>
<li><strong>64KB maximum</strong> per slot</li>
<li>Data persists across sessions</li>
<li>Stored locally per-game</li>
</ul>
<hr>
<h2 id="functions-1"><a class="header" href="#functions-1">Functions</a></h2>
<h3 id="save"><a class="header" href="#save">save</a></h3>
<p>Saves data to a slot.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save(slot: u32, data_ptr: *const u8, data_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t save(uint32_t slot, const uint8_t* data_ptr, uint32_t data_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn save(slot: u32, data_ptr: [*]const u8, data_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>slot</td><td><code>u32</code></td><td>Save slot (0-7)</td></tr>
<tr><td>data_ptr</td><td><code>*const u8</code></td><td>Pointer to data to save</td></tr>
<tr><td>data_len</td><td><code>u32</code></td><td>Size of data in bytes</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Success</td></tr>
<tr><td>1</td><td>Invalid slot</td></tr>
<tr><td>2</td><td>Data too large (&gt;64KB)</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn save_game() {
    unsafe {
        let save_data = SaveData {
            level: CURRENT_LEVEL,
            score: SCORE,
            health: PLAYER_HEALTH,
            position_x: PLAYER_X,
            position_y: PLAYER_Y,
            checksum: 0,
        };

        // Calculate checksum
        let bytes = &amp;save_data as *const SaveData as *const u8;
        let size = core::mem::size_of::&lt;SaveData&gt;();

        let result = save(0, bytes, size as u32);
        if result == 0 {
            show_message(b"Game Saved!");
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void save_game() {
    SaveData save_data = {
        .level = CURRENT_LEVEL,
        .score = SCORE,
        .health = PLAYER_HEALTH,
        .position_x = PLAYER_X,
        .position_y = PLAYER_Y,
        .checksum = 0
    };

    // Calculate checksum
    const uint8_t* bytes = (const uint8_t*)&amp;save_data;
    uint32_t size = sizeof(SaveData);

    uint32_t result = save(0, bytes, size);
    if (result == 0) {
        show_message((const uint8_t*)"Game Saved!", 11);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn save_game() void {
    var save_data = SaveData{
        .level = CURRENT_LEVEL,
        .score = SCORE,
        .health = PLAYER_HEALTH,
        .position_x = PLAYER_X,
        .position_y = PLAYER_Y,
        .checksum = 0,
    };

    // Calculate checksum
    const bytes: [*]const u8 = @ptrCast(&amp;save_data);
    const size = @sizeOf(SaveData);

    const result = save(0, bytes, size);
    if (result == 0) {
        show_message("Game Saved!".ptr, 11);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="load"><a class="header" href="#load">load</a></h3>
<p>Loads data from a slot.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load(slot: u32, data_ptr: *mut u8, max_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t load(uint32_t slot, uint8_t* data_ptr, uint32_t max_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn load(slot: u32, data_ptr: [*]u8, max_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>slot</td><td><code>u32</code></td><td>Save slot (0-7)</td></tr>
<tr><td>data_ptr</td><td><code>*mut u8</code></td><td>Destination buffer</td></tr>
<tr><td>max_len</td><td><code>u32</code></td><td>Maximum bytes to read</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Number of bytes read (0 if empty or error)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn load_game() -&gt; bool {
    unsafe {
        let mut save_data = SaveData::default();
        let bytes = &amp;mut save_data as *mut SaveData as *mut u8;
        let size = core::mem::size_of::&lt;SaveData&gt;();

        let read = load(0, bytes, size as u32);
        if read == size as u32 {
            // Validate checksum
            if validate_checksum(&amp;save_data) {
                CURRENT_LEVEL = save_data.level;
                SCORE = save_data.score;
                PLAYER_HEALTH = save_data.health;
                PLAYER_X = save_data.position_x;
                PLAYER_Y = save_data.position_y;
                return true;
            }
        }
        false
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">bool load_game() {
    SaveData save_data = {0};
    uint8_t* bytes = (uint8_t*)&amp;save_data;
    uint32_t size = sizeof(SaveData);

    uint32_t read = load(0, bytes, size);
    if (read == size) {
        // Validate checksum
        if (validate_checksum(&amp;save_data)) {
            CURRENT_LEVEL = save_data.level;
            SCORE = save_data.score;
            PLAYER_HEALTH = save_data.health;
            PLAYER_X = save_data.position_x;
            PLAYER_Y = save_data.position_y;
            return true;
        }
    }
    return false;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn load_game() bool {
    var save_data: SaveData = std.mem.zeroes(SaveData);
    const bytes: [*]u8 = @ptrCast(&amp;save_data);
    const size = @sizeOf(SaveData);

    const read = load(0, bytes, size);
    if (read == size) {
        // Validate checksum
        if (validate_checksum(&amp;save_data)) {
            CURRENT_LEVEL = save_data.level;
            SCORE = save_data.score;
            PLAYER_HEALTH = save_data.health;
            PLAYER_X = save_data.position_x;
            PLAYER_Y = save_data.position_y;
            return true;
        }
    }
    return false;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="delete"><a class="header" href="#delete">delete</a></h3>
<p>Deletes data in a save slot.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete(slot: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t delete_save(uint32_t slot);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn delete_save(slot: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>slot</td><td><code>u32</code></td><td>Save slot (0-7)</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Value</th><th>Meaning</th></tr>
</thead>
<tbody>
<tr><td>0</td><td>Success</td></tr>
<tr><td>1</td><td>Invalid slot</td></tr>
</tbody>
</table>
</div>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn delete_save(slot: u32) {
    unsafe {
        if delete(slot) == 0 {
            show_message(b"Save deleted");
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void delete_saved_game(uint32_t slot) {
    if (delete_save(slot) == 0) {
        show_message((const uint8_t*)"Save deleted", 12);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn delete_saved_game(slot: u32) void {
    if (delete_save(slot) == 0) {
        show_message("Save deleted".ptr, 12);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="save-data-patterns"><a class="header" href="#save-data-patterns">Save Data Patterns</a></h2>
<h3 id="simple-struct-save"><a class="header" href="#simple-struct-save">Simple Struct Save</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct SaveData {
    magic: u32,           // Identify valid saves
    version: u32,         // Save format version
    level: u32,
    score: u32,
    health: f32,
    position: [f32; 3],
    inventory: [u8; 64],
    checksum: u32,
}

impl SaveData {
    const MAGIC: u32 = 0x53415645; // "SAVE"

    fn new() -&gt; Self {
        Self {
            magic: Self::MAGIC,
            version: 1,
            level: 0,
            score: 0,
            health: 100.0,
            position: [0.0; 3],
            inventory: [0; 64],
            checksum: 0,
        }
    }

    fn calculate_checksum(&amp;self) -&gt; u32 {
        // Simple checksum (XOR all bytes except checksum field)
        let bytes = self as *const Self as *const u8;
        let len = core::mem::size_of::&lt;Self&gt;() - 4; // Exclude checksum
        let mut sum: u32 = 0;
        for i in 0..len {
            unsafe { sum ^= (*bytes.add(i) as u32) &lt;&lt; ((i % 4) * 8); }
        }
        sum
    }

    fn is_valid(&amp;self) -&gt; bool {
        self.magic == Self::MAGIC &amp;&amp; self.checksum == self.calculate_checksum()
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">typedef struct {
    uint32_t magic;           // Identify valid saves
    uint32_t version;         // Save format version
    uint32_t level;
    uint32_t score;
    float health;
    float position[3];
    uint8_t inventory[64];
    uint32_t checksum;
} SaveData;

#define SAVE_MAGIC 0x53415645  // "SAVE"

SaveData SaveData_new() {
    SaveData data = {0};
    data.magic = SAVE_MAGIC;
    data.version = 1;
    data.health = 100.0f;
    return data;
}

uint32_t SaveData_calculate_checksum(const SaveData* self) {
    // Simple checksum (XOR all bytes except checksum field)
    const uint8_t* bytes = (const uint8_t*)self;
    uint32_t len = sizeof(SaveData) - 4; // Exclude checksum
    uint32_t sum = 0;
    for (uint32_t i = 0; i &lt; len; i++) {
        sum ^= (bytes[i] &lt;&lt; ((i % 4) * 8));
    }
    return sum;
}

bool SaveData_is_valid(const SaveData* self) {
    return self-&gt;magic == SAVE_MAGIC &amp;&amp;
           self-&gt;checksum == SaveData_calculate_checksum(self);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const SaveData = extern struct {
    magic: u32,           // Identify valid saves
    version: u32,         // Save format version
    level: u32,
    score: u32,
    health: f32,
    position: [3]f32,
    inventory: [64]u8,
    checksum: u32,

    const MAGIC: u32 = 0x53415645; // "SAVE"

    fn new() SaveData {
        return SaveData{
            .magic = MAGIC,
            .version = 1,
            .level = 0,
            .score = 0,
            .health = 100.0,
            .position = [_]f32{0.0} ** 3,
            .inventory = [_]u8{0} ** 64,
            .checksum = 0,
        };
    }

    fn calculate_checksum(self: *const SaveData) u32 {
        // Simple checksum (XOR all bytes except checksum field)
        const bytes: [*]const u8 = @ptrCast(self);
        const len = @sizeOf(SaveData) - 4; // Exclude checksum
        var sum: u32 = 0;
        for (0..len) |i| {
            sum ^= @as(u32, bytes[i]) &lt;&lt; @intCast((i % 4) * 8);
        }
        return sum;
    }

    fn is_valid(self: *const SaveData) bool {
        return self.magic == MAGIC and
               self.checksum == self.calculate_checksum();
    }
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="multiple-save-slots-ui"><a class="header" href="#multiple-save-slots-ui">Multiple Save Slots UI</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn render_save_menu() {
    unsafe {
        draw_text(b"SAVE SLOTS".as_ptr(), 10, 200.0, 50.0, 24.0, 0xFFFFFFFF);

        for slot in 0..8 {
            let mut buffer = [0u8; 128];
            let read = load(slot, buffer.as_mut_ptr(), 128);

            let y = 100.0 + (slot as f32) * 40.0;

            if read &gt; 0 {
                // Parse save info
                let save = &amp;*(buffer.as_ptr() as *const SaveData);
                if save.is_valid() {
                    // Show save info
                    let text = format_save_info(slot, save.level, save.score);
                    draw_text(text.as_ptr(), text.len() as u32, 100.0, y, 16.0, 0xFFFFFFFF);
                } else {
                    draw_text(b"[Corrupted]".as_ptr(), 11, 100.0, y, 16.0, 0xFF4444FF);
                }
            } else {
                draw_text(b"[Empty]".as_ptr(), 7, 100.0, y, 16.0, 0x888888FF);
            }

            // Highlight selected slot
            if slot == SELECTED_SLOT {
                draw_rect(90.0, y - 5.0, 300.0, 30.0, 0xFFFFFF33);
            }
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">void render_save_menu() {
    draw_text((const uint8_t*)"SAVE SLOTS", 10, 200.0f, 50.0f, 24.0f, 0xFFFFFFFF);

    for (uint32_t slot = 0; slot &lt; 8; slot++) {
        uint8_t buffer[128] = {0};
        uint32_t read = load(slot, buffer, 128);

        float y = 100.0f + (slot * 40.0f);

        if (read &gt; 0) {
            // Parse save info
            const SaveData* save = (const SaveData*)buffer;
            if (SaveData_is_valid(save)) {
                // Show save info
                char text[64];
                format_save_info(text, slot, save-&gt;level, save-&gt;score);
                draw_text((const uint8_t*)text, strlen(text), 100.0f, y, 16.0f, 0xFFFFFFFF);
            } else {
                draw_text((const uint8_t*)"[Corrupted]", 11, 100.0f, y, 16.0f, 0xFF4444FF);
            }
        } else {
            draw_text((const uint8_t*)"[Empty]", 7, 100.0f, y, 16.0f, 0x888888FF);
        }

        // Highlight selected slot
        if (slot == SELECTED_SLOT) {
            draw_rect(90.0f, y - 5.0f, 300.0f, 30.0f, 0xFFFFFF33);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">fn render_save_menu() void {
    draw_text("SAVE SLOTS".ptr, 10, 200.0, 50.0, 24.0, 0xFFFFFFFF);

    for (0..8) |slot| {
        var buffer: [128]u8 = undefined;
        const read = load(@intCast(slot), &amp;buffer, 128);

        const y = 100.0 + (@as(f32, @floatFromInt(slot)) * 40.0);

        if (read &gt; 0) {
            // Parse save info
            const save: *const SaveData = @ptrCast(@alignCast(&amp;buffer));
            if (save.is_valid()) {
                // Show save info
                const text = format_save_info(slot, save.level, save.score);
                draw_text(text.ptr, @intCast(text.len), 100.0, y, 16.0, 0xFFFFFFFF);
            } else {
                draw_text("[Corrupted]".ptr, 11, 100.0, y, 16.0, 0xFF4444FF);
            }
        } else {
            draw_text("[Empty]".ptr, 7, 100.0, y, 16.0, 0x888888FF);
        }

        // Highlight selected slot
        if (slot == SELECTED_SLOT) {
            draw_rect(90.0, y - 5.0, 300.0, 30.0, 0xFFFFFF33);
        }
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="auto-save"><a class="header" href="#auto-save">Auto-Save</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut LAST_SAVE_TIME: f32 = 0.0;
const AUTO_SAVE_INTERVAL: f32 = 60.0; // Every 60 seconds

fn update() {
    unsafe {
        // Auto-save every 60 seconds
        if elapsed_time() - LAST_SAVE_TIME &gt; AUTO_SAVE_INTERVAL {
            auto_save();
            LAST_SAVE_TIME = elapsed_time();
        }
    }
}

fn auto_save() {
    unsafe {
        // Use slot 7 for auto-save
        let mut save = create_save_data();
        save.checksum = save.calculate_checksum();

        let bytes = &amp;save as *const SaveData as *const u8;
        let size = core::mem::size_of::&lt;SaveData&gt;();
        save(7, bytes, size as u32);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float LAST_SAVE_TIME = 0.0f;
const float AUTO_SAVE_INTERVAL = 60.0f; // Every 60 seconds

EWZX_EXPORT void update() {
    // Auto-save every 60 seconds
    if (elapsed_time() - LAST_SAVE_TIME &gt; AUTO_SAVE_INTERVAL) {
        auto_save();
        LAST_SAVE_TIME = elapsed_time();
    }
}

void auto_save() {
    // Use slot 7 for auto-save
    SaveData save_data = create_save_data();
    save_data.checksum = SaveData_calculate_checksum(&amp;save_data);

    const uint8_t* bytes = (const uint8_t*)&amp;save_data;
    uint32_t size = sizeof(SaveData);
    save(7, bytes, size);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var LAST_SAVE_TIME: f32 = 0.0;
const AUTO_SAVE_INTERVAL: f32 = 60.0; // Every 60 seconds

export fn update() void {
    // Auto-save every 60 seconds
    if (elapsed_time() - LAST_SAVE_TIME &gt; AUTO_SAVE_INTERVAL) {
        auto_save();
        LAST_SAVE_TIME = elapsed_time();
    }
}

fn auto_save() void {
    // Use slot 7 for auto-save
    var save_data = create_save_data();
    save_data.checksum = save_data.calculate_checksum();

    const bytes: [*]const u8 = @ptrCast(&amp;save_data);
    const size = @sizeOf(SaveData);
    save(7, bytes, size);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="complete-example-11"><a class="header" href="#complete-example-11">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[repr(C)]
struct GameSave {
    magic: u32,
    version: u32,
    level: u32,
    score: u32,
    lives: u32,
    player_x: f32,
    player_y: f32,
    unlocked_levels: u32,  // Bitmask
    high_scores: [u32; 10],
    checksum: u32,
}

static mut CURRENT_SAVE: GameSave = GameSave {
    magic: 0x47414D45,
    version: 1,
    level: 1,
    score: 0,
    lives: 3,
    player_x: 0.0,
    player_y: 0.0,
    unlocked_levels: 1,
    high_scores: [0; 10],
    checksum: 0,
};

fn save_to_slot(slot: u32) -&gt; bool {
    unsafe {
        CURRENT_SAVE.checksum = calculate_checksum(&amp;CURRENT_SAVE);
        let bytes = &amp;CURRENT_SAVE as *const GameSave as *const u8;
        let size = core::mem::size_of::&lt;GameSave&gt;();
        save(slot, bytes, size as u32) == 0
    }
}

fn load_from_slot(slot: u32) -&gt; bool {
    unsafe {
        let bytes = &amp;mut CURRENT_SAVE as *mut GameSave as *mut u8;
        let size = core::mem::size_of::&lt;GameSave&gt;();
        let read = load(slot, bytes, size as u32);

        if read == size as u32 {
            let expected = calculate_checksum(&amp;CURRENT_SAVE);
            if CURRENT_SAVE.checksum == expected &amp;&amp; CURRENT_SAVE.magic == 0x47414D45 {
                return true;
            }
        }
        // Reset to defaults on failure
        CURRENT_SAVE = GameSave::default();
        false
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">typedef struct {
    uint32_t magic;
    uint32_t version;
    uint32_t level;
    uint32_t score;
    uint32_t lives;
    float player_x;
    float player_y;
    uint32_t unlocked_levels;  // Bitmask
    uint32_t high_scores[10];
    uint32_t checksum;
} GameSave;

static GameSave CURRENT_SAVE = {
    .magic = 0x47414D45,
    .version = 1,
    .level = 1,
    .score = 0,
    .lives = 3,
    .player_x = 0.0f,
    .player_y = 0.0f,
    .unlocked_levels = 1,
    .high_scores = {0},
    .checksum = 0,
};

bool save_to_slot(uint32_t slot) {
    CURRENT_SAVE.checksum = calculate_checksum(&amp;CURRENT_SAVE);
    const uint8_t* bytes = (const uint8_t*)&amp;CURRENT_SAVE;
    uint32_t size = sizeof(GameSave);
    return save(slot, bytes, size) == 0;
}

bool load_from_slot(uint32_t slot) {
    uint8_t* bytes = (uint8_t*)&amp;CURRENT_SAVE;
    uint32_t size = sizeof(GameSave);
    uint32_t read = load(slot, bytes, size);

    if (read == size) {
        uint32_t expected = calculate_checksum(&amp;CURRENT_SAVE);
        if (CURRENT_SAVE.checksum == expected &amp;&amp; CURRENT_SAVE.magic == 0x47414D45) {
            return true;
        }
    }
    // Reset to defaults on failure
    CURRENT_SAVE = (GameSave){
        .magic = 0x47414D45,
        .version = 1,
        .level = 1,
        .lives = 3,
        .unlocked_levels = 1,
    };
    return false;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const GameSave = extern struct {
    magic: u32,
    version: u32,
    level: u32,
    score: u32,
    lives: u32,
    player_x: f32,
    player_y: f32,
    unlocked_levels: u32,  // Bitmask
    high_scores: [10]u32,
    checksum: u32,
};

var CURRENT_SAVE: GameSave = GameSave{
    .magic = 0x47414D45,
    .version = 1,
    .level = 1,
    .score = 0,
    .lives = 3,
    .player_x = 0.0,
    .player_y = 0.0,
    .unlocked_levels = 1,
    .high_scores = [_]u32{0} ** 10,
    .checksum = 0,
};

fn save_to_slot(slot: u32) bool {
    CURRENT_SAVE.checksum = calculate_checksum(&amp;CURRENT_SAVE);
    const bytes: [*]const u8 = @ptrCast(&amp;CURRENT_SAVE);
    const size = @sizeOf(GameSave);
    return save(slot, bytes, size) == 0;
}

fn load_from_slot(slot: u32) bool {
    const bytes: [*]u8 = @ptrCast(&amp;CURRENT_SAVE);
    const size = @sizeOf(GameSave);
    const read = load(slot, bytes, size);

    if (read == size) {
        const expected = calculate_checksum(&amp;CURRENT_SAVE);
        if (CURRENT_SAVE.checksum == expected and CURRENT_SAVE.magic == 0x47414D45) {
            return true;
        }
    }
    // Reset to defaults on failure
    CURRENT_SAVE = GameSave{
        .magic = 0x47414D45,
        .version = 1,
        .level = 1,
        .score = 0,
        .lives = 3,
        .player_x = 0.0,
        .player_y = 0.0,
        .unlocked_levels = 1,
        .high_scores = [_]u32{0} ** 10,
        .checksum = 0,
    };
    return false;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#system-functions">System Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="rom-data-pack-functions"><a class="header" href="#rom-data-pack-functions">ROM Data Pack Functions</a></h1>
<p>Load assets from the ROM’s bundled data pack.</p>
<h2 id="overview-3"><a class="header" href="#overview-3">Overview</a></h2>
<p>Assets loaded via <code>rom_*</code> functions go <strong>directly to VRAM/audio memory</strong>, bypassing WASM linear memory for efficient rollback. Only u32 handles are stored in your game’s RAM.</p>
<p><strong>All <code>rom_*</code> functions are init-only</strong> — call in <code>init()</code>, not <code>update()</code> or <code>render()</code>.</p>
<hr>
<h2 id="asset-loading"><a class="header" href="#asset-loading">Asset Loading</a></h2>
<h3 id="rom_texture"><a class="header" href="#rom_texture">rom_texture</a></h3>
<p>Loads a texture from the data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_texture(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_texture(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_texture(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>id_ptr</td><td><code>*const u8</code></td><td>Pointer to asset ID string</td></tr>
<tr><td>id_len</td><td><code>u32</code></td><td>Length of asset ID</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Texture handle (non-zero on success, 0 if not found)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        PLAYER_TEX = rom_texture(b"player".as_ptr(), 6);
        ENEMY_TEX = rom_texture(b"enemy_sheet".as_ptr(), 11);
        TERRAIN_TEX = rom_texture(b"terrain".as_ptr(), 7);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    player_tex = rom_texture("player", 6);
    enemy_tex = rom_texture("enemy_sheet", 11);
    terrain_tex = rom_texture("terrain", 7);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    player_tex = rom_texture("player", 6);
    enemy_tex = rom_texture("enemy_sheet", 11);
    terrain_tex = rom_texture("terrain", 7);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_mesh"><a class="header" href="#rom_mesh">rom_mesh</a></h3>
<p>Loads a mesh from the data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_mesh(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_mesh(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_mesh(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Mesh handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        LEVEL_MESH = rom_mesh(b"level1".as_ptr(), 6);
        PLAYER_MESH = rom_mesh(b"player_model".as_ptr(), 12);
        ENEMY_MESH = rom_mesh(b"enemy".as_ptr(), 5);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    level_mesh = rom_mesh("level1", 6);
    player_mesh = rom_mesh("player_model", 12);
    enemy_mesh = rom_mesh("enemy", 5);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    level_mesh = rom_mesh("level1", 6);
    player_mesh = rom_mesh("player_model", 12);
    enemy_mesh = rom_mesh("enemy", 5);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_skeleton"><a class="header" href="#rom_skeleton">rom_skeleton</a></h3>
<p>Loads a skeleton (inverse bind matrices) from the data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_skeleton(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_skeleton(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_skeleton(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Skeleton handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        PLAYER_SKELETON = rom_skeleton(b"player_rig".as_ptr(), 10);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    player_skeleton = rom_skeleton("player_rig", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    player_skeleton = rom_skeleton("player_rig", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_font"><a class="header" href="#rom_font">rom_font</a></h3>
<p>Loads a bitmap font from the data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_font(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_font(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_font(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Font handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        UI_FONT = rom_font(b"ui_font".as_ptr(), 7);
        TITLE_FONT = rom_font(b"title_font".as_ptr(), 10);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    ui_font = rom_font("ui_font", 7);
    title_font = rom_font("title_font", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    ui_font = rom_font("ui_font", 7);
    title_font = rom_font("title_font", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_sound"><a class="header" href="#rom_sound">rom_sound</a></h3>
<p>Loads a sound from the data pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_sound(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_sound(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_sound(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Sound handle</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        JUMP_SFX = rom_sound(b"jump".as_ptr(), 4);
        COIN_SFX = rom_sound(b"coin".as_ptr(), 4);
        MUSIC = rom_sound(b"level1_bgm".as_ptr(), 10);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    jump_sfx = rom_sound("jump", 4);
    coin_sfx = rom_sound("coin", 4);
    music = rom_sound("level1_bgm", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    jump_sfx = rom_sound("jump", 4);
    coin_sfx = rom_sound("coin", 4);
    music = rom_sound("level1_bgm", 10);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="raw-data-access"><a class="header" href="#raw-data-access">Raw Data Access</a></h2>
<p>For custom data formats (level data, dialog scripts, etc.).</p>
<h3 id="rom_data_len"><a class="header" href="#rom_data_len">rom_data_len</a></h3>
<p>Gets the size of raw data in the pack.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_data_len(id_ptr: *const u8, id_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_data_len(const uint8_t* id_ptr, uint32_t id_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_data_len(id_ptr: [*]const u8, id_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Size in bytes (0 if not found)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        let len = rom_data_len(b"level1_map".as_ptr(), 10);
        if len &gt; 0 {
            // Allocate buffer and load
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    uint32_t len = rom_data_len("level1_map", 10);
    if (len &gt; 0) {
        // Allocate buffer and load
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    const len = rom_data_len("level1_map", 10);
    if (len &gt; 0) {
        // Allocate buffer and load
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="rom_data"><a class="header" href="#rom_data">rom_data</a></h3>
<p>Copies raw data from the pack into WASM memory.</p>
<p><strong>Signature:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn rom_data(id_ptr: *const u8, id_len: u32, out_ptr: *mut u8, max_len: u32) -&gt; u32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT uint32_t rom_data(const uint8_t* id_ptr, uint32_t id_len, uint8_t* out_ptr, uint32_t max_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn rom_data(id_ptr: [*]const u8, id_len: u32, out_ptr: [*]u8, max_len: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Parameters:</strong></p>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Name</th><th>Type</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td>id_ptr</td><td><code>*const u8</code></td><td>Pointer to asset ID</td></tr>
<tr><td>id_len</td><td><code>u32</code></td><td>Length of asset ID</td></tr>
<tr><td>out_ptr</td><td><code>*mut u8</code></td><td>Destination buffer in WASM memory</td></tr>
<tr><td>max_len</td><td><code>u32</code></td><td>Maximum bytes to copy</td></tr>
</tbody>
</table>
</div>
<p><strong>Returns:</strong> Bytes copied (0 if not found or buffer too small)</p>
<p><strong>Example:</strong></p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut LEVEL_DATA: [u8; 4096] = [0; 4096];

fn init() {
    unsafe {
        let len = rom_data_len(b"level1".as_ptr(), 6);
        if len &lt;= 4096 {
            rom_data(b"level1".as_ptr(), 6, LEVEL_DATA.as_mut_ptr(), 4096);
            parse_level(&amp;LEVEL_DATA[..len as usize]);
        }
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint8_t level_data[4096] = {0};

EWZX_EXPORT void init(void) {
    uint32_t len = rom_data_len("level1", 6);
    if (len &lt;= 4096) {
        rom_data("level1", 6, level_data, 4096);
        parse_level(level_data, len);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var level_data: [4096]u8 = [_]u8{0} ** 4096;

export fn init() void {
    const len = rom_data_len("level1", 6);
    if (len &lt;= 4096) {
        _ = rom_data("level1", 6, &amp;level_data, 4096);
        parse_level(level_data[0..len]);
    }
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="game-manifest-nethertoml-1"><a class="header" href="#game-manifest-nethertoml-1">Game Manifest (nether.toml)</a></h2>
<p>Assets are bundled using the <code>nether.toml</code> manifest:</p>
<pre><code class="language-toml">[game]
id = "my-game"
title = "My Awesome Game"
author = "Developer Name"
version = "1.0.0"
render_mode = 2

[[assets.textures]]
id = "player"
path = "assets/player.png"

[[assets.textures]]
id = "enemy_sheet"
path = "assets/enemies.png"

[[assets.meshes]]
id = "level1"
path = "assets/level1.ewzmesh"

[[assets.meshes]]
id = "player_model"
path = "assets/player.ewzmesh"

[[assets.skeletons]]
id = "player_rig"
path = "assets/player.ewzskel"

[[assets.animations]]
id = "walk"
path = "assets/walk.ewzanim"

[[assets.sounds]]
id = "jump"
path = "assets/sfx/jump.raw"

[[assets.sounds]]
id = "level1_bgm"
path = "assets/music/level1.raw"

[[assets.fonts]]
id = "ui_font"
path = "assets/fonts/ui.ewzfont"

[[assets.data]]
id = "level1"
path = "assets/levels/level1.bin"
</code></pre>
<p>Build with:</p>
<pre><code class="language-bash">nether build
nether pack  # Creates .ewz ROM file
</code></pre>
<hr>
<h2 id="memory-model-1"><a class="header" href="#memory-model-1">Memory Model</a></h2>
<pre><code>ROM (12MB)          RAM (4MB)           VRAM (4MB)
┌────────────┐      ┌────────────┐      ┌────────────┐
│ WASM code  │      │ Game state │      │ Textures   │
│ (50-200KB) │      │ (handles)  │      │ (from ROM) │
├────────────┤      │            │      ├────────────┤
│ Data Pack: │      │ u32 tex_id │─────▶│ Uploaded   │
│ - textures │      │ u32 mesh_id│─────▶│ GPU data   │
│ - meshes   │      │ u32 snd_id │      └────────────┘
│ - sounds   │      │            │
│ - fonts    │      │ Level data │◀──── rom_data()
│ - data     │      │ (copied)   │      copies here
└────────────┘      └────────────┘
</code></pre>
<p><strong>Key points:</strong></p>
<ul>
<li><code>rom_texture/mesh/sound/font</code> → Data stays in host memory, only handle in WASM RAM</li>
<li><code>rom_data</code> → Data copied to WASM RAM (use sparingly for level data, etc.)</li>
<li>Only WASM RAM (4MB) is snapshotted for rollback</li>
</ul>
<hr>
<h2 id="complete-example-12"><a class="header" href="#complete-example-12">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Asset handles
static mut PLAYER_TEX: u32 = 0;
static mut PLAYER_MESH: u32 = 0;
static mut PLAYER_SKEL: u32 = 0;
static mut WALK_ANIM: u32 = 0;
static mut IDLE_ANIM: u32 = 0;
static mut JUMP_SFX: u32 = 0;
static mut MUSIC: u32 = 0;
static mut UI_FONT: u32 = 0;

// Level data (copied to WASM memory)
static mut LEVEL_DATA: [u8; 8192] = [0; 8192];
static mut LEVEL_SIZE: u32 = 0;

fn init() {
    unsafe {
        // Graphics assets → VRAM
        PLAYER_TEX = rom_texture(b"player".as_ptr(), 6);
        PLAYER_MESH = rom_mesh(b"player".as_ptr(), 6);
        PLAYER_SKEL = rom_skeleton(b"player_rig".as_ptr(), 10);

        // Animations → GPU storage
        WALK_ANIM = rom_keyframes(b"walk".as_ptr(), 4);
        IDLE_ANIM = rom_keyframes(b"idle".as_ptr(), 4);

        // Audio → Audio memory
        JUMP_SFX = rom_sound(b"jump".as_ptr(), 4);
        MUSIC = rom_sound(b"music".as_ptr(), 5);

        // Font → VRAM
        UI_FONT = rom_font(b"ui".as_ptr(), 2);

        // Level data → WASM RAM (copied)
        LEVEL_SIZE = rom_data_len(b"level1".as_ptr(), 6);
        if LEVEL_SIZE &lt;= 8192 {
            rom_data(b"level1".as_ptr(), 6, LEVEL_DATA.as_mut_ptr(), 8192);
        }

        // Start music
        music_play(MUSIC, 0.7);
    }
}

fn render() {
    unsafe {
        // Use loaded assets
        texture_bind(PLAYER_TEX);
        skeleton_bind(PLAYER_SKEL);
        keyframe_bind(WALK_ANIM, frame);
        draw_mesh(PLAYER_MESH);

        font_bind(UI_FONT);
        draw_text(b"SCORE: 0".as_ptr(), 8, 10.0, 10.0, 16.0, 0xFFFFFFFF);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Asset handles
static uint32_t player_tex = 0;
static uint32_t player_mesh = 0;
static uint32_t player_skel = 0;
static uint32_t walk_anim = 0;
static uint32_t idle_anim = 0;
static uint32_t jump_sfx = 0;
static uint32_t music = 0;
static uint32_t ui_font = 0;

// Level data (copied to WASM memory)
static uint8_t level_data[8192] = {0};
static uint32_t level_size = 0;

EWZX_EXPORT void init(void) {
    // Graphics assets → VRAM
    player_tex = rom_texture("player", 6);
    player_mesh = rom_mesh("player", 6);
    player_skel = rom_skeleton("player_rig", 10);

    // Animations → GPU storage
    walk_anim = rom_keyframes("walk", 4);
    idle_anim = rom_keyframes("idle", 4);

    // Audio → Audio memory
    jump_sfx = rom_sound("jump", 4);
    music = rom_sound("music", 5);

    // Font → VRAM
    ui_font = rom_font("ui", 2);

    // Level data → WASM RAM (copied)
    level_size = rom_data_len("level1", 6);
    if (level_size &lt;= 8192) {
        rom_data("level1", 6, level_data, 8192);
    }

    // Start music
    music_play(music, 0.7);
}

EWZX_EXPORT void render(void) {
    // Use loaded assets
    texture_bind(player_tex);
    skeleton_bind(player_skel);
    keyframe_bind(walk_anim, frame);
    draw_mesh(player_mesh);

    font_bind(ui_font);
    draw_text("SCORE: 0", 8, 10.0, 10.0, 16.0, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Asset handles
var player_tex: u32 = 0;
var player_mesh: u32 = 0;
var player_skel: u32 = 0;
var walk_anim: u32 = 0;
var idle_anim: u32 = 0;
var jump_sfx: u32 = 0;
var music: u32 = 0;
var ui_font: u32 = 0;

// Level data (copied to WASM memory)
var level_data: [8192]u8 = [_]u8{0} ** 8192;
var level_size: u32 = 0;

export fn init() void {
    // Graphics assets → VRAM
    player_tex = rom_texture("player", 6);
    player_mesh = rom_mesh("player", 6);
    player_skel = rom_skeleton("player_rig", 10);

    // Animations → GPU storage
    walk_anim = rom_keyframes("walk", 4);
    idle_anim = rom_keyframes("idle", 4);

    // Audio → Audio memory
    jump_sfx = rom_sound("jump", 4);
    music = rom_sound("music", 5);

    // Font → VRAM
    ui_font = rom_font("ui", 2);

    // Level data → WASM RAM (copied)
    level_size = rom_data_len("level1", 6);
    if (level_size &lt;= 8192) {
        _ = rom_data("level1", 6, &amp;level_data, 8192);
    }

    // Start music
    music_play(music, 0.7);
}

export fn render() void {
    // Use loaded assets
    texture_bind(player_tex);
    skeleton_bind(player_skel);
    keyframe_bind(walk_anim, frame);
    draw_mesh(player_mesh);

    font_bind(ui_font);
    draw_text("SCORE: 0", 8, 10.0, 10.0, 16.0, 0xFFFFFFFF);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#texture-functions">Textures</a>, <a href="#mesh-functions">Meshes</a>, <a href="#audio-functions">Audio</a>, <a href="#keyframe-animation-functions">Animation</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="debug-functions"><a class="header" href="#debug-functions">Debug Functions</a></h1>
<p>Runtime value inspection via the F3 debug panel.</p>
<h2 id="overview-4"><a class="header" href="#overview-4">Overview</a></h2>
<p>The debug system allows you to register game variables for live editing and monitoring. Press <strong>F3</strong> to open the debug panel during development.</p>
<p><strong>Features:</strong></p>
<ul>
<li>Live value editing (sliders, color pickers)</li>
<li>Read-only watches</li>
<li>Grouped organization</li>
<li>Frame control (pause, step, time scale)</li>
<li>Zero overhead in release builds</li>
</ul>
<hr>
<h2 id="value-registration"><a class="header" href="#value-registration">Value Registration</a></h2>
<p>Register editable values in <code>init()</code>. The debug panel will show controls for these values.</p>
<h3 id="debug_register_i32"><a class="header" href="#debug_register_i32">debug_register_i32</a></h3>
<p>Registers an editable 32-bit signed integer.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_i32(name_ptr: *const u8, name_len: u32, ptr: *const i32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_i32(const uint8_t* name_ptr, uint32_t name_len, const int32_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_i32(name_ptr: [*]const u8, name_len: u32, ptr: *const i32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut ENEMY_COUNT: i32 = 5;

fn init() {
    unsafe {
        debug_register_i32(b"Enemy Count".as_ptr(), 11, &amp;ENEMY_COUNT);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static int32_t enemy_count = 5;

EWZX_EXPORT void init(void) {
    debug_register_i32("Enemy Count", 11, &amp;enemy_count);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var enemy_count: i32 = 5;

export fn init() void {
    debug_register_i32("Enemy Count", 11, &amp;enemy_count);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_f32"><a class="header" href="#debug_register_f32">debug_register_f32</a></h3>
<p>Registers an editable 32-bit float.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_f32(name_ptr: *const u8, name_len: u32, ptr: *const f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_f32(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_f32(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut GRAVITY: f32 = 9.8;
static mut JUMP_FORCE: f32 = 15.0;

fn init() {
    unsafe {
        debug_register_f32(b"Gravity".as_ptr(), 7, &amp;GRAVITY);
        debug_register_f32(b"Jump Force".as_ptr(), 10, &amp;JUMP_FORCE);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float gravity = 9.8f;
static float jump_force = 15.0f;

EWZX_EXPORT void init(void) {
    debug_register_f32("Gravity", 7, &amp;gravity);
    debug_register_f32("Jump Force", 10, &amp;jump_force);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var gravity: f32 = 9.8;
var jump_force: f32 = 15.0;

export fn init() void {
    debug_register_f32("Gravity", 7, &amp;gravity);
    debug_register_f32("Jump Force", 10, &amp;jump_force);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_bool"><a class="header" href="#debug_register_bool">debug_register_bool</a></h3>
<p>Registers an editable boolean (checkbox).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_bool(name_ptr: *const u8, name_len: u32, ptr: *const u8)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_bool(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_bool(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut GOD_MODE: u8 = 0; // 0 = false, 1 = true

fn init() {
    unsafe {
        debug_register_bool(b"God Mode".as_ptr(), 8, &amp;GOD_MODE);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint8_t god_mode = 0; // 0 = false, 1 = true

EWZX_EXPORT void init(void) {
    debug_register_bool("God Mode", 8, &amp;god_mode);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var god_mode: u8 = 0; // 0 = false, 1 = true

export fn init() void {
    debug_register_bool("God Mode", 8, &amp;god_mode);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_u8--u16--u32"><a class="header" href="#debug_register_u8--u16--u32">debug_register_u8 / u16 / u32</a></h3>
<p>Registers unsigned integers.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_u8(name_ptr: *const u8, name_len: u32, ptr: *const u8)
fn debug_register_u16(name_ptr: *const u8, name_len: u32, ptr: *const u16)
fn debug_register_u32(name_ptr: *const u8, name_len: u32, ptr: *const u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_u8(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
EWZX_IMPORT void debug_register_u16(const uint8_t* name_ptr, uint32_t name_len, const uint16_t* ptr);
EWZX_IMPORT void debug_register_u32(const uint8_t* name_ptr, uint32_t name_len, const uint32_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_u8(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
pub extern fn debug_register_u16(name_ptr: [*]const u8, name_len: u32, ptr: *const u16) void;
pub extern fn debug_register_u32(name_ptr: [*]const u8, name_len: u32, ptr: *const u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_i8--i16"><a class="header" href="#debug_register_i8--i16">debug_register_i8 / i16</a></h3>
<p>Registers signed integers.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_i8(name_ptr: *const u8, name_len: u32, ptr: *const i8)
fn debug_register_i16(name_ptr: *const u8, name_len: u32, ptr: *const i16)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_i8(const uint8_t* name_ptr, uint32_t name_len, const int8_t* ptr);
EWZX_IMPORT void debug_register_i16(const uint8_t* name_ptr, uint32_t name_len, const int16_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_i8(name_ptr: [*]const u8, name_len: u32, ptr: *const i8) void;
pub extern fn debug_register_i16(name_ptr: [*]const u8, name_len: u32, ptr: *const i16) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="range-constrained-registration"><a class="header" href="#range-constrained-registration">Range-Constrained Registration</a></h2>
<h3 id="debug_register_i32_range"><a class="header" href="#debug_register_i32_range">debug_register_i32_range</a></h3>
<p>Registers an integer with min/max bounds (slider).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_i32_range(
    name_ptr: *const u8, name_len: u32,
    ptr: *const i32,
    min: i32, max: i32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_i32_range(
    const uint8_t* name_ptr, uint32_t name_len,
    const int32_t* ptr,
    int32_t min, int32_t max
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_i32_range(
    name_ptr: [*]const u8, name_len: u32,
    ptr: *const i32,
    min: i32, max: i32
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut DIFFICULTY: i32 = 2;

fn init() {
    unsafe {
        debug_register_i32_range(b"Difficulty".as_ptr(), 10, &amp;DIFFICULTY, 1, 5);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static int32_t difficulty = 2;

EWZX_EXPORT void init(void) {
    debug_register_i32_range("Difficulty", 10, &amp;difficulty, 1, 5);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var difficulty: i32 = 2;

export fn init() void {
    debug_register_i32_range("Difficulty", 10, &amp;difficulty, 1, 5);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_f32_range"><a class="header" href="#debug_register_f32_range">debug_register_f32_range</a></h3>
<p>Registers a float with min/max bounds.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_f32_range(
    name_ptr: *const u8, name_len: u32,
    ptr: *const f32,
    min: f32, max: f32
)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_f32_range(
    const uint8_t* name_ptr, uint32_t name_len,
    const float* ptr,
    float min, float max
);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_f32_range(
    name_ptr: [*]const u8, name_len: u32,
    ptr: *const f32,
    min: f32, max: f32
) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PLAYER_SPEED: f32 = 5.0;

fn init() {
    unsafe {
        debug_register_f32_range(b"Speed".as_ptr(), 5, &amp;PLAYER_SPEED, 0.0, 20.0);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float player_speed = 5.0f;

EWZX_EXPORT void init(void) {
    debug_register_f32_range("Speed", 5, &amp;player_speed, 0.0f, 20.0f);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var player_speed: f32 = 5.0;

export fn init() void {
    debug_register_f32_range("Speed", 5, &amp;player_speed, 0.0, 20.0);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_u8_range--u16_range--i16_range"><a class="header" href="#debug_register_u8_range--u16_range--i16_range">debug_register_u8_range / u16_range / i16_range</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_u8_range(name_ptr: *const u8, name_len: u32, ptr: *const u8, min: u32, max: u32)
fn debug_register_u16_range(name_ptr: *const u8, name_len: u32, ptr: *const u16, min: u32, max: u32)
fn debug_register_i16_range(name_ptr: *const u8, name_len: u32, ptr: *const i16, min: i32, max: i32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_u8_range(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr, uint32_t min, uint32_t max);
EWZX_IMPORT void debug_register_u16_range(const uint8_t* name_ptr, uint32_t name_len, const uint16_t* ptr, uint32_t min, uint32_t max);
EWZX_IMPORT void debug_register_i16_range(const uint8_t* name_ptr, uint32_t name_len, const int16_t* ptr, int32_t min, int32_t max);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_u8_range(name_ptr: [*]const u8, name_len: u32, ptr: *const u8, min: u32, max: u32) void;
pub extern fn debug_register_u16_range(name_ptr: [*]const u8, name_len: u32, ptr: *const u16, min: u32, max: u32) void;
pub extern fn debug_register_i16_range(name_ptr: [*]const u8, name_len: u32, ptr: *const i16, min: i32, max: i32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="debug_register_vec2"><a class="header" href="#debug_register_vec2">debug_register_vec2</a></h3>
<p>Registers a 2D vector (two f32s).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_vec2(name_ptr: *const u8, name_len: u32, ptr: *const f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_vec2(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_vec2(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut PLAYER_POS: [f32; 2] = [0.0, 0.0];

fn init() {
    unsafe {
        debug_register_vec2(b"Player Pos".as_ptr(), 10, PLAYER_POS.as_ptr());
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static float player_pos[2] = {0.0f, 0.0f};

EWZX_EXPORT void init(void) {
    debug_register_vec2("Player Pos", 10, player_pos);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var player_pos: [2]f32 = .{0.0, 0.0};

export fn init() void {
    debug_register_vec2("Player Pos", 10, &amp;player_pos);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_vec3"><a class="header" href="#debug_register_vec3">debug_register_vec3</a></h3>
<p>Registers a 3D vector (three f32s).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_vec3(name_ptr: *const u8, name_len: u32, ptr: *const f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_vec3(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_vec3(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_rect"><a class="header" href="#debug_register_rect">debug_register_rect</a></h3>
<p>Registers a rectangle (x, y, width, height as four f32s).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_rect(name_ptr: *const u8, name_len: u32, ptr: *const f32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_rect(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_rect(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_register_color"><a class="header" href="#debug_register_color">debug_register_color</a></h3>
<p>Registers a color (RGBA as four u8s).</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_color(name_ptr: *const u8, name_len: u32, ptr: *const u8)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_color(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_color(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut TINT_COLOR: [u8; 4] = [255, 255, 255, 255];

fn init() {
    unsafe {
        debug_register_color(b"Tint".as_ptr(), 4, TINT_COLOR.as_ptr());
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint8_t tint_color[4] = {255, 255, 255, 255};

EWZX_EXPORT void init(void) {
    debug_register_color("Tint", 4, tint_color);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var tint_color: [4]u8 = .{255, 255, 255, 255};

export fn init() void {
    debug_register_color("Tint", 4, &amp;tint_color);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="fixed-point-registration"><a class="header" href="#fixed-point-registration">Fixed-Point Registration</a></h2>
<p>For games using fixed-point math.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_register_fixed_i16_q8(name_ptr: *const u8, name_len: u32, ptr: *const i16)
fn debug_register_fixed_i32_q8(name_ptr: *const u8, name_len: u32, ptr: *const i32)
fn debug_register_fixed_i32_q16(name_ptr: *const u8, name_len: u32, ptr: *const i32)
fn debug_register_fixed_i32_q24(name_ptr: *const u8, name_len: u32, ptr: *const i32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_register_fixed_i16_q8(const uint8_t* name_ptr, uint32_t name_len, const int16_t* ptr);
EWZX_IMPORT void debug_register_fixed_i32_q8(const uint8_t* name_ptr, uint32_t name_len, const int32_t* ptr);
EWZX_IMPORT void debug_register_fixed_i32_q16(const uint8_t* name_ptr, uint32_t name_len, const int32_t* ptr);
EWZX_IMPORT void debug_register_fixed_i32_q24(const uint8_t* name_ptr, uint32_t name_len, const int32_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_register_fixed_i16_q8(name_ptr: [*]const u8, name_len: u32, ptr: *const i16) void;
pub extern fn debug_register_fixed_i32_q8(name_ptr: [*]const u8, name_len: u32, ptr: *const i32) void;
pub extern fn debug_register_fixed_i32_q16(name_ptr: [*]const u8, name_len: u32, ptr: *const i32) void;
pub extern fn debug_register_fixed_i32_q24(name_ptr: [*]const u8, name_len: u32, ptr: *const i32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="watch-functions-read-only"><a class="header" href="#watch-functions-read-only">Watch Functions (Read-Only)</a></h2>
<p>Watches display values without allowing editing.</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_watch_i8(name_ptr: *const u8, name_len: u32, ptr: *const i8)
fn debug_watch_i16(name_ptr: *const u8, name_len: u32, ptr: *const i16)
fn debug_watch_i32(name_ptr: *const u8, name_len: u32, ptr: *const i32)
fn debug_watch_u8(name_ptr: *const u8, name_len: u32, ptr: *const u8)
fn debug_watch_u16(name_ptr: *const u8, name_len: u32, ptr: *const u16)
fn debug_watch_u32(name_ptr: *const u8, name_len: u32, ptr: *const u32)
fn debug_watch_f32(name_ptr: *const u8, name_len: u32, ptr: *const f32)
fn debug_watch_bool(name_ptr: *const u8, name_len: u32, ptr: *const u8)
fn debug_watch_vec2(name_ptr: *const u8, name_len: u32, ptr: *const f32)
fn debug_watch_vec3(name_ptr: *const u8, name_len: u32, ptr: *const f32)
fn debug_watch_rect(name_ptr: *const u8, name_len: u32, ptr: *const f32)
fn debug_watch_color(name_ptr: *const u8, name_len: u32, ptr: *const u8)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_watch_i8(const uint8_t* name_ptr, uint32_t name_len, const int8_t* ptr);
EWZX_IMPORT void debug_watch_i16(const uint8_t* name_ptr, uint32_t name_len, const int16_t* ptr);
EWZX_IMPORT void debug_watch_i32(const uint8_t* name_ptr, uint32_t name_len, const int32_t* ptr);
EWZX_IMPORT void debug_watch_u8(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
EWZX_IMPORT void debug_watch_u16(const uint8_t* name_ptr, uint32_t name_len, const uint16_t* ptr);
EWZX_IMPORT void debug_watch_u32(const uint8_t* name_ptr, uint32_t name_len, const uint32_t* ptr);
EWZX_IMPORT void debug_watch_f32(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
EWZX_IMPORT void debug_watch_bool(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
EWZX_IMPORT void debug_watch_vec2(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
EWZX_IMPORT void debug_watch_vec3(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
EWZX_IMPORT void debug_watch_rect(const uint8_t* name_ptr, uint32_t name_len, const float* ptr);
EWZX_IMPORT void debug_watch_color(const uint8_t* name_ptr, uint32_t name_len, const uint8_t* ptr);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_watch_i8(name_ptr: [*]const u8, name_len: u32, ptr: *const i8) void;
pub extern fn debug_watch_i16(name_ptr: [*]const u8, name_len: u32, ptr: *const i16) void;
pub extern fn debug_watch_i32(name_ptr: [*]const u8, name_len: u32, ptr: *const i32) void;
pub extern fn debug_watch_u8(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
pub extern fn debug_watch_u16(name_ptr: [*]const u8, name_len: u32, ptr: *const u16) void;
pub extern fn debug_watch_u32(name_ptr: [*]const u8, name_len: u32, ptr: *const u32) void;
pub extern fn debug_watch_f32(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
pub extern fn debug_watch_bool(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
pub extern fn debug_watch_vec2(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
pub extern fn debug_watch_vec3(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
pub extern fn debug_watch_rect(name_ptr: [*]const u8, name_len: u32, ptr: *const f32) void;
pub extern fn debug_watch_color(name_ptr: [*]const u8, name_len: u32, ptr: *const u8) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>static mut FRAME_COUNT: u32 = 0;
static mut FPS: f32 = 0.0;

fn init() {
    unsafe {
        debug_watch_u32(b"Frame".as_ptr(), 5, &amp;FRAME_COUNT);
        debug_watch_f32(b"FPS".as_ptr(), 3, &amp;FPS);
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">static uint32_t frame_count = 0;
static float fps = 0.0f;

EWZX_EXPORT void init(void) {
    debug_watch_u32("Frame", 5, &amp;frame_count);
    debug_watch_f32("FPS", 3, &amp;fps);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">var frame_count: u32 = 0;
var fps: f32 = 0.0;

export fn init() void {
    debug_watch_u32("Frame", 5, &amp;frame_count);
    debug_watch_f32("FPS", 3, &amp;fps);
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="grouping"><a class="header" href="#grouping">Grouping</a></h2>
<h3 id="debug_group_begin"><a class="header" href="#debug_group_begin">debug_group_begin</a></h3>
<p>Starts a collapsible group in the debug panel.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_group_begin(name_ptr: *const u8, name_len: u32)
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_group_begin(const uint8_t* name_ptr, uint32_t name_len);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_group_begin(name_ptr: [*]const u8, name_len: u32) void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h3 id="debug_group_end"><a class="header" href="#debug_group_end">debug_group_end</a></h3>
<p>Ends the current group.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_group_end()
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT void debug_group_end(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_group_end() void;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn init() {
    unsafe {
        debug_group_begin(b"Player".as_ptr(), 6);
        debug_register_vec3(b"Position".as_ptr(), 8, PLAYER_POS.as_ptr());
        debug_register_f32(b"Health".as_ptr(), 6, &amp;PLAYER_HEALTH);
        debug_register_f32(b"Speed".as_ptr(), 5, &amp;PLAYER_SPEED);
        debug_group_end();

        debug_group_begin(b"Physics".as_ptr(), 7);
        debug_register_f32(b"Gravity".as_ptr(), 7, &amp;GRAVITY);
        debug_register_f32(b"Friction".as_ptr(), 8, &amp;FRICTION);
        debug_group_end();
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void init(void) {
    debug_group_begin("Player", 6);
    debug_register_vec3("Position", 8, player_pos);
    debug_register_f32("Health", 6, &amp;player_health);
    debug_register_f32("Speed", 5, &amp;player_speed);
    debug_group_end();

    debug_group_begin("Physics", 7);
    debug_register_f32("Gravity", 7, &amp;gravity);
    debug_register_f32("Friction", 8, &amp;friction);
    debug_group_end();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn init() void {
    debug_group_begin("Player", 6);
    debug_register_vec3("Position", 8, &amp;player_pos);
    debug_register_f32("Health", 6, &amp;player_health);
    debug_register_f32("Speed", 5, &amp;player_speed);
    debug_group_end();

    debug_group_begin("Physics", 7);
    debug_register_f32("Gravity", 7, &amp;gravity);
    debug_register_f32("Friction", 8, &amp;friction);
    debug_group_end();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="frame-control"><a class="header" href="#frame-control">Frame Control</a></h2>
<h3 id="debug_is_paused"><a class="header" href="#debug_is_paused">debug_is_paused</a></h3>
<p>Check if game is paused via debug panel.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_is_paused() -&gt; i32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT int32_t debug_is_paused(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_is_paused() i32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> 1 if paused, 0 otherwise</p>
<hr>
<h3 id="debug_get_time_scale"><a class="header" href="#debug_get_time_scale">debug_get_time_scale</a></h3>
<p>Get the current time scale.</p>
<p><strong>Signature:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn debug_get_time_scale() -&gt; f32
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float debug_get_time_scale(void);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn debug_get_time_scale() f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>Returns:</strong> Time scale (1.0 = normal, 0.5 = half speed, 2.0 = double)</p>
<p><strong>Example:</strong>
{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn update() {
    unsafe {
        if debug_is_paused() != 0 {
            return; // Skip update when paused
        }

        let dt = delta_time() * debug_get_time_scale();
        // Use scaled delta time
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_EXPORT void update(void) {
    if (debug_is_paused() != 0) {
        return; // Skip update when paused
    }

    float dt = delta_time() * debug_get_time_scale();
    // Use scaled delta time
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">export fn update() void {
    if (debug_is_paused() != 0) {
        return; // Skip update when paused
    }

    const dt = delta_time() * debug_get_time_scale();
    // Use scaled delta time
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<hr>
<h2 id="debug-keyboard-shortcuts"><a class="header" href="#debug-keyboard-shortcuts">Debug Keyboard Shortcuts</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Key</th><th>Action</th></tr>
</thead>
<tbody>
<tr><td>F3</td><td>Toggle debug panel</td></tr>
<tr><td>F5</td><td>Pause/unpause</td></tr>
<tr><td>F6</td><td>Step one frame (while paused)</td></tr>
<tr><td>F7</td><td>Decrease time scale</td></tr>
<tr><td>F8</td><td>Increase time scale</td></tr>
</tbody>
</table>
</div>
<hr>
<h2 id="complete-example-13"><a class="header" href="#complete-example-13">Complete Example</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Game state
static mut PLAYER_X: f32 = 0.0;
static mut PLAYER_Y: f32 = 0.0;
static mut PLAYER_VEL_X: f32 = 0.0;
static mut PLAYER_VEL_Y: f32 = 0.0;
static mut PLAYER_HEALTH: f32 = 100.0;

// Tuning parameters
static mut MOVE_SPEED: f32 = 5.0;
static mut JUMP_FORCE: f32 = 12.0;
static mut GRAVITY: f32 = 25.0;
static mut FRICTION: f32 = 0.9;

// Debug
static mut GOD_MODE: u8 = 0;
static mut SHOW_HITBOXES: u8 = 0;
static mut ENEMY_COUNT: i32 = 5;

fn init() {
    unsafe {
        // Player group
        debug_group_begin(b"Player".as_ptr(), 6);
        debug_watch_f32(b"X".as_ptr(), 1, &amp;PLAYER_X);
        debug_watch_f32(b"Y".as_ptr(), 1, &amp;PLAYER_Y);
        debug_watch_f32(b"Vel X".as_ptr(), 5, &amp;PLAYER_VEL_X);
        debug_watch_f32(b"Vel Y".as_ptr(), 5, &amp;PLAYER_VEL_Y);
        debug_register_f32_range(b"Health".as_ptr(), 6, &amp;PLAYER_HEALTH, 0.0, 100.0);
        debug_group_end();

        // Physics group
        debug_group_begin(b"Physics".as_ptr(), 7);
        debug_register_f32_range(b"Move Speed".as_ptr(), 10, &amp;MOVE_SPEED, 1.0, 20.0);
        debug_register_f32_range(b"Jump Force".as_ptr(), 10, &amp;JUMP_FORCE, 5.0, 30.0);
        debug_register_f32_range(b"Gravity".as_ptr(), 7, &amp;GRAVITY, 10.0, 50.0);
        debug_register_f32_range(b"Friction".as_ptr(), 8, &amp;FRICTION, 0.5, 1.0);
        debug_group_end();

        // Debug options
        debug_group_begin(b"Debug".as_ptr(), 5);
        debug_register_bool(b"God Mode".as_ptr(), 8, &amp;GOD_MODE);
        debug_register_bool(b"Show Hitboxes".as_ptr(), 13, &amp;SHOW_HITBOXES);
        debug_register_i32_range(b"Enemy Count".as_ptr(), 11, &amp;ENEMY_COUNT, 0, 20);
        debug_group_end();
    }
}

fn update() {
    unsafe {
        // Respect debug pause
        if debug_is_paused() != 0 {
            return;
        }

        let dt = delta_time() * debug_get_time_scale();

        // Use tunable values
        PLAYER_VEL_Y += GRAVITY * dt;
        PLAYER_VEL_X *= FRICTION;

        if button_held(0, BUTTON_RIGHT) != 0 {
            PLAYER_VEL_X = MOVE_SPEED;
        }
        if button_held(0, BUTTON_LEFT) != 0 {
            PLAYER_VEL_X = -MOVE_SPEED;
        }
        if button_pressed(0, BUTTON_A) != 0 {
            PLAYER_VEL_Y = -JUMP_FORCE;
        }

        PLAYER_X += PLAYER_VEL_X * dt;
        PLAYER_Y += PLAYER_VEL_Y * dt;
    }
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Game state
static float player_x = 0.0f;
static float player_y = 0.0f;
static float player_vel_x = 0.0f;
static float player_vel_y = 0.0f;
static float player_health = 100.0f;

// Tuning parameters
static float move_speed = 5.0f;
static float jump_force = 12.0f;
static float gravity = 25.0f;
static float friction = 0.9f;

// Debug
static uint8_t god_mode = 0;
static uint8_t show_hitboxes = 0;
static int32_t enemy_count = 5;

EWZX_EXPORT void init(void) {
    // Player group
    debug_group_begin("Player", 6);
    debug_watch_f32("X", 1, &amp;player_x);
    debug_watch_f32("Y", 1, &amp;player_y);
    debug_watch_f32("Vel X", 5, &amp;player_vel_x);
    debug_watch_f32("Vel Y", 5, &amp;player_vel_y);
    debug_register_f32_range("Health", 6, &amp;player_health, 0.0f, 100.0f);
    debug_group_end();

    // Physics group
    debug_group_begin("Physics", 7);
    debug_register_f32_range("Move Speed", 10, &amp;move_speed, 1.0f, 20.0f);
    debug_register_f32_range("Jump Force", 10, &amp;jump_force, 5.0f, 30.0f);
    debug_register_f32_range("Gravity", 7, &amp;gravity, 10.0f, 50.0f);
    debug_register_f32_range("Friction", 8, &amp;friction, 0.5f, 1.0f);
    debug_group_end();

    // Debug options
    debug_group_begin("Debug", 5);
    debug_register_bool("God Mode", 8, &amp;god_mode);
    debug_register_bool("Show Hitboxes", 13, &amp;show_hitboxes);
    debug_register_i32_range("Enemy Count", 11, &amp;enemy_count, 0, 20);
    debug_group_end();
}

EWZX_EXPORT void update(void) {
    // Respect debug pause
    if (debug_is_paused() != 0) {
        return;
    }

    float dt = delta_time() * debug_get_time_scale();

    // Use tunable values
    player_vel_y += gravity * dt;
    player_vel_x *= friction;

    if (button_held(0, EWZX_BUTTON_RIGHT) != 0) {
        player_vel_x = move_speed;
    }
    if (button_held(0, EWZX_BUTTON_LEFT) != 0) {
        player_vel_x = -move_speed;
    }
    if (button_pressed(0, EWZX_BUTTON_A) != 0) {
        player_vel_y = -jump_force;
    }

    player_x += player_vel_x * dt;
    player_y += player_vel_y * dt;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Game state
var player_x: f32 = 0.0;
var player_y: f32 = 0.0;
var player_vel_x: f32 = 0.0;
var player_vel_y: f32 = 0.0;
var player_health: f32 = 100.0;

// Tuning parameters
var move_speed: f32 = 5.0;
var jump_force: f32 = 12.0;
var gravity: f32 = 25.0;
var friction: f32 = 0.9;

// Debug
var god_mode: u8 = 0;
var show_hitboxes: u8 = 0;
var enemy_count: i32 = 5;

export fn init() void {
    // Player group
    debug_group_begin("Player", 6);
    debug_watch_f32("X", 1, &amp;player_x);
    debug_watch_f32("Y", 1, &amp;player_y);
    debug_watch_f32("Vel X", 5, &amp;player_vel_x);
    debug_watch_f32("Vel Y", 5, &amp;player_vel_y);
    debug_register_f32_range("Health", 6, &amp;player_health, 0.0, 100.0);
    debug_group_end();

    // Physics group
    debug_group_begin("Physics", 7);
    debug_register_f32_range("Move Speed", 10, &amp;move_speed, 1.0, 20.0);
    debug_register_f32_range("Jump Force", 10, &amp;jump_force, 5.0, 30.0);
    debug_register_f32_range("Gravity", 7, &amp;gravity, 10.0, 50.0);
    debug_register_f32_range("Friction", 8, &amp;friction, 0.5, 1.0);
    debug_group_end();

    // Debug options
    debug_group_begin("Debug", 5);
    debug_register_bool("God Mode", 8, &amp;god_mode);
    debug_register_bool("Show Hitboxes", 13, &amp;show_hitboxes);
    debug_register_i32_range("Enemy Count", 11, &amp;enemy_count, 0, 20);
    debug_group_end();
}

export fn update() void {
    // Respect debug pause
    if (debug_is_paused() != 0) {
        return;
    }

    const dt = delta_time() * debug_get_time_scale();

    // Use tunable values
    player_vel_y += gravity * dt;
    player_vel_x *= friction;

    if (button_held(0, Button.right) != 0) {
        player_vel_x = move_speed;
    }
    if (button_held(0, Button.left) != 0) {
        player_vel_x = -move_speed;
    }
    if (button_pressed(0, Button.a) != 0) {
        player_vel_y = -jump_force;
    }

    player_x += player_vel_x * dt;
    player_y += player_vel_y * dt;
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<p><strong>See Also:</strong> <a href="#system-functions">System Functions</a></p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="dither-patterns-reference"><a class="header" href="#dither-patterns-reference">Dither Patterns Reference</a></h1>
<p>Quick reference for Bayer dithering matrices. Currently Nethercore ZX uses 4x4 only (compile-time), but these are available for future work.</p>
<h2 id="2x2-bayer-matrix-4-levels"><a class="header" href="#2x2-bayer-matrix-4-levels">2x2 Bayer Matrix (4 levels)</a></h2>
<pre><code class="language-wgsl">const BAYER_2X2: array&lt;f32, 4&gt; = array(
    0.0/4.0, 2.0/4.0,
    3.0/4.0, 1.0/4.0,
);
</code></pre>
<h2 id="4x4-bayer-matrix-16-levels--current-default"><a class="header" href="#4x4-bayer-matrix-16-levels--current-default">4x4 Bayer Matrix (16 levels) — Current Default</a></h2>
<pre><code class="language-wgsl">const BAYER_4X4: array&lt;f32, 16&gt; = array(
     0.0/16.0,  8.0/16.0,  2.0/16.0, 10.0/16.0,
    12.0/16.0,  4.0/16.0, 14.0/16.0,  6.0/16.0,
     3.0/16.0, 11.0/16.0,  1.0/16.0,  9.0/16.0,
    15.0/16.0,  7.0/16.0, 13.0/16.0,  5.0/16.0,
);
</code></pre>
<h2 id="8x8-bayer-matrix-64-levels"><a class="header" href="#8x8-bayer-matrix-64-levels">8x8 Bayer Matrix (64 levels)</a></h2>
<pre><code class="language-wgsl">const BAYER_8X8: array&lt;f32, 64&gt; = array(
     0.0/64.0, 32.0/64.0,  8.0/64.0, 40.0/64.0,  2.0/64.0, 34.0/64.0, 10.0/64.0, 42.0/64.0,
    48.0/64.0, 16.0/64.0, 56.0/64.0, 24.0/64.0, 50.0/64.0, 18.0/64.0, 58.0/64.0, 26.0/64.0,
    12.0/64.0, 44.0/64.0,  4.0/64.0, 36.0/64.0, 14.0/64.0, 46.0/64.0,  6.0/64.0, 38.0/64.0,
    60.0/64.0, 28.0/64.0, 52.0/64.0, 20.0/64.0, 62.0/64.0, 30.0/64.0, 54.0/64.0, 22.0/64.0,
     3.0/64.0, 35.0/64.0, 11.0/64.0, 43.0/64.0,  1.0/64.0, 33.0/64.0,  9.0/64.0, 41.0/64.0,
    51.0/64.0, 19.0/64.0, 59.0/64.0, 27.0/64.0, 49.0/64.0, 17.0/64.0, 57.0/64.0, 25.0/64.0,
    15.0/64.0, 47.0/64.0,  7.0/64.0, 39.0/64.0, 13.0/64.0, 45.0/64.0,  5.0/64.0, 37.0/64.0,
    63.0/64.0, 31.0/64.0, 55.0/64.0, 23.0/64.0, 61.0/64.0, 29.0/64.0, 53.0/64.0, 21.0/64.0,
);
</code></pre>
<h2 id="16x16-bayer-matrix-256-levels"><a class="header" href="#16x16-bayer-matrix-256-levels">16x16 Bayer Matrix (256 levels)</a></h2>
<pre><code class="language-wgsl">const BAYER_16X16: array&lt;f32, 256&gt; = array(
      0.0/256.0, 128.0/256.0,  32.0/256.0, 160.0/256.0,   8.0/256.0, 136.0/256.0,  40.0/256.0, 168.0/256.0,   2.0/256.0, 130.0/256.0,  34.0/256.0, 162.0/256.0,  10.0/256.0, 138.0/256.0,  42.0/256.0, 170.0/256.0,
    192.0/256.0,  64.0/256.0, 224.0/256.0,  96.0/256.0, 200.0/256.0,  72.0/256.0, 232.0/256.0, 104.0/256.0, 194.0/256.0,  66.0/256.0, 226.0/256.0,  98.0/256.0, 202.0/256.0,  74.0/256.0, 234.0/256.0, 106.0/256.0,
     48.0/256.0, 176.0/256.0,  16.0/256.0, 144.0/256.0,  56.0/256.0, 184.0/256.0,  24.0/256.0, 152.0/256.0,  50.0/256.0, 178.0/256.0,  18.0/256.0, 146.0/256.0,  58.0/256.0, 186.0/256.0,  26.0/256.0, 154.0/256.0,
    240.0/256.0, 112.0/256.0, 208.0/256.0,  80.0/256.0, 248.0/256.0, 120.0/256.0, 216.0/256.0,  88.0/256.0, 242.0/256.0, 114.0/256.0, 210.0/256.0,  82.0/256.0, 250.0/256.0, 122.0/256.0, 218.0/256.0,  90.0/256.0,
     12.0/256.0, 140.0/256.0,  44.0/256.0, 172.0/256.0,   4.0/256.0, 132.0/256.0,  36.0/256.0, 164.0/256.0,  14.0/256.0, 142.0/256.0,  46.0/256.0, 174.0/256.0,   6.0/256.0, 134.0/256.0,  38.0/256.0, 166.0/256.0,
    204.0/256.0,  76.0/256.0, 236.0/256.0, 108.0/256.0, 196.0/256.0,  68.0/256.0, 228.0/256.0, 100.0/256.0, 206.0/256.0,  78.0/256.0, 238.0/256.0, 110.0/256.0, 198.0/256.0,  70.0/256.0, 230.0/256.0, 102.0/256.0,
     60.0/256.0, 188.0/256.0,  28.0/256.0, 156.0/256.0,  52.0/256.0, 180.0/256.0,  20.0/256.0, 148.0/256.0,  62.0/256.0, 190.0/256.0,  30.0/256.0, 158.0/256.0,  54.0/256.0, 182.0/256.0,  22.0/256.0, 150.0/256.0,
    252.0/256.0, 124.0/256.0, 220.0/256.0,  92.0/256.0, 244.0/256.0, 116.0/256.0, 212.0/256.0,  84.0/256.0, 254.0/256.0, 126.0/256.0, 222.0/256.0,  94.0/256.0, 246.0/256.0, 118.0/256.0, 214.0/256.0,  86.0/256.0,
      3.0/256.0, 131.0/256.0,  35.0/256.0, 163.0/256.0,  11.0/256.0, 139.0/256.0,  43.0/256.0, 171.0/256.0,   1.0/256.0, 129.0/256.0,  33.0/256.0, 161.0/256.0,   9.0/256.0, 137.0/256.0,  41.0/256.0, 169.0/256.0,
    195.0/256.0,  67.0/256.0, 227.0/256.0,  99.0/256.0, 203.0/256.0,  75.0/256.0, 235.0/256.0, 107.0/256.0, 193.0/256.0,  65.0/256.0, 225.0/256.0,  97.0/256.0, 201.0/256.0,  73.0/256.0, 233.0/256.0, 105.0/256.0,
     51.0/256.0, 179.0/256.0,  19.0/256.0, 147.0/256.0,  59.0/256.0, 187.0/256.0,  27.0/256.0, 155.0/256.0,  49.0/256.0, 177.0/256.0,  17.0/256.0, 145.0/256.0,  57.0/256.0, 185.0/256.0,  25.0/256.0, 153.0/256.0,
    243.0/256.0, 115.0/256.0, 211.0/256.0,  83.0/256.0, 251.0/256.0, 123.0/256.0, 219.0/256.0,  91.0/256.0, 241.0/256.0, 113.0/256.0, 209.0/256.0,  81.0/256.0, 249.0/256.0, 121.0/256.0, 217.0/256.0,  89.0/256.0,
     15.0/256.0, 143.0/256.0,  47.0/256.0, 175.0/256.0,   7.0/256.0, 135.0/256.0,  39.0/256.0, 167.0/256.0,  13.0/256.0, 141.0/256.0,  45.0/256.0, 173.0/256.0,   5.0/256.0, 133.0/256.0,  37.0/256.0, 165.0/256.0,
    207.0/256.0,  79.0/256.0, 239.0/256.0, 111.0/256.0, 199.0/256.0,  71.0/256.0, 231.0/256.0, 103.0/256.0, 205.0/256.0,  77.0/256.0, 237.0/256.0, 109.0/256.0, 197.0/256.0,  69.0/256.0, 229.0/256.0, 101.0/256.0,
     63.0/256.0, 191.0/256.0,  31.0/256.0, 159.0/256.0,  55.0/256.0, 183.0/256.0,  23.0/256.0, 151.0/256.0,  61.0/256.0, 189.0/256.0,  29.0/256.0, 157.0/256.0,  53.0/256.0, 181.0/256.0,  21.0/256.0, 149.0/256.0,
    255.0/256.0, 127.0/256.0, 223.0/256.0,  95.0/256.0, 247.0/256.0, 119.0/256.0, 215.0/256.0,  87.0/256.0, 253.0/256.0, 125.0/256.0, 221.0/256.0,  93.0/256.0, 245.0/256.0, 117.0/256.0, 213.0/256.0,  85.0/256.0,
);
</code></pre>
<h2 id="pattern-comparison-at-50-alpha"><a class="header" href="#pattern-comparison-at-50-alpha">Pattern Comparison at 50% Alpha</a></h2>
<pre><code>2x2:              4x4:              8x8:
█░█░█░█░          █░█░              █░█░░█░█
░█░█░█░█          ░█░█              ░░█░█░░█
█░█░█░█░          █░█░              ░█░░█░█░
░█░█░█░█          ░█░█              █░░█░░█░
(obvious)         (classic)         (smoother)
</code></pre>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<pre><code class="language-wgsl">fn get_bayer_threshold(frag_coord: vec2&lt;f32&gt;, size: u32) -&gt; f32 {
    let x = u32(frag_coord.x) % size;
    let y = u32(frag_coord.y) % size;
    return BAYER_MATRIX[y * size + x];
}

fn should_discard(alpha: f32, frag_coord: vec2&lt;f32&gt;) -&gt; bool {
    return alpha &lt; get_bayer_threshold(frag_coord, 4u);
}
</code></pre>
<h2 id="external-references"><a class="header" href="#external-references">External References</a></h2>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Ordered_dithering">Ordered Dithering (Wikipedia)</a></li>
<li><a href="https://www.anisopteragames.com/how-to-fix-color-banding-with-dithering/">Bayer Matrix Generation</a></li>
<li><a href="https://segaretro.org/Sega_Saturn/Hardware_features">Saturn Mesh Transparency</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="button-constants-2"><a class="header" href="#button-constants-2">Button Constants</a></h1>
<p>Quick reference for all button constants used with <code>button_pressed()</code> and <code>button_held()</code>.</p>
<h2 id="standard-layout"><a class="header" href="#standard-layout">Standard Layout</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_LEFT: u32 = 2;
const BUTTON_RIGHT: u32 = 3;
const BUTTON_A: u32 = 4;      // Bottom face button (Xbox A, PlayStation X)
const BUTTON_B: u32 = 5;      // Right face button (Xbox B, PlayStation O)
const BUTTON_X: u32 = 6;      // Left face button (Xbox X, PlayStation Square)
const BUTTON_Y: u32 = 7;      // Top face button (Xbox Y, PlayStation Triangle)
const BUTTON_LB: u32 = 8;     // Left bumper
const BUTTON_RB: u32 = 9;     // Right bumper
const BUTTON_LT: u32 = 10;    // Left trigger (as button)
const BUTTON_RT: u32 = 11;    // Right trigger (as button)
const BUTTON_START: u32 = 12; // Start / Options
const BUTTON_SELECT: u32 = 13; // Select / Share / Back
const BUTTON_L3: u32 = 14;    // Left stick click
const BUTTON_R3: u32 = 15;    // Right stick click
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">#define EWZX_BUTTON_UP 0
#define EWZX_BUTTON_DOWN 1
#define EWZX_BUTTON_LEFT 2
#define EWZX_BUTTON_RIGHT 3
#define EWZX_BUTTON_A 4       // Bottom face button (Xbox A, PlayStation X)
#define EWZX_BUTTON_B 5       // Right face button (Xbox B, PlayStation O)
#define EWZX_BUTTON_X 6       // Left face button (Xbox X, PlayStation Square)
#define EWZX_BUTTON_Y 7       // Top face button (Xbox Y, PlayStation Triangle)
#define EWZX_BUTTON_LB 8      // Left bumper
#define EWZX_BUTTON_RB 9      // Right bumper
#define EWZX_BUTTON_LT 10     // Left trigger (as button)
#define EWZX_BUTTON_RT 11     // Right trigger (as button)
#define EWZX_BUTTON_START 12  // Start / Options
#define EWZX_BUTTON_SELECT 13 // Select / Share / Back
#define EWZX_BUTTON_L3 14     // Left stick click
#define EWZX_BUTTON_R3 15     // Right stick click
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">const Button = struct {
    pub const up: u32 = 0;
    pub const down: u32 = 1;
    pub const left: u32 = 2;
    pub const right: u32 = 3;
    pub const a: u32 = 4;      // Bottom face button (Xbox A, PlayStation X)
    pub const b: u32 = 5;      // Right face button (Xbox B, PlayStation O)
    pub const x: u32 = 6;      // Left face button (Xbox X, PlayStation Square)
    pub const y: u32 = 7;      // Top face button (Xbox Y, PlayStation Triangle)
    pub const lb: u32 = 8;     // Left bumper
    pub const rb: u32 = 9;     // Right bumper
    pub const lt: u32 = 10;    // Left trigger (as button)
    pub const rt: u32 = 11;    // Right trigger (as button)
    pub const start: u32 = 12; // Start / Options
    pub const select: u32 = 13; // Select / Share / Back
    pub const l3: u32 = 14;    // Left stick click
    pub const r3: u32 = 15;    // Right stick click
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="controller-mapping"><a class="header" href="#controller-mapping">Controller Mapping</a></h2>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Nethercore</th><th>Xbox</th><th>PlayStation</th><th>Nintendo</th></tr>
</thead>
<tbody>
<tr><td>A</td><td>A</td><td>X (Cross)</td><td>B</td></tr>
<tr><td>B</td><td>B</td><td>O (Circle)</td><td>A</td></tr>
<tr><td>X</td><td>X</td><td>Square</td><td>Y</td></tr>
<tr><td>Y</td><td>Y</td><td>Triangle</td><td>X</td></tr>
<tr><td>LB</td><td>LB</td><td>L1</td><td>L</td></tr>
<tr><td>RB</td><td>RB</td><td>R1</td><td>R</td></tr>
<tr><td>START</td><td>Menu</td><td>Options</td><td>+</td></tr>
<tr><td>SELECT</td><td>View</td><td>Share</td><td>-</td></tr>
</tbody>
</table>
</div>
<h2 id="input-functions-1"><a class="header" href="#input-functions-1">Input Functions</a></h2>
<h3 id="checking-button-state"><a class="header" href="#checking-button-state">Checking Button State</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Returns 1 on the frame button is first pressed, 0 otherwise
fn button_pressed(player: u32, button: u32) -&gt; u32;

// Returns 1 every frame the button is held, 0 otherwise
fn button_held(player: u32, button: u32) -&gt; u32;

// Returns 1 on the frame button is released, 0 otherwise
fn button_released(player: u32, button: u32) -&gt; u32;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Returns 1 on the frame button is first pressed, 0 otherwise
EWZX_IMPORT uint32_t button_pressed(uint32_t player, uint32_t button);

// Returns 1 every frame the button is held, 0 otherwise
EWZX_IMPORT uint32_t button_held(uint32_t player, uint32_t button);

// Returns 1 on the frame button is released, 0 otherwise
EWZX_IMPORT uint32_t button_released(uint32_t player, uint32_t button);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Returns 1 on the frame button is first pressed, 0 otherwise
pub extern fn button_pressed(player: u32, button: u32) u32;

// Returns 1 every frame the button is held, 0 otherwise
pub extern fn button_held(player: u32, button: u32) u32;

// Returns 1 on the frame button is released, 0 otherwise
pub extern fn button_released(player: u32, button: u32) u32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h3 id="usage-examples"><a class="header" href="#usage-examples">Usage Examples</a></h3>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Jump on button press
if button_pressed(0, BUTTON_A) != 0 {
    player_jump();
}

// Continuous movement while held
if button_held(0, BUTTON_LEFT) != 0 {
    player.x -= SPEED;
}

// Trigger on release (e.g., charge attack)
if button_released(0, BUTTON_X) != 0 {
    release_charged_attack();
}
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Jump on button press
if (button_pressed(0, EWZX_BUTTON_A) != 0) {
    player_jump();
}

// Continuous movement while held
if (button_held(0, EWZX_BUTTON_LEFT) != 0) {
    player.x -= SPEED;
}

// Trigger on release (e.g., charge attack)
if (button_released(0, EWZX_BUTTON_X) != 0) {
    release_charged_attack();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Jump on button press
if (button_pressed(0, Button.a) != 0) {
    player_jump();
}

// Continuous movement while held
if (button_held(0, Button.left) != 0) {
    player.x -= SPEED;
}

// Trigger on release (e.g., charge attack)
if (button_released(0, Button.x) != 0) {
    release_charged_attack();
}
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="analog-input"><a class="header" href="#analog-input">Analog Input</a></h2>
<p>For smooth movement, use the analog sticks:</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn left_stick_x(player: u32) -&gt; f32;   // -1.0 to 1.0
fn left_stick_y(player: u32) -&gt; f32;   // -1.0 (up) to 1.0 (down)
fn right_stick_x(player: u32) -&gt; f32;
fn right_stick_y(player: u32) -&gt; f32;
fn left_trigger(player: u32) -&gt; f32;   // 0.0 to 1.0
fn right_trigger(player: u32) -&gt; f32;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">EWZX_IMPORT float left_stick_x(uint32_t player);   // -1.0 to 1.0
EWZX_IMPORT float left_stick_y(uint32_t player);   // -1.0 (up) to 1.0 (down)
EWZX_IMPORT float right_stick_x(uint32_t player);
EWZX_IMPORT float right_stick_y(uint32_t player);
EWZX_IMPORT float left_trigger(uint32_t player);   // 0.0 to 1.0
EWZX_IMPORT float right_trigger(uint32_t player);
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">pub extern fn left_stick_x(player: u32) f32;   // -1.0 to 1.0
pub extern fn left_stick_y(player: u32) f32;   // -1.0 (up) to 1.0 (down)
pub extern fn right_stick_x(player: u32) f32;
pub extern fn right_stick_y(player: u32) f32;
pub extern fn left_trigger(player: u32) f32;   // 0.0 to 1.0
pub extern fn right_trigger(player: u32) f32;
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="multiple-players"><a class="header" href="#multiple-players">Multiple Players</a></h2>
<p>All input functions take a <code>player</code> parameter (0-3):</p>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Player 1 (index 0)
let p1_x = left_stick_x(0);

// Player 2 (index 1)
let p2_x = left_stick_x(1);

// Check how many players are connected
let count = player_count();
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Player 1 (index 0)
float p1_x = left_stick_x(0);

// Player 2 (index 1)
float p2_x = left_stick_x(1);

// Check how many players are connected
uint32_t count = player_count();
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Player 1 (index 0)
const p1_x = left_stick_x(0);

// Player 2 (index 1)
const p2_x = left_stick_x(1);

// Check how many players are connected
const count = player_count();
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<h2 id="copy-paste-template"><a class="header" href="#copy-paste-template">Copy-Paste Template</a></h2>
<p>{{#tabs global=“lang”}}</p>
<p>{{#tab name=“Rust”}}</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Button constants
const BUTTON_UP: u32 = 0;
const BUTTON_DOWN: u32 = 1;
const BUTTON_LEFT: u32 = 2;
const BUTTON_RIGHT: u32 = 3;
const BUTTON_A: u32 = 4;
const BUTTON_B: u32 = 5;
const BUTTON_X: u32 = 6;
const BUTTON_Y: u32 = 7;
const BUTTON_LB: u32 = 8;
const BUTTON_RB: u32 = 9;
const BUTTON_START: u32 = 12;
const BUTTON_SELECT: u32 = 13;
<span class="boring">}</span></code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“C/C++”}}</p>
<pre><code class="language-c">// Button constants
#define EWZX_BUTTON_UP 0
#define EWZX_BUTTON_DOWN 1
#define EWZX_BUTTON_LEFT 2
#define EWZX_BUTTON_RIGHT 3
#define EWZX_BUTTON_A 4
#define EWZX_BUTTON_B 5
#define EWZX_BUTTON_X 6
#define EWZX_BUTTON_Y 7
#define EWZX_BUTTON_LB 8
#define EWZX_BUTTON_RB 9
#define EWZX_BUTTON_START 12
#define EWZX_BUTTON_SELECT 13
</code></pre>
<p>{{#endtab}}</p>
<p>{{#tab name=“Zig”}}</p>
<pre><code class="language-zig">// Button constants
const Button = struct {
    pub const up: u32 = 0;
    pub const down: u32 = 1;
    pub const left: u32 = 2;
    pub const right: u32 = 3;
    pub const a: u32 = 4;
    pub const b: u32 = 5;
    pub const x: u32 = 6;
    pub const y: u32 = 7;
    pub const lb: u32 = 8;
    pub const rb: u32 = 9;
    pub const start: u32 = 12;
    pub const select: u32 = 13;
};
</code></pre>
<p>{{#endtab}}</p>
<p>{{#endtabs}}</p>
<div style="break-before: page; page-break-before: always;"></div>
<h1 id="example-games"><a class="header" href="#example-games">Example Games</a></h1>
<p>The Nethercore repository includes 28+ example games organized by category. Each example is a complete, buildable project.</p>
<h2 id="location"><a class="header" href="#location">Location</a></h2>
<pre><code>nethercore/examples/
</code></pre>
<h2 id="learning-path"><a class="header" href="#learning-path">Learning Path</a></h2>
<p>New to Nethercore? Follow this progression:</p>
<ol>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/hello-world">hello-world</a></strong> - 2D text and rectangles, basic input</li>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/triangle">triangle</a></strong> - Your first 3D shape</li>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/textured-quad">textured-quad</a></strong> - Loading and applying textures</li>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/cube">cube</a></strong> - Transforms and rotation</li>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/paddle">paddle</a></strong> - Complete game with the <a href="#build-paddle">tutorial</a></li>
<li><strong><a href="https://github.com/nethercore/nethercore/tree/main/examples/platformer">platformer</a></strong> - Advanced example with physics, billboards, UI</li>
</ol>
<h2 id="by-category"><a class="header" href="#by-category">By Category</a></h2>
<h3 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>hello-world</strong></td><td>Basic 2D drawing, text, input handling</td></tr>
<tr><td><strong>triangle</strong></td><td>Minimal 3D rendering</td></tr>
<tr><td><strong>textured-quad</strong></td><td>Texture loading and binding</td></tr>
<tr><td><strong>cube</strong></td><td>Rotating textured cube with transforms</td></tr>
</tbody>
</table>
</div>
<h3 id="graphics--rendering"><a class="header" href="#graphics--rendering">Graphics &amp; Rendering</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>lighting</strong></td><td>PBR rendering with 4 dynamic lights</td></tr>
<tr><td><strong>blinn-phong</strong></td><td>Classic specular and rim lighting</td></tr>
<tr><td><strong>billboard</strong></td><td>GPU-instanced billboards</td></tr>
<tr><td><strong>procedural-shapes</strong></td><td>Built-in mesh generators</td></tr>
<tr><td><strong>textured-procedural</strong></td><td>Textured procedural meshes</td></tr>
<tr><td><strong>dither-demo</strong></td><td>PS1-style dithering effects</td></tr>
<tr><td><strong>material-override</strong></td><td>Per-draw material properties</td></tr>
</tbody>
</table>
</div>
<h3 id="render-mode-inspectors"><a class="header" href="#render-mode-inspectors">Render Mode Inspectors</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>mode0-inspector</strong></td><td>Interactive Mode 0 (Unlit) explorer</td></tr>
<tr><td><strong>mode1-inspector</strong></td><td>Interactive Mode 1 (Matcap) explorer</td></tr>
<tr><td><strong>mode2-inspector</strong></td><td>Interactive Mode 2 (PBR) explorer</td></tr>
<tr><td><strong>mode3-inspector</strong></td><td>Interactive Mode 3 (Hybrid) explorer</td></tr>
</tbody>
</table>
</div>
<h3 id="animation--skinning"><a class="header" href="#animation--skinning">Animation &amp; Skinning</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>skinned-mesh</strong></td><td>GPU skeletal animation basics</td></tr>
<tr><td><strong>animation-demo</strong></td><td>Keyframe playback from ROM</td></tr>
<tr><td><strong>ik-demo</strong></td><td>Inverse kinematics</td></tr>
<tr><td><strong>multi-skinned-procedural</strong></td><td>Multiple animated characters</td></tr>
<tr><td><strong>multi-skinned-rom</strong></td><td>ROM-based animation data</td></tr>
<tr><td><strong>skeleton-stress-test</strong></td><td>Performance testing</td></tr>
</tbody>
</table>
</div>
<h3 id="complete-games"><a class="header" href="#complete-games">Complete Games</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>paddle</strong></td><td>Classic 2-player game with AI</td></tr>
<tr><td><strong>platformer</strong></td><td>Full mini-game with physics, UI, multiplayer</td></tr>
</tbody>
</table>
</div>
<h3 id="audio-2"><a class="header" href="#audio-2">Audio</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>audio-demo</strong></td><td>Sound effects, panning, channels</td></tr>
</tbody>
</table>
</div>
<h3 id="asset-loading-1"><a class="header" href="#asset-loading-1">Asset Loading</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>datapack-demo</strong></td><td>ROM asset workflow</td></tr>
<tr><td><strong>font-demo</strong></td><td>Custom font loading</td></tr>
<tr><td><strong>level-loader</strong></td><td>Level data from ROM</td></tr>
<tr><td><strong>asset-test</strong></td><td>Pre-converted asset testing</td></tr>
</tbody>
</table>
</div>
<h3 id="development-tools"><a class="header" href="#development-tools">Development Tools</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>debug-demo</strong></td><td>Debug inspection system</td></tr>
</tbody>
</table>
</div>
<h3 id="shared-libraries"><a class="header" href="#shared-libraries">Shared Libraries</a></h3>
<div class="table-wrapper">
<table>
<thead>
<tr><th>Example</th><th>Description</th></tr>
</thead>
<tbody>
<tr><td><strong>examples-common</strong></td><td>Reusable utilities (DebugCamera, math helpers)</td></tr>
</tbody>
</table>
</div>
<h2 id="building-examples"><a class="header" href="#building-examples">Building Examples</a></h2>
<p>Each example is a standalone Cargo project:</p>
<pre><code class="language-bash">cd examples/paddle
cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
</code></pre>
<p>Or build all examples:</p>
<pre><code class="language-bash">cargo xtask build-examples
</code></pre>
<h2 id="example-structure"><a class="header" href="#example-structure">Example Structure</a></h2>
<p>All examples follow this pattern:</p>
<pre><code>example-name/
├── Cargo.toml      # Project config
├── nether.toml      # Game manifest (optional)
├── src/
│   └── lib.rs      # Game code
└── assets/         # Assets (if needed)
</code></pre>
<h2 id="learning-by-reading-code"><a class="header" href="#learning-by-reading-code">Learning by Reading Code</a></h2>
<p>Each example includes comments explaining key concepts:</p>
<pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>//! Example Name
//!
//! Description of what this example demonstrates.
//!
//! Controls:
//! - ...
//!
//! Note: Rollback state is automatic.
<span class="boring">}</span></code></pre>
<p>Browse the source on GitHub or read locally in your clone.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <template id=fa-eye><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M288 32c-80.8 0-145.5 36.8-192.6 80.6C48.6 156 17.3 208 2.5 243.7c-3.3 7.9-3.3 16.7 0 24.6C17.3 304 48.6 356 95.4 399.4C142.5 443.2 207.2 480 288 480s145.5-36.8 192.6-80.6c46.8-43.5 78.1-95.4 93-131.1c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C433.5 68.8 368.8 32 288 32zM432 256c0 79.5-64.5 144-144 144s-144-64.5-144-144s64.5-144 144-144s144 64.5 144 144zM288 192c0 35.3-28.7 64-64 64c-11.5 0-22.3-3-31.6-8.4c-.2 2.8-.4 5.5-.4 8.4c0 53 43 96 96 96s96-43 96-96s-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6z"/></svg></span></template>
        <template id=fa-eye-slash><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M38.8 5.1C28.4-3.1 13.3-1.2 5.1 9.2S-1.2 34.7 9.2 42.9l592 464c10.4 8.2 25.5 6.3 33.7-4.1s6.3-25.5-4.1-33.7L525.6 386.7c39.6-40.6 66.4-86.1 79.9-118.4c3.3-7.9 3.3-16.7 0-24.6c-14.9-35.7-46.2-87.7-93-131.1C465.5 68.8 400.8 32 320 32c-68.2 0-125 26.3-169.3 60.8L38.8 5.1zM223.1 149.5C248.6 126.2 282.7 112 320 112c79.5 0 144 64.5 144 144c0 24.9-6.3 48.3-17.4 68.7L408 294.5c5.2-11.8 8-24.8 8-38.5c0-53-43-96-96-96c-2.8 0-5.6 .1-8.4 .4c5.3 9.3 8.4 20.1 8.4 31.6c0 10.2-2.4 19.8-6.6 28.3l-90.3-70.8zm223.1 298L373 389.9c-16.4 6.5-34.3 10.1-53 10.1c-79.5 0-144-64.5-144-144c0-6.9 .5-13.6 1.4-20.2L83.1 161.5C60.3 191.2 44 220.8 34.5 243.7c-3.3 7.9-3.3 16.7 0 24.6c14.9 35.7 46.2 87.7 93 131.1C174.5 443.2 239.2 480 320 480c47.8 0 89.9-12.9 126.2-32.5z"/></svg></span></template>
        <template id=fa-copy><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M502.6 70.63l-61.25-61.25C435.4 3.371 427.2 0 418.7 0H255.1c-35.35 0-64 28.66-64 64l.0195 256C192 355.4 220.7 384 256 384h192c35.2 0 64-28.8 64-64V93.25C512 84.77 508.6 76.63 502.6 70.63zM464 320c0 8.836-7.164 16-16 16H255.1c-8.838 0-16-7.164-16-16L239.1 64.13c0-8.836 7.164-16 16-16h128L384 96c0 17.67 14.33 32 32 32h47.1V320zM272 448c0 8.836-7.164 16-16 16H63.1c-8.838 0-16-7.164-16-16L47.98 192.1c0-8.836 7.164-16 16-16H160V128H63.99c-35.35 0-64 28.65-64 64l.0098 256C.002 483.3 28.66 512 64 512h192c35.2 0 64-28.8 64-64v-32h-47.1L272 448z"/></svg></span></template>
        <template id=fa-play><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M73 39c-14.8-9.1-33.4-9.4-48.5-.9S0 62.6 0 80V432c0 17.4 9.4 33.4 24.5 41.9s33.7 8.1 48.5-.9L361 297c14.3-8.7 23-24.2 23-41s-8.7-32.2-23-41L73 39z"/></svg></span></template>
        <template id=fa-clock-rotate-left><span class=fa-svg><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!--! Font Awesome Free 6.2.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2022 Fonticons, Inc. --><path d="M75 75L41 41C25.9 25.9 0 36.6 0 57.9V168c0 13.3 10.7 24 24 24H134.1c21.4 0 32.1-25.9 17-41l-30.8-30.8C155 85.5 203 64 256 64c106 0 192 86 192 192s-86 192-192 192c-40.8 0-78.6-12.7-109.7-34.4c-14.5-10.1-34.4-6.6-44.6 7.9s-6.6 34.4 7.9 44.6C151.2 495 201.7 512 256 512c141.4 0 256-114.6 256-256S397.4 0 256 0C185.3 0 121.3 28.7 75 75zm181 53c-13.3 0-24 10.7-24 24V256c0 6.4 2.5 12.5 7 17l72 72c9.4 9.4 24.6 9.4 33.9 0s9.4-24.6 0-33.9l-65-65V152c0-13.3-10.7-24-24-24z"/></svg></span></template>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr-ef4e11c1.min.js"></script>
        <script src="mark-09e88c2c.min.js"></script>
        <script src="searcher-c2a407aa.js"></script>

        <script src="clipboard-1626706a.min.js"></script>
        <script src="highlight-abc7f01d.js"></script>
        <script src="book-a0b12cfe.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>


    </div>
    </body>
</html>
