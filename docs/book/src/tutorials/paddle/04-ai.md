# Part 4: AI Opponent

Let's add an AI opponent so single players can enjoy the game.

## What You'll Learn

- Simple AI that follows the ball
- Checking player count with `player_count()`
- Making AI beatable (not perfect)

## Add Player Count FFI

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...
    fn player_count() -> u32;
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
// Add to your imports
NCZX_IMPORT uint32_t player_count(void);
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
// Add to your imports
pub extern fn player_count() u32;
```
{{#endtab}}

{{#endtabs}}

## Track Game Mode

Add a state variable to track whether we're in two-player mode:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
static mut IS_TWO_PLAYER: bool = false;
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
static bool is_two_player = false;
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
var is_two_player: bool = false;
```
{{#endtab}}

{{#endtabs}}

## Simple AI Logic

Create an AI update function:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
fn update_ai(paddle_y: &mut f32) {
    unsafe {
        // AI follows the ball
        let paddle_center = *paddle_y + PADDLE_HEIGHT / 2.0;
        let ball_center = BALL_Y + BALL_SIZE / 2.0;

        let diff = ball_center - paddle_center;

        // Only move if difference is significant (dead zone)
        if diff.abs() > 5.0 {
            // AI moves slower than max speed to be beatable
            let ai_speed = PADDLE_SPEED * 0.7;

            if diff > 0.0 {
                *paddle_y += ai_speed;
            } else {
                *paddle_y -= ai_speed;
            }
        }

        // Clamp to screen bounds
        *paddle_y = clamp(*paddle_y, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
    }
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
void update_ai(float* paddle_y) {
    // AI follows the ball
    float paddle_center = *paddle_y + PADDLE_HEIGHT / 2.0f;
    float ball_center = ball_y + BALL_SIZE / 2.0f;

    float diff = ball_center - paddle_center;

    // Only move if difference is significant (dead zone)
    if (fabsf(diff) > 5.0f) {
        // AI moves slower than max speed to be beatable
        float ai_speed = PADDLE_SPEED * 0.7f;

        if (diff > 0.0f) {
            *paddle_y += ai_speed;
        } else {
            *paddle_y -= ai_speed;
        }
    }

    // Clamp to screen bounds
    *paddle_y = clamp(*paddle_y, 0.0f, SCREEN_HEIGHT - PADDLE_HEIGHT);
}
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
fn updateAi(paddle_y: *f32) void {
    // AI follows the ball
    const paddle_center = paddle_y.* + PADDLE_HEIGHT / 2.0;
    const ball_center = ball_y + BALL_SIZE / 2.0;

    const diff = ball_center - paddle_center;

    // Only move if difference is significant (dead zone)
    if (@abs(diff) > 5.0) {
        // AI moves slower than max speed to be beatable
        const ai_speed = PADDLE_SPEED * 0.7;

        if (diff > 0.0) {
            paddle_y.* += ai_speed;
        } else {
            paddle_y.* -= ai_speed;
        }
    }

    // Clamp to screen bounds
    paddle_y.* = clamp(paddle_y.*, 0.0, SCREEN_HEIGHT - PADDLE_HEIGHT);
}
```
{{#endtab}}

{{#endtabs}}

You'll also need this helper:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
fn abs(v: f32) -> f32 {
    if v < 0.0 { -v } else { v }
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
// Use fabsf() from math.h (already shown in update_ai above)
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
// Use @abs() builtin (already shown in updateAi above)
```
{{#endtab}}

{{#endtabs}}

## Update the Game Loop

Modify `update()` to use AI when appropriate:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
#[no_mangle]
pub extern "C" fn update() {
    unsafe {
        // Check if a second player is connected
        IS_TWO_PLAYER = player_count() >= 2;

        // Player 1 always uses input
        update_paddle(&mut PADDLE1_Y, 0);

        // Player 2: human or AI
        if IS_TWO_PLAYER {
            update_paddle(&mut PADDLE2_Y, 1);
        } else {
            update_ai(&mut PADDLE2_Y);
        }

        update_ball();
    }
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
NCZX_EXPORT void update(void) {
    // Check if a second player is connected
    is_two_player = player_count() >= 2;

    // Player 1 always uses input
    update_paddle(&paddle1_y, 0);

    // Player 2: human or AI
    if (is_two_player) {
        update_paddle(&paddle2_y, 1);
    } else {
        update_ai(&paddle2_y);
    }

    update_ball();
}
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
export fn update() void {
    // Check if a second player is connected
    is_two_player = player_count() >= 2;

    // Player 1 always uses input
    updatePaddle(&paddle1_y, 0);

    // Player 2: human or AI
    if (is_two_player) {
        updatePaddle(&paddle2_y, 1);
    } else {
        updateAi(&paddle2_y);
    }

    updateBall();
}
```
{{#endtab}}

{{#endtabs}}

## Show Game Mode

Let's display the current mode. Add text FFI:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
#[link(wasm_import_module = "env")]
extern "C" {
    // ... existing imports ...
    fn set_color(color: u32);
    fn draw_text(ptr: *const u8, len: u32, x: f32, y: f32, size: f32);
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
// Add to your imports
NCZX_IMPORT void set_color(uint32_t color);
NCZX_IMPORT void draw_text(const uint8_t* ptr, uint32_t len, float x, float y, float size);
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
// Add to your imports
pub extern fn set_color(color: u32) void;
pub extern fn draw_text(ptr: [*]const u8, len: u32, x: f32, y: f32, size: f32) void;
```
{{#endtab}}

{{#endtabs}}

Add to `render()`:

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
#[no_mangle]
pub extern "C" fn render() {
    unsafe {
        // ... existing drawing code ...

        // Show mode indicator
        set_color(COLOR_GRAY);
        if IS_TWO_PLAYER {
            let text = b"2 PLAYERS";
            draw_text(text.as_ptr(), text.len() as u32, 10.0, 10.0, 16.0);
        } else {
            let text = b"vs AI";
            draw_text(text.as_ptr(), text.len() as u32, 10.0, 10.0, 16.0);
        }
    }
}
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
NCZX_EXPORT void render(void) {
    // ... existing drawing code ...

    // Show mode indicator
    set_color(COLOR_GRAY);
    if (is_two_player) {
        draw_text((uint8_t*)"2 PLAYERS", 9, 10.0f, 10.0f, 16.0f);
    } else {
        draw_text((uint8_t*)"vs AI", 5, 10.0f, 10.0f, 16.0f);
    }
}
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
export fn render() void {
    // ... existing drawing code ...

    // Show mode indicator
    set_color(COLOR_GRAY);
    if (is_two_player) {
        draw_text("2 PLAYERS", 9, 10.0, 10.0, 16.0);
    } else {
        draw_text("vs AI", 5, 10.0, 10.0, 16.0);
    }
}
```
{{#endtab}}

{{#endtabs}}

## How the AI Works

The AI is intentionally imperfect:

1. **Follows the ball** - Moves toward where the ball is
2. **Slower speed** - Only 70% of max paddle speed
3. **Dead zone** - Doesn't jitter when ball is near center
4. **No prediction** - Doesn't anticipate where ball will go

This makes the AI beatable but still challenging.

### Making AI Harder or Easier

{{#tabs global="lang"}}

{{#tab name="Rust"}}
```rust
// Easier AI (50% speed)
let ai_speed = PADDLE_SPEED * 0.5;

// Harder AI (90% speed)
let ai_speed = PADDLE_SPEED * 0.9;

// Perfect AI (instant tracking) - not fun!
*paddle_y = ball_center - PADDLE_HEIGHT / 2.0;
```
{{#endtab}}

{{#tab name="C/C++"}}
```c
// Easier AI (50% speed)
float ai_speed = PADDLE_SPEED * 0.5f;

// Harder AI (90% speed)
float ai_speed = PADDLE_SPEED * 0.9f;

// Perfect AI (instant tracking) - not fun!
*paddle_y = ball_center - PADDLE_HEIGHT / 2.0f;
```
{{#endtab}}

{{#tab name="Zig"}}
```zig
// Easier AI (50% speed)
const ai_speed = PADDLE_SPEED * 0.5;

// Harder AI (90% speed)
const ai_speed = PADDLE_SPEED * 0.9;

// Perfect AI (instant tracking) - not fun!
paddle_y.* = ball_center - PADDLE_HEIGHT / 2.0;
```
{{#endtab}}

{{#endtabs}}

## The Magic: Automatic Multiplayer

Here's the key insight: **when a second player connects, the game automatically becomes two-player**. You don't need to do anything special!

This works because:
1. We check `player_count()` every frame
2. Player 2 input is always read (even if unused)
3. The switch from AI to human is seamless

When a friend joins your game online via Nethercore's netcode, `player_count()` increases and they take control of paddle 2.

## Build and Test

```bash
cargo build --target wasm32-unknown-unknown --release
nether run target/wasm32-unknown-unknown/release/paddle.wasm
```

With one controller:
- You control player 1
- AI controls player 2
- "vs AI" appears in corner

Connect a second controller:
- Both players are human
- "2 PLAYERS" appears

---

**Next:** [Part 5: Multiplayer](./05-multiplayer.md) - Understanding the rollback netcode magic.
