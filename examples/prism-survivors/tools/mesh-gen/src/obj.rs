//! OBJ file writer for procedural mesh generation
//!
//! Generates Wavefront OBJ files that can be processed by nether-export.

use std::io::Write;
use std::path::Path;

/// Simple OBJ file writer
pub struct ObjWriter {
    vertices: Vec<[f32; 3]>,
    uvs: Vec<[f32; 2]>,
    normals: Vec<[f32; 3]>,
    /// Face indices: (vertex, uv, normal) - all 1-indexed
    faces: Vec<(u32, u32, u32)>,
}

impl ObjWriter {
    pub fn new() -> Self {
        Self {
            vertices: Vec::new(),
            uvs: Vec::new(),
            normals: Vec::new(),
            faces: Vec::new(),
        }
    }

    /// Add a vertex position
    pub fn vertex(&mut self, x: f32, y: f32, z: f32) -> u32 {
        self.vertices.push([x, y, z]);
        self.vertices.len() as u32 // 1-indexed
    }

    /// Add a UV coordinate
    pub fn uv(&mut self, u: f32, v: f32) -> u32 {
        self.uvs.push([u, v]);
        self.uvs.len() as u32 // 1-indexed
    }

    /// Add a normal vector
    pub fn normal(&mut self, x: f32, y: f32, z: f32) -> u32 {
        self.normals.push([x, y, z]);
        self.normals.len() as u32 // 1-indexed
    }

    /// Add a face vertex with position, UV, and normal indices (1-indexed)
    pub fn face_vtn(&mut self, v: u32, vt: u32, vn: u32) {
        self.faces.push((v, vt, vn));
    }

    /// Add a face vertex with just position index (1-indexed)
    pub fn face_v(&mut self, v: u32) {
        self.faces.push((v, 0, 0));
    }

    /// Write the OBJ file to disk
    pub fn write_to_file(&self, path: &Path) -> std::io::Result<()> {
        let mut file = std::fs::File::create(path)?;

        writeln!(file, "# Generated by PRISM SURVIVORS mesh-gen")?;
        writeln!(file, "# Vertices: {}", self.vertices.len())?;
        writeln!(file, "# Faces: {}", self.faces.len() / 3)?;
        writeln!(file)?;

        // Write vertices
        for v in &self.vertices {
            writeln!(file, "v {} {} {}", v[0], v[1], v[2])?;
        }
        writeln!(file)?;

        // Write UVs
        for uv in &self.uvs {
            writeln!(file, "vt {} {}", uv[0], uv[1])?;
        }
        writeln!(file)?;

        // Write normals
        for n in &self.normals {
            writeln!(file, "vn {} {} {}", n[0], n[1], n[2])?;
        }
        writeln!(file)?;

        // Write faces (triangles)
        for chunk in self.faces.chunks(3) {
            if chunk.len() == 3 {
                let (v1, vt1, vn1) = chunk[0];
                let (v2, vt2, vn2) = chunk[1];
                let (v3, vt3, vn3) = chunk[2];

                if vt1 > 0 && vn1 > 0 {
                    // v/vt/vn format
                    writeln!(
                        file,
                        "f {}/{}/{} {}/{}/{} {}/{}/{}",
                        v1, vt1, vn1, v2, vt2, vn2, v3, vt3, vn3
                    )?;
                } else if vn1 > 0 {
                    // v//vn format
                    writeln!(
                        file,
                        "f {}//{} {}//{} {}//{}",
                        v1, vn1, v2, vn2, v3, vn3
                    )?;
                } else {
                    // v format
                    writeln!(file, "f {} {} {}", v1, v2, v3)?;
                }
            }
        }

        Ok(())
    }

    /// Get vertex count
    pub fn vertex_count(&self) -> usize {
        self.vertices.len()
    }

    /// Get face count (triangles)
    pub fn face_count(&self) -> usize {
        self.faces.len() / 3
    }
}

impl Default for ObjWriter {
    fn default() -> Self {
        Self::new()
    }
}

// === Mesh generation utilities ===

/// Generate a unit cube centered at origin
pub fn generate_cube(obj: &mut ObjWriter, size: f32) {
    let s = size / 2.0;

    // 8 vertices
    let v1 = obj.vertex(-s, -s,  s);
    let v2 = obj.vertex( s, -s,  s);
    let v3 = obj.vertex( s,  s,  s);
    let v4 = obj.vertex(-s,  s,  s);
    let v5 = obj.vertex(-s, -s, -s);
    let v6 = obj.vertex( s, -s, -s);
    let v7 = obj.vertex( s,  s, -s);
    let v8 = obj.vertex(-s,  s, -s);

    // 4 UVs
    let uv1 = obj.uv(0.0, 0.0);
    let uv2 = obj.uv(1.0, 0.0);
    let uv3 = obj.uv(1.0, 1.0);
    let uv4 = obj.uv(0.0, 1.0);

    // 6 normals
    let n_front = obj.normal(0.0, 0.0, 1.0);
    let n_back = obj.normal(0.0, 0.0, -1.0);
    let n_right = obj.normal(1.0, 0.0, 0.0);
    let n_left = obj.normal(-1.0, 0.0, 0.0);
    let n_top = obj.normal(0.0, 1.0, 0.0);
    let n_bottom = obj.normal(0.0, -1.0, 0.0);

    // Front face
    obj.face_vtn(v1, uv1, n_front);
    obj.face_vtn(v2, uv2, n_front);
    obj.face_vtn(v3, uv3, n_front);
    obj.face_vtn(v1, uv1, n_front);
    obj.face_vtn(v3, uv3, n_front);
    obj.face_vtn(v4, uv4, n_front);

    // Back face
    obj.face_vtn(v6, uv1, n_back);
    obj.face_vtn(v5, uv2, n_back);
    obj.face_vtn(v8, uv3, n_back);
    obj.face_vtn(v6, uv1, n_back);
    obj.face_vtn(v8, uv3, n_back);
    obj.face_vtn(v7, uv4, n_back);

    // Right face
    obj.face_vtn(v2, uv1, n_right);
    obj.face_vtn(v6, uv2, n_right);
    obj.face_vtn(v7, uv3, n_right);
    obj.face_vtn(v2, uv1, n_right);
    obj.face_vtn(v7, uv3, n_right);
    obj.face_vtn(v3, uv4, n_right);

    // Left face
    obj.face_vtn(v5, uv1, n_left);
    obj.face_vtn(v1, uv2, n_left);
    obj.face_vtn(v4, uv3, n_left);
    obj.face_vtn(v5, uv1, n_left);
    obj.face_vtn(v4, uv3, n_left);
    obj.face_vtn(v8, uv4, n_left);

    // Top face
    obj.face_vtn(v4, uv1, n_top);
    obj.face_vtn(v3, uv2, n_top);
    obj.face_vtn(v7, uv3, n_top);
    obj.face_vtn(v4, uv1, n_top);
    obj.face_vtn(v7, uv3, n_top);
    obj.face_vtn(v8, uv4, n_top);

    // Bottom face
    obj.face_vtn(v5, uv1, n_bottom);
    obj.face_vtn(v6, uv2, n_bottom);
    obj.face_vtn(v2, uv3, n_bottom);
    obj.face_vtn(v5, uv1, n_bottom);
    obj.face_vtn(v2, uv3, n_bottom);
    obj.face_vtn(v1, uv4, n_bottom);
}

/// Generate a UV sphere
pub fn generate_sphere(obj: &mut ObjWriter, radius: f32, segments: u32, rings: u32) {
    let base_v = obj.vertex_count() as u32;
    let base_vt = obj.uvs.len() as u32;
    let base_vn = obj.normals.len() as u32;

    // Generate vertices, UVs, and normals
    for j in 0..=rings {
        let v_angle = std::f32::consts::PI * (j as f32 / rings as f32);
        let y = radius * v_angle.cos();
        let ring_radius = radius * v_angle.sin();

        for i in 0..=segments {
            let u_angle = 2.0 * std::f32::consts::PI * (i as f32 / segments as f32);
            let x = ring_radius * u_angle.cos();
            let z = ring_radius * u_angle.sin();

            obj.vertex(x, y, z);

            // UV
            let u = i as f32 / segments as f32;
            let v = j as f32 / rings as f32;
            obj.uv(u, v);

            // Normal (normalized position for sphere)
            let len = (x * x + y * y + z * z).sqrt();
            obj.normal(x / len, y / len, z / len);
        }
    }

    // Generate faces
    for j in 0..rings {
        for i in 0..segments {
            let row1 = j * (segments + 1);
            let row2 = (j + 1) * (segments + 1);

            let v1 = base_v + row1 + i + 1;
            let v2 = base_v + row1 + i + 1 + 1;
            let v3 = base_v + row2 + i + 1;
            let v4 = base_v + row2 + i + 1 + 1;

            let vt1 = base_vt + row1 + i + 1;
            let vt2 = base_vt + row1 + i + 1 + 1;
            let vt3 = base_vt + row2 + i + 1;
            let vt4 = base_vt + row2 + i + 1 + 1;

            let vn1 = base_vn + row1 + i + 1;
            let vn2 = base_vn + row1 + i + 1 + 1;
            let vn3 = base_vn + row2 + i + 1;
            let vn4 = base_vn + row2 + i + 1 + 1;

            // Two triangles per quad
            obj.face_vtn(v1, vt1, vn1);
            obj.face_vtn(v3, vt3, vn3);
            obj.face_vtn(v2, vt2, vn2);

            obj.face_vtn(v2, vt2, vn2);
            obj.face_vtn(v3, vt3, vn3);
            obj.face_vtn(v4, vt4, vn4);
        }
    }
}
