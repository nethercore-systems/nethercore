//! Generation of `generated_shaders.rs` written into OUT_DIR.

use super::{common_extract, formats, generator};

pub(crate) struct GeneratedShaders {
    pub(crate) rust: String,
    pub(crate) shader_count: usize,
}

const GET_PREGENERATED_SHADER_FN: &str = r#"/// Get pregenerated shader source by mode and format
/// Returns None if the mode/format combination is invalid
#[allow(clippy::manual_range_contains)]
pub fn get_pregenerated_shader(mode: u8, format: u8) -> Option<&'static str> {
    const FORMAT_NORMAL: u8 = 4;
    const FORMAT_SKINNED: u8 = 8;
    const FORMAT_TANGENT: u8 = 16;

    // Validate mode/format combination
    if mode > 3 {
        return None;
    }
    if format >= 32 {
        return None; // Invalid format
    }
    if mode > 0 && format & FORMAT_NORMAL == 0 {
        return None; // Modes 1-3 require NORMAL
    }
    if format & FORMAT_TANGENT != 0 && format & FORMAT_NORMAL == 0 {
        return None; // TANGENT requires NORMAL
    }

    // Index calculation:
    // Mode 0: 24 formats (0-15, 20-23, 28-31)
    //   - 0-15: indices 0-15
    //   - 20-23: indices 16-19
    //   - 28-31: indices 20-23
    // Modes 1-3: 16 formats each (4-7, 12-15, 20-23, 28-31)
    //   - Map format to 0-15 offset: (UV + COLOR*2) + SKINNED*4 + TANGENT*8
    let index = match mode {
        0 => {
            // Mode 0: direct index for 0-15, offset for tangent variants
            if format < 16 {
                format as usize
            } else if format >= 20 && format <= 23 {
                16 + (format - 20) as usize // tangent+normal (no skinned)
            } else if format >= 28 && format <= 31 {
                20 + (format - 28) as usize // tangent+normal+skinned
            } else {
                return None; // Invalid format for mode 0
            }
        }
        1 => {
            let base = 24usize; // After mode 0's 24 shaders
            let offset = (format & 0b0011) as usize
                + if format & FORMAT_SKINNED != 0 { 4 } else { 0 }
                + if format & FORMAT_TANGENT != 0 { 8 } else { 0 };
            base + offset
        }
        2 => {
            let base = 24 + 16; // After mode 0 and mode 1
            let offset = (format & 0b0011) as usize
                + if format & FORMAT_SKINNED != 0 { 4 } else { 0 }
                + if format & FORMAT_TANGENT != 0 { 8 } else { 0 };
            base + offset
        }
        3 => {
            let base = 24 + 16 + 16; // After mode 0, 1, and 2
            let offset = (format & 0b0011) as usize
                + if format & FORMAT_SKINNED != 0 { 4 } else { 0 }
                + if format & FORMAT_TANGENT != 0 { 8 } else { 0 };
            base + offset
        }
        _ => return None,
    };

    Some(PREGENERATED_SHADERS[index])
}
"#;

pub(crate) fn generate() -> Result<GeneratedShaders, Vec<String>> {
    let mut generated_code = String::new();
    generated_code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    generated_code
        .push_str("// Contains all 72 pregenerated shader permutations (with tangent support)\n\n");

    // Generate array of 72 shader sources
    // Mode 0: 24 formats (0-15, 20-23, 28-31), Modes 1-3: 16 formats each = 24 + 16*3 = 72
    generated_code
        .push_str("/// Pregenerated shader sources indexed by shader_index(mode, format)\n");
    generated_code.push_str("pub const PREGENERATED_SHADERS: [&str; 72] = [\n");

    let mut shader_count = 0usize;
    let mut errors: Vec<String> = Vec::new();

    // Mode 0: valid formats (0-15, 20-23, 28-31) - tangent requires normal
    for format in formats::valid_formats_for_mode(0) {
        match generator::generate_shader(0, format) {
            Ok(source) => {
                if let Err(e) = generator::validate_shader(&source, 0, format) {
                    errors.push(e);
                }
                generated_code.push_str(&format!("    // Mode 0, Format {}\n", format));
                generated_code.push_str(&format!("    r#\"{}\"#,\n", source));
                shader_count += 1;
            }
            Err(e) => errors.push(e),
        }
    }

    // Modes 1-3: only formats with NORMAL (4-7, 12-15, 20-23, 28-31)
    for mode in 1u8..=3 {
        for format in formats::valid_formats_for_mode(mode) {
            match generator::generate_shader(mode, format) {
                Ok(source) => {
                    if let Err(e) = generator::validate_shader(&source, mode, format) {
                        errors.push(e);
                    }
                    generated_code.push_str(&format!("    // Mode {}, Format {}\n", mode, format));
                    generated_code.push_str(&format!("    r#\"{}\"#,\n", source));
                    shader_count += 1;
                }
                Err(e) => errors.push(e),
            }
        }
    }

    generated_code.push_str("];\n\n");

    // Generate index lookup function
    generated_code.push_str(GET_PREGENERATED_SHADER_FN);

    // Generate environment shader
    let environment_shader = common_extract::generate_environment_shader();
    if let Err(e) = generator::validate_shader_generic(&environment_shader, "environment") {
        errors.push(e);
    }
    generated_code.push_str("\n/// Generated environment shader source\n");
    generated_code.push_str(&format!(
        "pub const ENVIRONMENT_SHADER: &str = r#\"{}\"#;\n",
        environment_shader
    ));

    // Generate quad shader
    let quad_shader = common_extract::generate_quad_shader();
    if let Err(e) = generator::validate_shader_generic(&quad_shader, "quad_unlit") {
        errors.push(e);
    }
    generated_code.push_str("\n/// Generated quad unlit shader source\n");
    generated_code.push_str(&format!(
        "pub const QUAD_SHADER: &str = r#\"{}\"#;\n",
        quad_shader
    ));

    if !errors.is_empty() {
        return Err(errors);
    }

    Ok(GeneratedShaders {
        rust: generated_code,
        shader_count,
    })
}
