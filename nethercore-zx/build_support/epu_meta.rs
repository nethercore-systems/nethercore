//! EPU Metadata Code Generation
//!
//! Parses WGSL shader files and generates `epu_meta_gen.rs` with const/static
//! tables for the EPU debug panel.
//!
//! This module:
//! 1. Finds all WGSL opcode files in `shaders/epu/bounds/` and `shaders/epu/features/`
//! 2. Parses the `@epu_meta_begin`/`@epu_meta_end` blocks from each file
//! 3. Generates `src/debug/epu_meta_gen.rs` with const/static tables for runtime use

use std::collections::BTreeMap;
use std::fs;
use std::path::PathBuf;

use zx_common::wgsl_meta_parser::{MapKind, OpcodeKind, OpcodeMeta, parse_wgsl_meta};

/// Maximum number of opcodes supported (5-bit opcode = 0x00..0x1F)
const MAX_OPCODES: usize = 32;
/// Maximum number of fields per opcode
const MAX_FIELDS: usize = 8;

/// Run the EPU metadata code generation.
///
/// Returns the number of opcodes processed.
pub fn generate() -> usize {
    let manifest_dir = std::env::var("CARGO_MANIFEST_DIR").expect("CARGO_MANIFEST_DIR not set");
    let shader_base = PathBuf::from(&manifest_dir).join("shaders/epu");

    // Collect all WGSL files from bounds/ and features/
    let bounds_dir = shader_base.join("bounds");
    let features_dir = shader_base.join("features");

    let mut wgsl_files = Vec::new();

    // Collect bounds files
    if bounds_dir.exists() {
        for entry in fs::read_dir(&bounds_dir).expect("Failed to read bounds directory") {
            let entry = entry.expect("Failed to read directory entry");
            let path = entry.path();
            if path.extension().map(|e| e == "wgsl").unwrap_or(false) {
                println!("cargo:rerun-if-changed={}", path.display());
                wgsl_files.push(path);
            }
        }
    }

    // Collect features files
    if features_dir.exists() {
        for entry in fs::read_dir(&features_dir).expect("Failed to read features directory") {
            let entry = entry.expect("Failed to read directory entry");
            let path = entry.path();
            if path.extension().map(|e| e == "wgsl").unwrap_or(false) {
                println!("cargo:rerun-if-changed={}", path.display());
                wgsl_files.push(path);
            }
        }
    }

    if wgsl_files.is_empty() {
        panic!(
            "No WGSL files found in {} or {}\n\
             Expected opcode files with @epu_meta_begin/@epu_meta_end blocks",
            bounds_dir.display(),
            features_dir.display()
        );
    }

    // Parse all WGSL files and collect metadata
    let mut opcodes: BTreeMap<u8, OpcodeMeta> = BTreeMap::new();

    for path in &wgsl_files {
        let source = fs::read_to_string(path)
            .unwrap_or_else(|e| panic!("Failed to read {}: {}", path.display(), e));

        let path_str = path.to_string_lossy();
        let meta = parse_wgsl_meta(&source, &path_str);

        // Check for duplicate opcodes
        if let Some(existing) = opcodes.get(&meta.opcode) {
            panic!(
                "Duplicate opcode 0x{:02X} ({}):\n  First: {} in previous file\n  Second: {} in {}",
                meta.opcode, meta.opcode, existing.name, meta.name, path_str
            );
        }

        // Validate field count
        if meta.fields.len() > MAX_FIELDS {
            panic!(
                "Too many fields ({}) for opcode 0x{:02X} ({}) in {}\n\
                 Maximum allowed: {}",
                meta.fields.len(),
                meta.opcode,
                meta.name,
                path_str,
                MAX_FIELDS
            );
        }

        opcodes.insert(meta.opcode, meta);
    }

    let opcode_count = opcodes.len();

    // Generate Rust code
    let code = generate_code(&opcodes);

    // Write to src/debug/epu_meta_gen.rs
    let out_path = PathBuf::from(&manifest_dir).join("src/debug/epu_meta_gen.rs");

    // Ensure the debug directory exists
    if let Some(parent) = out_path.parent() {
        fs::create_dir_all(parent)
            .unwrap_or_else(|e| panic!("Failed to create directory {}: {}", parent.display(), e));
    }

    fs::write(&out_path, code)
        .unwrap_or_else(|e| panic!("Failed to write {}: {}", out_path.display(), e));

    opcode_count
}

/// Generate the Rust code for the epu_meta_gen module
fn generate_code(opcodes: &BTreeMap<u8, OpcodeMeta>) -> String {
    let mut code = String::new();

    // Header
    code.push_str("// Auto-generated by build.rs - DO NOT EDIT\n");
    code.push_str("// This file is generated from WGSL metadata blocks\n");
    code.push_str("//\n");
    code.push_str("// To regenerate, modify the @epu_meta_begin/@epu_meta_end blocks\n");
    code.push_str("// in shaders/epu/bounds/*.wgsl and shaders/epu/features/*.wgsl\n\n");

    // Suppress warnings for generated code
    code.push_str("#![allow(dead_code)]\n\n");

    // Count
    code.push_str("/// Total number of defined opcodes\n");
    code.push_str(&format!(
        "pub const OPCODE_COUNT: usize = {};\n\n",
        opcodes.len()
    ));

    // Maximum opcode value
    let max_opcode = opcodes.keys().max().copied().unwrap_or(0) as usize;
    code.push_str("/// Highest opcode number (for array sizing)\n");
    code.push_str(&format!(
        "pub const MAX_OPCODE: usize = {};\n\n",
        max_opcode
    ));

    // OpcodeKind enum
    code.push_str("/// Kind of EPU opcode\n");
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("#[repr(u8)]\n");
    code.push_str("pub enum OpcodeKind {\n");
    code.push_str("    /// Bounds opcode (defines regions)\n");
    code.push_str("    Bounds = 0,\n");
    code.push_str("    /// Radiance opcode (additive feature layer)\n");
    code.push_str("    Radiance = 1,\n");
    code.push_str("}\n\n");

    // MapKind enum
    code.push_str("/// Mapping types for field values\n");
    code.push_str("#[derive(Debug, Clone, Copy, PartialEq, Eq)]\n");
    code.push_str("#[repr(u8)]\n");
    code.push_str("pub enum MapKind {\n");
    code.push_str("    /// u8 mapped to 0.0..1.0\n");
    code.push_str("    U8_01 = 0,\n");
    code.push_str("    /// u8 mapped via linear interpolation between min..max\n");
    code.push_str("    U8Lerp = 1,\n");
    code.push_str("    /// u4 (nibble) mapped to 0.0..1.0\n");
    code.push_str("    U4_01 = 2,\n");
    code.push_str("    /// 16-bit octahedral direction encoding\n");
    code.push_str("    Dir16Oct = 3,\n");
    code.push_str("}\n\n");

    // OpcodeInfo struct
    code.push_str("/// Information about a single EPU opcode\n");
    code.push_str("#[derive(Debug, Clone, Copy)]\n");
    code.push_str("pub struct OpcodeInfo {\n");
    code.push_str("    /// Opcode number (0x00..0x1F)\n");
    code.push_str("    pub code: u8,\n");
    code.push_str("    /// Opcode name (e.g., \"PLANE\", \"RAMP\")\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    /// Opcode kind (bounds or radiance)\n");
    code.push_str("    pub kind: OpcodeKind,\n");
    code.push_str("}\n\n");

    // FieldSpec struct
    code.push_str("/// Specification for a single field in an EPU opcode\n");
    code.push_str("#[derive(Debug, Clone, Copy)]\n");
    code.push_str("pub struct FieldSpec {\n");
    code.push_str("    /// The raw field name (e.g., \"intensity\", \"param_a\")\n");
    code.push_str("    pub name: &'static str,\n");
    code.push_str("    /// Human-readable label for the UI\n");
    code.push_str("    pub label: &'static str,\n");
    code.push_str("    /// Optional unit string (e.g., \"x\", \"tangent\")\n");
    code.push_str("    pub unit: Option<&'static str>,\n");
    code.push_str("    /// Mapping type for the field value\n");
    code.push_str("    pub map: MapKind,\n");
    code.push_str("    /// Minimum value for u8_lerp mapping (0.0 for other mappings)\n");
    code.push_str("    pub min: f32,\n");
    code.push_str("    /// Maximum value for u8_lerp mapping (1.0 for other mappings)\n");
    code.push_str("    pub max: f32,\n");
    code.push_str("}\n\n");

    // OPCODES array - indexed by opcode number, with Option for missing opcodes
    code.push_str("/// Opcode info indexed by opcode number (None for undefined opcodes)\n");
    code.push_str(&format!(
        "pub static OPCODES: [Option<OpcodeInfo>; {}] = [\n",
        MAX_OPCODES
    ));
    for i in 0..MAX_OPCODES {
        if let Some(meta) = opcodes.get(&(i as u8)) {
            let kind_str = match meta.kind {
                OpcodeKind::Bounds => "OpcodeKind::Bounds",
                OpcodeKind::Radiance => "OpcodeKind::Radiance",
            };
            code.push_str(&format!(
                "    Some(OpcodeInfo {{ code: 0x{:02X}, name: \"{}\", kind: {} }}),\n",
                meta.opcode, meta.name, kind_str
            ));
        } else {
            code.push_str("    None,\n");
        }
    }
    code.push_str("];\n\n");

    // VARIANTS array - variant names per opcode (up to 8)
    code.push_str("/// Variant names per opcode (up to 8)\n");
    code.push_str(&format!(
        "pub static VARIANTS: [&[&str]; {}] = [\n",
        MAX_OPCODES
    ));
    for i in 0..MAX_OPCODES {
        if let Some(meta) = opcodes.get(&(i as u8)) {
            if meta.variants.is_empty() {
                code.push_str("    &[],\n");
            } else {
                let variants_str: Vec<String> =
                    meta.variants.iter().map(|v| format!("\"{}\"", v)).collect();
                code.push_str(&format!("    &[{}],\n", variants_str.join(", ")));
            }
        } else {
            code.push_str("    &[],\n");
        }
    }
    code.push_str("];\n\n");

    // DOMAINS array - domain names per opcode (up to 4)
    code.push_str("/// Domain names per opcode (up to 4)\n");
    code.push_str(&format!(
        "pub static DOMAINS: [&[&str]; {}] = [\n",
        MAX_OPCODES
    ));
    for i in 0..MAX_OPCODES {
        if let Some(meta) = opcodes.get(&(i as u8)) {
            if meta.domains.is_empty() {
                code.push_str("    &[],\n");
            } else {
                let domains_str: Vec<String> =
                    meta.domains.iter().map(|d| format!("\"{}\"", d)).collect();
                code.push_str(&format!("    &[{}],\n", domains_str.join(", ")));
            }
        } else {
            code.push_str("    &[],\n");
        }
    }
    code.push_str("];\n\n");

    // Generate static field spec arrays for each opcode
    for (opcode, meta) in opcodes.iter() {
        if !meta.fields.is_empty() {
            code.push_str(&format!(
                "static FIELDS_{:02X}: [FieldSpec; {}] = [\n",
                opcode,
                meta.fields.len()
            ));
            for field in &meta.fields {
                let map_kind = match field.map {
                    MapKind::U8_01 => "MapKind::U8_01",
                    MapKind::U8Lerp => "MapKind::U8Lerp",
                    MapKind::U4_01 => "MapKind::U4_01",
                    MapKind::Dir16Oct => "MapKind::Dir16Oct",
                };
                let unit_str = match &field.unit {
                    Some(u) => format!("Some(\"{}\")", u),
                    None => "None".to_string(),
                };
                let min_val = field.min.unwrap_or(0.0);
                let max_val = field.max.unwrap_or(1.0);
                code.push_str(&format!(
                    "    FieldSpec {{ name: \"{}\", label: \"{}\", unit: {}, map: {}, min: {:.6}, max: {:.6} }},\n",
                    field.field_name, field.label, unit_str, map_kind, min_val, max_val
                ));
            }
            code.push_str("];\n");
        }
    }
    code.push('\n');

    // FIELD_SPECS array - field specs per opcode
    code.push_str("/// Field specifications per opcode\n");
    code.push_str(&format!(
        "pub static FIELD_SPECS: [&[FieldSpec]; {}] = [\n",
        MAX_OPCODES
    ));
    for i in 0..MAX_OPCODES {
        if let Some(meta) = opcodes.get(&(i as u8)) {
            if meta.fields.is_empty() {
                code.push_str("    &[],\n");
            } else {
                code.push_str(&format!("    &FIELDS_{:02X},\n", i));
            }
        } else {
            code.push_str("    &[],\n");
        }
    }
    code.push_str("];\n\n");

    // Helper functions
    code.push_str(
        "// ============================================================================\n",
    );
    code.push_str("// Helper Functions\n");
    code.push_str(
        "// ============================================================================\n\n",
    );

    // opcode_name
    code.push_str("/// Get the name of an opcode, or \"UNKNOWN\" if undefined\n");
    code.push_str("#[inline]\n");
    code.push_str("pub const fn opcode_name(code: u8) -> &'static str {\n");
    code.push_str("    if code as usize >= OPCODES.len() {\n");
    code.push_str("        return \"UNKNOWN\";\n");
    code.push_str("    }\n");
    code.push_str("    match &OPCODES[code as usize] {\n");
    code.push_str("        Some(info) => info.name,\n");
    code.push_str("        None => \"UNKNOWN\",\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // opcode_kind
    code.push_str("/// Get the kind of an opcode, or None if undefined\n");
    code.push_str("#[inline]\n");
    code.push_str("pub const fn opcode_kind(code: u8) -> Option<OpcodeKind> {\n");
    code.push_str("    if code as usize >= OPCODES.len() {\n");
    code.push_str("        return None;\n");
    code.push_str("    }\n");
    code.push_str("    match &OPCODES[code as usize] {\n");
    code.push_str("        Some(info) => Some(info.kind),\n");
    code.push_str("        None => None,\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // variant_name
    code.push_str("/// Get the name of a variant for an opcode, or \"\" if invalid\n");
    code.push_str("#[inline]\n");
    code.push_str("pub fn variant_name(opcode: u8, variant_id: u8) -> &'static str {\n");
    code.push_str("    if opcode as usize >= VARIANTS.len() {\n");
    code.push_str("        return \"\";\n");
    code.push_str("    }\n");
    code.push_str("    let variants = VARIANTS[opcode as usize];\n");
    code.push_str("    if (variant_id as usize) < variants.len() {\n");
    code.push_str("        variants[variant_id as usize]\n");
    code.push_str("    } else {\n");
    code.push_str("        \"\"\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // domain_name
    code.push_str("/// Get the name of a domain for an opcode, or \"\" if invalid\n");
    code.push_str("#[inline]\n");
    code.push_str("pub fn domain_name(opcode: u8, domain_id: u8) -> &'static str {\n");
    code.push_str("    if opcode as usize >= DOMAINS.len() {\n");
    code.push_str("        return \"\";\n");
    code.push_str("    }\n");
    code.push_str("    let domains = DOMAINS[opcode as usize];\n");
    code.push_str("    if (domain_id as usize) < domains.len() {\n");
    code.push_str("        domains[domain_id as usize]\n");
    code.push_str("    } else {\n");
    code.push_str("        \"\"\n");
    code.push_str("    }\n");
    code.push_str("}\n\n");

    // variant_count
    code.push_str("/// Get the number of variants for an opcode\n");
    code.push_str("#[inline]\n");
    code.push_str("pub fn variant_count(opcode: u8) -> usize {\n");
    code.push_str("    if opcode as usize >= VARIANTS.len() {\n");
    code.push_str("        return 0;\n");
    code.push_str("    }\n");
    code.push_str("    VARIANTS[opcode as usize].len()\n");
    code.push_str("}\n\n");

    // domain_count
    code.push_str("/// Get the number of domains for an opcode\n");
    code.push_str("#[inline]\n");
    code.push_str("pub fn domain_count(opcode: u8) -> usize {\n");
    code.push_str("    if opcode as usize >= DOMAINS.len() {\n");
    code.push_str("        return 0;\n");
    code.push_str("    }\n");
    code.push_str("    DOMAINS[opcode as usize].len()\n");
    code.push_str("}\n\n");

    // field_specs
    code.push_str("/// Get the field specifications for an opcode\n");
    code.push_str("#[inline]\n");
    code.push_str("pub fn field_specs(opcode: u8) -> &'static [FieldSpec] {\n");
    code.push_str("    if opcode as usize >= FIELD_SPECS.len() {\n");
    code.push_str("        return &[];\n");
    code.push_str("    }\n");
    code.push_str("    FIELD_SPECS[opcode as usize]\n");
    code.push_str("}\n\n");

    // is_defined
    code.push_str("/// Check if an opcode is defined\n");
    code.push_str("#[inline]\n");
    code.push_str("pub const fn is_defined(code: u8) -> bool {\n");
    code.push_str("    if code as usize >= OPCODES.len() {\n");
    code.push_str("        return false;\n");
    code.push_str("    }\n");
    code.push_str("    OPCODES[code as usize].is_some()\n");
    code.push_str("}\n");

    code
}
