//! OBJ file export for procedural meshes

use super::types::UnpackedMesh;
use std::io::Write;
use std::path::Path;

/// Write UnpackedMesh to OBJ file format
///
/// Exports mesh data to Wavefront OBJ format with vertices, normals, and optional UVs.
/// The OBJ format uses 1-indexed references.
///
/// # Arguments
/// * `mesh` - The mesh to export
/// * `path` - Output file path
/// * `name` - Object name in the OBJ file
///
/// # Example
/// ```no_run
/// use nethercore_zx::procedural::{generate_sphere, write_obj, UnpackedMesh};
///
/// let mesh: UnpackedMesh = generate_sphere(1.0, 16, 8);
/// write_obj(&mesh, "sphere.obj".as_ref(), "sphere")?;
/// # Ok::<(), std::io::Error>(())
/// ```
pub fn write_obj(mesh: &UnpackedMesh, path: &Path, name: &str) -> std::io::Result<()> {
    let mut file = std::fs::File::create(path)?;

    // Header
    writeln!(file, "# Generated by Nethercore")?;
    writeln!(file, "# Vertices: {}", mesh.positions.len())?;
    writeln!(file, "# Triangles: {}", mesh.indices.len() / 3)?;
    writeln!(file)?;
    writeln!(file, "o {}", name)?;
    writeln!(file)?;

    // Vertices (v x y z)
    for pos in &mesh.positions {
        writeln!(file, "v {} {} {}", pos[0], pos[1], pos[2])?;
    }
    writeln!(file)?;

    // UVs (vt u v) - if present
    if !mesh.uvs.is_empty() {
        for uv in &mesh.uvs {
            writeln!(file, "vt {} {}", uv[0], uv[1])?;
        }
        writeln!(file)?;
    }

    // Normals (vn x y z)
    for norm in &mesh.normals {
        writeln!(file, "vn {} {} {}", norm[0], norm[1], norm[2])?;
    }
    writeln!(file)?;

    // Faces (f v1/vt1/vn1 v2/vt2/vn2 v3/vt3/vn3)
    // OBJ format is 1-indexed!
    for chunk in mesh.indices.chunks(3) {
        if chunk.len() == 3 {
            let v1 = chunk[0] as usize + 1;
            let v2 = chunk[1] as usize + 1;
            let v3 = chunk[2] as usize + 1;

            if mesh.uvs.is_empty() {
                // v//vn format (no UVs)
                writeln!(file, "f {}//{} {}//{} {}//{}", v1, v1, v2, v2, v3, v3)?;
            } else {
                // v/vt/vn format (with UVs)
                writeln!(
                    file,
                    "f {}/{}/{} {}/{}/{} {}/{}/{}",
                    v1, v1, v1, v2, v2, v2, v3, v3, v3
                )?;
            }
        }
    }

    Ok(())
}
