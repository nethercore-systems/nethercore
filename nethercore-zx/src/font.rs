//! Built-in bitmap font for Nethercore ZX
//!
//! Simple 8x8 monospace font covering ASCII 32-126 (printable characters).
//! This is a minimal font suitable for debug text and simple UI.

#![allow(dead_code)] // Public API for text rendering, not yet wired up

/// Width of each glyph in pixels
pub const GLYPH_WIDTH: u32 = 8;
/// Height of each glyph in pixels
pub const GLYPH_HEIGHT: u32 = 8;
/// First character in the font (space)
pub const FIRST_CHAR: u32 = 32;
/// Last character in the font (tilde)
pub const LAST_CHAR: u32 = 126;
/// Number of glyphs in the font
pub const GLYPH_COUNT: u32 = LAST_CHAR - FIRST_CHAR + 1;

/// Font texture atlas dimensions
pub const ATLAS_WIDTH: u32 = 8 * 16; // 16 characters per row
pub const ATLAS_HEIGHT: u32 = 8 * 6; // 6 rows (95 chars / 16 = 5.9375 -> 6 rows)

/// Get the UV coordinates for a character in the font atlas
///
/// Returns (u0, v0, u1, v1) in normalized coordinates [0, 1]
pub fn get_glyph_uv(char_code: u32) -> (f32, f32, f32, f32) {
    if !(FIRST_CHAR..=LAST_CHAR).contains(&char_code) {
        // Return space character for unknown chars
        return get_glyph_uv(FIRST_CHAR);
    }

    let index = char_code - FIRST_CHAR;
    let col = index % 16;
    let row = index / 16;

    let u0 = (col * GLYPH_WIDTH) as f32 / ATLAS_WIDTH as f32;
    let v0 = (row * GLYPH_HEIGHT) as f32 / ATLAS_HEIGHT as f32;
    let u1 = ((col + 1) * GLYPH_WIDTH) as f32 / ATLAS_WIDTH as f32;
    let v1 = ((row + 1) * GLYPH_HEIGHT) as f32 / ATLAS_HEIGHT as f32;

    (u0, v0, u1, v1)
}

/// Generate the font atlas texture data (RGBA8)
///
/// Returns a `Vec<u8>` of size `ATLAS_WIDTH * ATLAS_HEIGHT * 4`
pub fn generate_font_atlas() -> Vec<u8> {
    let width = ATLAS_WIDTH as usize;
    let height = ATLAS_HEIGHT as usize;
    let mut pixels = vec![0u8; width * height * 4];

    // Render each glyph
    for i in 0..GLYPH_COUNT {
        let char_code = FIRST_CHAR + i;
        let col = (i % 16) as usize;
        let row = (i / 16) as usize;
        let x_offset = col * GLYPH_WIDTH as usize;
        let y_offset = row * GLYPH_HEIGHT as usize;

        // Get the glyph bitmap
        let bitmap = get_glyph_bitmap(char_code);

        // Copy to atlas
        for y in 0..GLYPH_HEIGHT as usize {
            for x in 0..GLYPH_WIDTH as usize {
                let atlas_x = x_offset + x;
                let atlas_y = y_offset + y;
                let atlas_idx = (atlas_y * width + atlas_x) * 4;

                let pixel = bitmap[y * GLYPH_WIDTH as usize + x];
                // White text, alpha = pixel value
                pixels[atlas_idx] = 255; // R
                pixels[atlas_idx + 1] = 255; // G
                pixels[atlas_idx + 2] = 255; // B
                pixels[atlas_idx + 3] = pixel; // A
            }
        }
    }

    pixels
}

/// Get the bitmap for a single character (8x8, single channel)
///
/// Returns an array of 64 bytes where each byte is the alpha value (0-255)
fn get_glyph_bitmap(char_code: u32) -> [u8; 64] {
    let mut bitmap = [0u8; 64];

    // Simple 8x8 bitmap font data
    // Each character is represented as 8 bytes (one per row)
    // Each bit represents a pixel (1 = white, 0 = transparent)
    let data = match char_code as u8 {
        b' ' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'!' => [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00],
        b'"' => [0x6C, 0x6C, 0x6C, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'#' => [0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],
        b'$' => [0x0C, 0x3F, 0x68, 0x3E, 0x0B, 0x7E, 0x18, 0x00],
        b'%' => [0x60, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x06, 0x00],
        b'&' => [0x38, 0x6C, 0x6C, 0x38, 0x6D, 0x66, 0x3B, 0x00],
        b'\'' => [0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'(' => [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00],
        b')' => [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00],
        b'*' => [0x00, 0x18, 0x7E, 0x3C, 0x7E, 0x18, 0x00, 0x00],
        b'+' => [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00],
        b',' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30],
        b'-' => [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00],
        b'.' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00],
        b'/' => [0x00, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00, 0x00],
        b'0' => [0x3C, 0x66, 0x6E, 0x7E, 0x76, 0x66, 0x3C, 0x00],
        b'1' => [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
        b'2' => [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x30, 0x7E, 0x00],
        b'3' => [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00],
        b'4' => [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00],
        b'5' => [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00],
        b'6' => [0x1C, 0x30, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00],
        b'7' => [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00],
        b'8' => [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00],
        b'9' => [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x0C, 0x38, 0x00],
        b':' => [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00],
        b';' => [0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30],
        b'<' => [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00],
        b'=' => [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00],
        b'>' => [0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00],
        b'?' => [0x3C, 0x66, 0x0C, 0x18, 0x18, 0x00, 0x18, 0x00],
        b'@' => [0x3C, 0x66, 0x6E, 0x6A, 0x6E, 0x60, 0x3C, 0x00],
        b'A' => [0x3C, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
        b'B' => [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00],
        b'C' => [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00],
        b'D' => [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00],
        b'E' => [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x7E, 0x00],
        b'F' => [0x7E, 0x60, 0x60, 0x7C, 0x60, 0x60, 0x60, 0x00],
        b'G' => [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00],
        b'H' => [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00],
        b'I' => [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00],
        b'J' => [0x3E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00],
        b'K' => [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00],
        b'L' => [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00],
        b'M' => [0x63, 0x77, 0x7F, 0x6B, 0x6B, 0x63, 0x63, 0x00],
        b'N' => [0x66, 0x66, 0x76, 0x7E, 0x6E, 0x66, 0x66, 0x00],
        b'O' => [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
        b'P' => [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00],
        b'Q' => [0x3C, 0x66, 0x66, 0x66, 0x6A, 0x6C, 0x36, 0x00],
        b'R' => [0x7C, 0x66, 0x66, 0x7C, 0x6C, 0x66, 0x66, 0x00],
        b'S' => [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00],
        b'T' => [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        b'U' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00],
        b'V' => [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
        b'W' => [0x63, 0x63, 0x6B, 0x6B, 0x7F, 0x77, 0x63, 0x00],
        b'X' => [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00],
        b'Y' => [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00],
        b'Z' => [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00],
        b'[' => [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00],
        b'\\' => [0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x00, 0x00],
        b']' => [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00],
        b'^' => [0x18, 0x3C, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'_' => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
        b'`' => [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00],
        b'a' => [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00],
        b'b' => [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00],
        b'c' => [0x00, 0x00, 0x3C, 0x66, 0x60, 0x66, 0x3C, 0x00],
        b'd' => [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00],
        b'e' => [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00],
        b'f' => [0x1C, 0x36, 0x30, 0x7C, 0x30, 0x30, 0x30, 0x00],
        b'g' => [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x3C],
        b'h' => [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
        b'i' => [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00],
        b'j' => [0x0C, 0x00, 0x1C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38],
        b'k' => [0x60, 0x60, 0x66, 0x6C, 0x78, 0x6C, 0x66, 0x00],
        b'l' => [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00],
        b'm' => [0x00, 0x00, 0x66, 0x7F, 0x6B, 0x6B, 0x63, 0x00],
        b'n' => [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00],
        b'o' => [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00],
        b'p' => [0x00, 0x00, 0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60],
        b'q' => [0x00, 0x00, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x06],
        b'r' => [0x00, 0x00, 0x6C, 0x76, 0x60, 0x60, 0x60, 0x00],
        b's' => [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00],
        b't' => [0x30, 0x30, 0x7C, 0x30, 0x30, 0x36, 0x1C, 0x00],
        b'u' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00],
        b'v' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00],
        b'w' => [0x00, 0x00, 0x63, 0x6B, 0x6B, 0x7F, 0x36, 0x00],
        b'x' => [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00],
        b'y' => [0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x3C],
        b'z' => [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00],
        b'{' => [0x0C, 0x18, 0x18, 0x30, 0x18, 0x18, 0x0C, 0x00],
        b'|' => [0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00],
        b'}' => [0x30, 0x18, 0x18, 0x0C, 0x18, 0x18, 0x30, 0x00],
        b'~' => [0x31, 0x6B, 0x46, 0x00, 0x00, 0x00, 0x00, 0x00],
        _ => [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // Unknown char
    };

    // Convert bit pattern to alpha values
    for y in 0..8 {
        let row = data[y];
        for x in 0..8 {
            let bit = (row >> (7 - x)) & 1;
            bitmap[y * 8 + x] = if bit == 1 { 255 } else { 0 };
        }
    }

    bitmap
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_glyph_uv() {
        // Test first character (space)
        let (u0, v0, u1, v1) = get_glyph_uv(32);
        assert_eq!(u0, 0.0);
        assert_eq!(v0, 0.0);
        assert_eq!(u1, 8.0 / ATLAS_WIDTH as f32);
        assert_eq!(v1, 8.0 / ATLAS_HEIGHT as f32);

        // Test character outside range
        let (u0_fallback, v0_fallback, _, _) = get_glyph_uv(200);
        assert_eq!(u0_fallback, 0.0); // Should fallback to space
        assert_eq!(v0_fallback, 0.0);
    }

    #[test]
    fn test_atlas_generation() {
        let atlas = generate_font_atlas();
        assert_eq!(atlas.len(), (ATLAS_WIDTH * ATLAS_HEIGHT * 4) as usize);

        // Check that the atlas is not all zeros
        let non_zero = atlas.iter().any(|&b| b != 0);
        assert!(non_zero, "Atlas should contain non-zero values");
    }

    #[test]
    fn test_glyph_bitmap() {
        // Test space character (should be all zeros)
        let bitmap = get_glyph_bitmap(b' ' as u32);
        assert_eq!(bitmap, [0u8; 64]);

        // Test '!' character (should have some non-zero values)
        let bitmap = get_glyph_bitmap(b'!' as u32);
        let has_pixels = bitmap.iter().any(|&b| b != 0);
        assert!(has_pixels, "Exclamation mark should have visible pixels");
    }
}
